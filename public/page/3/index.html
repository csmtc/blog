<!doctype html><html lang=zh-CN data-theme=light><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.145.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="CSMTC Blog"><meta itemprop=description content="分享让自我更强大"><meta name=description content="分享让自我更强大"><meta itemprop=image content="//localhost:1313/images/csmtc.png"><meta itemprop=keywords content="blog"><link type=text/css rel=stylesheet href=//localhost:1313/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=//localhost:1313/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=//localhost:1313/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.css?=1741733787"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>CSMTC Blog</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>CSMTC Blog</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>share make powerful</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class="hvr-icon-pulse menu-item-active" rel=section><i class="fa fa-home hvr-icon"></i>Home</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>Categories</a></li><li class="menu-item menu-item-tag"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tag hvr-icon"></i>Tags</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=CSMTC src=/imgs/img-lazy-loading.gif data-src=/images/csmtc.png><p class=site-author-name itemprop=name>CSMTC</p><div class=site-description itemprop=description>分享让自我更强大</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/><span class=site-state-item-count>29</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>2</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>0</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/csmtc title="Github → https://github.com/csmtc" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=https://gitee.com/csmtce title="Gitee → https://gitee.com/csmtce" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Gitee</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/small/by_nc_sa.svg alt=共享知识></a></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg>
</a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.11-Visitor-%E8%AE%BF%E9%97%AE%E8%80%85/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/images/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="5.11-Visitor-访问者"><meta itemprop=description content="


目的

表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
示例

考虑一个编译器，它将源程序表示为一个抽象语法树，对于语法树结点需要进行不同的处理：类型检查，代码优化等


将操作和结点类耦合带来的问题：将所有这些操作分散到各种结点类中会导致整个系统难以理解、难以维护和修改；此外，增加新的操作通常需要重新编译所有这些类
解决方法：将每一个类中相关的操作包装在一个独立的对象（称为一个 Visitor）中，并在遍历抽象语法树时将此对象传递给当前访问的元素

所有抽象语法树的访问者有一个抽象的父类 NodeVisitor。NodeVisitor 必须为每一个结点类定义一个操作

使用 Visitor 模式，必须定义两个类层次：


一个对应于接受操作的元素（Node 层次）
另一个对应于定义对元素的操作的访问者（NodeVisitor 层次）。给访问者类层次增加一个新的子类即可创建一个新的操作。

适用性


一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。
需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。
定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。

结构




Visitor：接口。为该对象结构中 ConcreteElement 的每一个类声明一个 Visit 操作，该操作的名字和特征标识了发送 Visit 请求给该访问者的类。

访问者就可以通过该元素的特定接口直接访问它。



ConcreteVisitor：实现每个由 Visitor 声明的操作。每种具体的 Visitor 实现一种特定操作


Element，ConcreteElement：定义一个 Accept 操作，它以一个访问者为参数


ObjectStructure（例如 List，Map）：能枚举它的元素，可以提供一个高层的接口以允许该 Visitor 访问它的元素


一个使用 Visitor 模式的客户必须创建一个 ConcreteVisitor 对象，然后遍历该对象结构，并用该访问者访问每一个元素。


当一个元素被访问时，它调用对应于它的类的 Visitor 操作。


效果



访问者模式使得易于增加新的操作：仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。相反，如果每个功能都分散在多个类之上的话，定义新的操作时必须修改每一个类。


访问者集中相关的操作而分离无关的操作：相关的行为不是分布在定义该对象结构的各个类上，而是集中在一个访问者中；无关行为却被分别放在各自的访问者子类中


增加新的 ConcreteElement 类很困难：每添加一个新的 ConcreteElement 都要在 Vistor 中添加一个新的抽象操作，并在每一个 ConcretVisitor 类中实现相应的操作。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.11-Visitor-%E8%AE%BF%E9%97%AE%E8%80%85/ itemprop=url class=post-title-link>5.11-Visitor-访问者</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:54:36 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:54:36 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><ul><li></li></ul><h3 id=目的>目的
<a class=header-anchor href=#%e7%9b%ae%e7%9a%84></a></h3><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><h3 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h3><p>考虑一个编译器，它将源程序表示为一个抽象语法树，对于语法树结点需要进行不同的处理：类型检查，代码优化等
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5.11-Visitor-%E8%AE%BF%E9%97%AE%E8%80%85/image-2023-10-19_18-21-15-257.png alt></p><ul><li>将操作和结点类耦合带来的问题：将所有这些操作分散到各种结点类中会导致整个系统难以理解、难以维护和修改；此外，增加新的操作通常需要重新编译所有这些类</li><li>解决方法：将每一个类中相关的操作包装在一个独立的对象（称为一个 Visitor）中，并在遍历抽象语法树时将此对象传递给当前访问的元素<ul><li>所有抽象语法树的访问者有一个抽象的父类 NodeVisitor。NodeVisitor 必须为每一个结点类定义一个操作
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5.11-Visitor-%E8%AE%BF%E9%97%AE%E8%80%85/image-2023-10-19_18-39-03-846.png alt>
使用 Visitor 模式，必须定义两个类层次：</li></ul></li><li>一个对应于接受操作的元素（Node 层次）</li><li>另一个对应于定义对元素的操作的访问者（NodeVisitor 层次）。给访问者类层次增加一个新的子类即可创建一个新的操作。</li></ul><h3 id=适用性>适用性
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%80%a7></a></h3><ul><li>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。</li><li>需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。</li><li>定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。</li></ul><h3 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h3><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/5.11-Visitor-%E8%AE%BF%E9%97%AE%E8%80%85/image-2023-10-19_18-40-40-846.png alt></p><ul><li><p>Visitor：接口。为该对象结构中 ConcreteElement 的每一个类声明一个 Visit 操作，该操作的名字和特征标识了发送 Visit 请求给该访问者的类。</p><ul><li>访问者就可以通过该元素的特定接口直接访问它。</li></ul></li><li><p>ConcreteVisitor：实现每个由 Visitor 声明的操作。每种具体的 Visitor 实现一种特定操作</p></li><li><p>Element，ConcreteElement：定义一个 Accept 操作，它以一个访问者为参数</p></li><li><p>ObjectStructure（例如 List，Map）：能枚举它的元素，可以提供一个高层的接口以允许该 Visitor 访问它的元素</p></li><li><p>一个使用 Visitor 模式的客户必须创建一个 ConcreteVisitor 对象，然后遍历该对象结构，并用该访问者访问每一个元素。</p></li><li><p>当一个元素被访问时，它调用对应于它的类的 Visitor 操作。</p></li></ul><h3 id=效果>效果
<a class=header-anchor href=#%e6%95%88%e6%9e%9c></a></h3><ul><li><p>访问者模式使得易于增加新的操作：仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。相反，如果每个功能都分散在多个类之上的话，定义新的操作时必须修改每一个类。</p></li><li><p>访问者集中相关的操作而分离无关的操作：相关的行为不是分布在定义该对象结构的各个类上，而是集中在一个访问者中；无关行为却被分别放在各自的访问者子类中</p></li><li><p>增加新的 ConcreteElement 类很困难：每添加一个新的 ConcreteElement 都要在 Vistor 中添加一个新的抽象操作，并在每一个 ConcretVisitor 类中实现相应的操作。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.11-Visitor-%E8%AE%BF%E9%97%AE%E8%80%85/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.4-Iteratorcursor-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/images/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="5.4-Iterator「cursor」-迭代器-行为型模式"><meta itemprop=description content="目的

提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示
示例

一个聚合对象，如列表（list），需要：

提供一种方法来让别人可以访问它的元素，而又不需要暴露它的内部结构
可能要以不同的方式遍历
不希望列表的接口中充斥着各种不同遍历的操作

KEY：将对列表的访问和遍历从列表对象中分离出来并放入一个迭代器（iterator）对象中，由迭代器对象跟踪当前元素，维护遍历序列

将遍历机制与列表对象分离使我们可以对同一个容器定义不同的迭代器来实现不同的遍历策略。例如先序迭代和后序迭代

多态迭代：

为何需要多态：上述方法中，迭代器和列表是耦合在一起的，而且客户对象必须知道遍历的是一个列表而不是其他聚合结构
方法：使用继承和多态机制，并由容器提供 CreateIterator 的接口，创建自己兼容的某种迭代器

这是 Factory Method，产生两个类层次，一个是列表的，一个是迭代器的。 CreateIterator“联系”这两个类层次




适用性


访问一个聚合对象的内容而无须暴露它的内部表示。
支持对聚合对象的多种遍历。
为遍历不同的聚合结构提供一个统一的接口（即支持多态迭代）。

结构



Iterator：定义访问和遍历元素的接口
ConcreteIterator：

实现迭代器接口
对该聚合遍历时跟踪当前位置，并能够计算出待遍历的后继对象


Aggregate（聚合）：定义创建相应迭代器对象的接口。
ConcreteAggregate：实现创建相应迭代器的接口，该操作返回 ConcreteIterator 的一个适当的实例

优缺点

迭代器模式有三个重要的作用：

支持以不同的方式遍历一个聚合
简化了聚合的接口：有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了
在同一个聚合上可以同时有多个遍历：每个迭代器保持它自己的遍历状态，因此你可以同时进行多个遍历

实现

谁控制迭代

控制迭代即控制迭代的推进过程，根据迭代过程是迭代器还是使用该迭代器的客户控制，迭代器可分为内部/外部迭代器 2 类：

外部迭代器：客户必须主动推进遍历的步伐，显式地向迭代器请求下一个元素
内部迭代器：由迭代器控制迭代的推进，客户只需向其提交一个待执行的操作，而迭代器将对聚合中的每一个元素实施该操作。

谁定义遍历算法

迭代器和聚合均可定义遍历算法
聚合定义遍历算法：聚合定义遍历算法，迭代器只存储当前迭代的上下文

在遍历过程中用迭代器来存储当前迭代的状态。我们称这种迭代器为游标（cursor），因为它仅用来指示当前位置。
客户会以这个游标为参数调用该聚合的 Next 操作，而 Next 操作将改变这个指示器的状态

迭代器定义遍历算法：

优点：

易于在相同的聚合上使用不同的迭代算法
易于在不同的聚合上复用相同的算法


缺点：遍历算法可能需要访问聚合的私有变量。如果这样，将遍历算法放入迭代器中会破坏聚合的封装性

遍历时修改

在遍历一个聚合的同时更改这个聚合可能是危险的。如果在遍历聚合的时候增加或删除聚合元素，可能会导致两次访问同一个元素或者遗漏掉某个元素。
一个健壮的迭代器 robust iterator 保证==插入和删除操作不会干扰遍历，且不需要拷贝该聚合==

这大多数需要向聚合注册迭代器。当插入或删除元素时，该聚合需要：

调整迭代器的内部状态
或在内部维护额外的信息以保证正确的遍历。



可选接口

迭代器的最小接口由 First、Next、IsDone 和 CurrentItem 操作组成"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.4-Iteratorcursor-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>5.4-Iterator「cursor」-迭代器-行为型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:54:06 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:54:06 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h3 id=目的>目的
<a class=header-anchor href=#%e7%9b%ae%e7%9a%84></a></h3><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示</p><h3 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h3><p>一个聚合对象，如列表（list），需要：</p><ul><li>提供一种方法来让别人可以访问它的元素，而又不需要暴露它的内部结构</li><li>可能要以不同的方式遍历</li><li>不希望列表的接口中充斥着各种不同遍历的操作</li></ul><p><strong>KEY</strong>：将对列表的访问和遍历从列表对象中分离出来并放入一个迭代器（iterator）对象中，由迭代器对象跟踪当前元素，维护遍历序列</p><ul><li>将遍历机制与列表对象分离使我们可以对同一个容器定义不同的迭代器来实现不同的遍历策略。例如先序迭代和后序迭代</li></ul><p><strong>多态迭代</strong>：</p><ul><li>为何需要多态：上述方法中，迭代器和列表是耦合在一起的，而且客户对象必须知道遍历的是一个列表而不是其他聚合结构</li><li>方法：使用继承和多态机制，并由容器提供 CreateIterator 的接口，创建自己兼容的某种迭代器<ul><li>这是 Factory Method，产生两个类层次，一个是列表的，一个是迭代器的。 CreateIterator“联系”这两个类层次
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5.4-Iterator%E3%80%8Ccursor%E3%80%8D-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-10_09-23-04-798.png alt></li></ul></li></ul><h3 id=适用性>适用性
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%80%a7></a></h3><ul><li>访问一个聚合对象的内容而无须暴露它的内部表示。</li><li>支持对聚合对象的多种遍历。</li><li>为遍历不同的聚合结构提供一个统一的接口（即支持多态迭代）。</li></ul><h3 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h3><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/5.4-Iterator%E3%80%8Ccursor%E3%80%8D-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-10_09-27-45-319.png alt></p><ul><li>Iterator：定义访问和遍历元素的接口</li><li>ConcreteIterator：<ul><li>实现迭代器接口</li><li>对该聚合遍历时<em>跟踪当前位置，并能够计算出待遍历的后继对象</em></li></ul></li><li>Aggregate（聚合）：定义创建相应迭代器对象的接口。</li><li>ConcreteAggregate：实现创建相应迭代器的接口，该操作返回 ConcreteIterator 的一个适当的实例</li></ul><h3 id=优缺点>优缺点
<a class=header-anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9></a></h3><p>迭代器模式有三个重要的作用：</p><ul><li>支持以不同的方式遍历一个聚合</li><li>简化了聚合的接口：有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了</li><li>在同一个聚合上可以同时有多个遍历：每个迭代器保持它自己的遍历状态，因此你可以同时进行多个遍历</li></ul><h3 id=实现>实现
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0></a></h3><h4 id=谁控制迭代>谁控制迭代
<a class=header-anchor href=#%e8%b0%81%e6%8e%a7%e5%88%b6%e8%bf%ad%e4%bb%a3></a></h4><p>控制迭代即控制迭代的推进过程，根据迭代过程是迭代器还是使用该迭代器的客户控制，迭代器可分为内部/外部迭代器 2 类：</p><ul><li><strong>外部迭代器</strong>：客户必须主动推进遍历的步伐，显式地向迭代器请求下一个元素</li><li><strong>内部迭代器</strong>：由迭代器控制迭代的推进，客户只需向其提交一个待执行的操作，而迭代器将对聚合中的每一个元素实施该操作。</li></ul><h4 id=谁定义遍历算法>谁定义遍历算法
<a class=header-anchor href=#%e8%b0%81%e5%ae%9a%e4%b9%89%e9%81%8d%e5%8e%86%e7%ae%97%e6%b3%95></a></h4><p>迭代器和聚合均可定义遍历算法</p><p><strong>聚合定义遍历算法</strong>：<em>聚合定义遍历算法，迭代器只存储当前迭代的上下文</em></p><ul><li>在遍历过程中用迭代器来存储当前迭代的状态。我们称这种迭代器为<strong>游标（cursor）</strong>，因为它仅用来指示当前位置。</li><li>客户会以这个游标为参数调用该聚合的 Next 操作，而 Next 操作将改变这个指示器的状态</li></ul><p><strong>迭代器定义遍历算法</strong>：</p><ul><li>优点：<ul><li>易于在相同的聚合上使用不同的迭代算法</li><li>易于在不同的聚合上复用相同的算法</li></ul></li><li>缺点：遍历算法可能需要访问聚合的私有变量。如果这样，将遍历算法放入迭代器中会破坏聚合的封装性</li></ul><h4 id=遍历时修改>遍历时修改
<a class=header-anchor href=#%e9%81%8d%e5%8e%86%e6%97%b6%e4%bf%ae%e6%94%b9></a></h4><p>在遍历一个聚合的同时更改这个聚合可能是危险的。如果在遍历聚合的时候增加或删除聚合元素，可能会导致两次访问同一个元素或者遗漏掉某个元素。</p><p>一个<strong>健壮的迭代器 robust iterator</strong> 保证==插入和删除操作不会干扰遍历，且不需要拷贝该聚合==</p><ul><li>这大多数需要向聚合注册迭代器。当插入或删除元素时，该聚合需要：<ul><li>调整迭代器的内部状态</li><li>或在内部维护额外的信息以保证正确的遍历。</li></ul></li></ul><h4 id=可选接口>可选接口
<a class=header-anchor href=#%e5%8f%af%e9%80%89%e6%8e%a5%e5%8f%a3></a></h4><p>迭代器的最小接口由 First、Next、IsDone 和 CurrentItem 操作组成</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.4-Iteratorcursor-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.5-Mediator-%E4%B8%AD%E4%BB%8B%E8%80%85-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/images/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="5.5-Mediator-中介者-行为型模式"><meta itemprop=description content="目的

用一个中介对象封装对象交互，使各对象不需要显式地相互引用

从而可以解耦合
可以对立改变之间的交互

示例

面向对象中，对象的行为分布到各个对象中。这种分布可能会导致对象间有许多连接。在最坏的情况下，每一个对象都知道其他所有对象。
考虑 GUI 中各个窗口组件的依赖关系：例如当一个特定的输入域为空时，某个按钮不能使用；ListBox 选择一项可能会改变一个输入域的内容

这导致每个组件必须单独定制以反应组件间的依赖关系
解决方法：可以通过将集体行为封装在一个单独的中介者（mediator）对象中，如下图所设

类层次结构：
对象交互：
例如选择 ListBox 改变 EntryField 的内容

适用性


一组对象以定义良好但复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。
一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。
想定制一个分布在多个类中的行为，而又不想生成太多的子类。

结构



Mediator 中介者：定义和同事 Colleague 通信的接口
ConcreteMediator：了解并维护它的各个同事，处理它们之间的交互
Colleagueclass：

每个同事均了解其中介对象（例如持有一份 Mediator 实例的引用）
每个同事通过中介的接口与其他同事通信



同事向一个中介者对象发送和接收请求。中介者在各同事间适当地转发请求以实现协作行为
优缺点


将各 Colleague 解耦
简化了对象协议：用 Mediator 和各 Colleague 间的一对多交互来代替多对多交互，更易于理解、维护和扩展。
对对象如何协作进行了抽象：将中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象各自本身的行为转移到它们之间的交互上来。
使控制集中化：中介者模式将交互的复杂性变为中介者的复杂性，这可能导致中介者本身复杂而难以维护

实现


简单情形下无需定义抽象中介类：当各 Colleague 仅与一个 Mediator 一起工作时，没有必要定义一个抽象的 Mediator 类
Colleague-Mediator 通信：当一个感兴趣的事件发生时， Colleague 必须与其 Mediator 通信，这有两种实现方法：

使用 Observer（5.7） 模式，将 Mediator 实现为一个 Observer，各 Colleague 作为 Subject

一旦 Subject 状态改变就发送通知给 Mediator
Mediator 将该事件向所有其他 Colleague 转发


在 Mediator 中定义一个特殊的通知接口，各 Colleague 在通信时直接调用该接口



相关模式

Facade（4.5）与中介者的不同之处在于："></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.5-Mediator-%E4%B8%AD%E4%BB%8B%E8%80%85-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>5.5-Mediator-中介者-行为型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:54:12 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:54:12 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h3 id=目的>目的
<a class=header-anchor href=#%e7%9b%ae%e7%9a%84></a></h3><p>用一个中介对象封装对象交互，使各对象不需要显式地相互引用</p><ul><li>从而可以解耦合</li><li>可以对立改变之间的交互</li></ul><h3 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h3><p>面向对象中，对象的行为分布到各个对象中。这种分布可能会导致对象间有许多连接。在最坏的情况下，每一个对象都知道其他所有对象。</p><p>考虑 GUI 中各个窗口组件的依赖关系：例如当一个特定的输入域为空时，某个按钮不能使用；ListBox 选择一项可能会改变一个输入域的内容</p><ul><li>这导致每个组件必须单独定制以反应组件间的依赖关系</li><li>解决方法：可以通过将集体行为封装在一个单独的中介者（mediator）对象中，如下图所设</li></ul><p>类层次结构：<img src=/imgs/img-lazy-loading.gif data-src=./assets/5.5-Mediator-%E4%B8%AD%E4%BB%8B%E8%80%85-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-12_15-58-26-968.png alt>
对象交互：<img src=/imgs/img-lazy-loading.gif data-src=./assets/5.5-Mediator-%E4%B8%AD%E4%BB%8B%E8%80%85-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-12_15-52-46-168.png alt>
例如选择 ListBox 改变 EntryField 的内容
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5.5-Mediator-%E4%B8%AD%E4%BB%8B%E8%80%85-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-12_15-53-31-871.png alt></p><h3 id=适用性>适用性
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%80%a7></a></h3><ul><li>一组对象以定义良好但复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。</li><li>一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。</li><li>想定制一个分布在多个类中的行为，而又不想生成太多的子类。</li></ul><h3 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h3><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/5.5-Mediator-%E4%B8%AD%E4%BB%8B%E8%80%85-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-12_16-00-15-284.png alt></p><ul><li>Mediator 中介者：定义和同事 Colleague 通信的接口</li><li>ConcreteMediator：了解并维护它的各个同事，处理它们之间的交互</li><li>Colleagueclass：<ul><li>每个同事均了解其中介对象（例如持有一份 Mediator 实例的引用）</li><li>每个同事通过中介的接口与其他同事通信</li></ul></li></ul><p>同事向一个中介者对象发送和接收请求。中介者在各同事间适当地转发请求以实现协作行为</p><h3 id=优缺点>优缺点
<a class=header-anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9></a></h3><ul><li>将各 Colleague 解耦</li><li>简化了对象协议：用 Mediator 和各 Colleague 间的一对多交互来代替多对多交互，更易于理解、维护和扩展。</li><li>对对象如何协作进行了抽象：将中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象各自本身的行为转移到它们之间的交互上来。</li><li>使控制集中化：中介者模式将交互的复杂性变为中介者的复杂性，这可能导致中介者本身复杂而难以维护</li></ul><h3 id=实现>实现
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0></a></h3><ul><li>简单情形下无需定义抽象中介类：当各 Colleague 仅与一个 Mediator 一起工作时，没有必要定义一个抽象的 Mediator 类</li><li>Colleague-Mediator 通信：当一个感兴趣的事件发生时， Colleague 必须与其 Mediator 通信，这有两种实现方法：<ul><li>使用 Observer（5.7） 模式，将 Mediator 实现为一个 Observer，各 Colleague 作为 Subject<ul><li>一旦 Subject 状态改变就发送通知给 Mediator</li><li>Mediator 将该事件向所有其他 Colleague 转发</li></ul></li><li>在 Mediator 中定义一个特殊的通知接口，各 Colleague 在通信时直接调用该接口</li></ul></li></ul><h3 id=相关模式>相关模式
<a class=header-anchor href=#%e7%9b%b8%e5%85%b3%e6%a8%a1%e5%bc%8f></a></h3><p>Facade（4.5）与中介者的不同之处在于：</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.5-Mediator-%E4%B8%AD%E4%BB%8B%E8%80%85-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.6-MementoToken-%E5%A4%87%E5%BF%98%E5%BD%95-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/images/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="5.6-Memento「Token」-备忘录-行为型模式"><meta itemprop=description content="目的

在不破坏封装性的前提下捕获对象内部状态，在对象外保存该状态以备恢复
示例

一个图形编辑器，它支持图形对象间的连线。用户可用一条直线连接两个矩形，而当用户移动任意一个矩形时，这两个矩形仍能保持连接

考虑需要撤销移动命令的情形：

备忘录存储内部状态：某个对象（称为原发器 originator ）保存自身某个瞬间的内部状态为备忘录对象。
对象可以导出内部状态为备忘录：当需要设置原发器的检查点时，取消操作机制会向原发器请求一个备忘录。
也可以依据备忘录恢复内部状态：需要恢复时，编辑器向原发器提供备忘录供其恢复内部状态

譬如计算图形对象连线的 ConstraintSolver 类，可以作为原发器：考虑取消移动的过程：

作为移动操作的一个副作用，编辑器向 ConstraintSolver 请求一个备忘录；ConstraintSolver 创建并返回一个备忘录
此后当用户取消移动操作时，编辑器将上次请求的备忘录送回给 ConstraintSolver
ConstraintSolver 改变它的内部结构以精确地将它的等式和变量返回到它们各自先前的状态

结构



Memento 备忘录：备忘录存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态

防止原发器以外的其他对象访问备忘录。备忘录实际上有两个接口，

管理者（caretaker）只能看到备忘录的窄接口——它只能将备忘录传递给其他对象。
原发器能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。


理想的情况是只允许生成本备忘录的那个原发器访问本备忘录的内部状态。


Originator 原发器：原发器创建一个备忘录，用以记录当前时刻它的内部状态；并使用备忘录恢复内部状态
Caretaker 管理者：负责保存好备忘录，但不能访问或修改备忘录的内容

管理者向原发器请求一个备忘录，保留一段时间后，在需要回退状态时将其送回给原发器
优缺点


保护封装性
简化了原发器：Originator 无需考虑如何保存客户请求过的各个内部状态版本，版本管理由 caretaker 完成。
复制状态的开销：若生成备忘录时必须拷贝并存储大量的信息，或者客户非常频繁地创建备忘录和恢复原发器状态，可能会导致非常大的开销

可能需要使用增量修改


维护状态的开销：管理者负责删除它所维护的备忘录。然而，管理者不知道备忘录中有多少个状态。因此当存储备忘录时，一个本来很小的管理者可能会产生大量的存储开销
宽窄接口：在一些语言中可能难以保证只有原发器可访问备忘录的状态。

实现

宽窄接口

备忘录有两个接口：一个为原发器所使用的宽接口，一个为其他对象所使用的窄接口。
C++中，可将 Originator 作为 Memento 的一个友元，并使 Memento 宽接口为私有的，窄接口为公共的
增量改变

如果备忘录的创建及其返回（给它们的原发器）的顺序是可预测的，备忘录可以仅存储原发器内部状态的增量改变。
例如，一个包含可撤销的命令的历史列表可使用备忘录：

存在一个历史列表，定义了一个特定的顺序，按照这个顺序命令可以被撤销和重做
备忘录可以只存储一个命令所产生的增量改变而不是它所影响的每一个对象的完整状态

相关模式

Command（5.2）：命令可使用备忘录来为可撤销的操作维护状态。
Iterator（5.4）：如前所述，备忘录可用于迭代。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.6-MementoToken-%E5%A4%87%E5%BF%98%E5%BD%95-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>5.6-Memento「Token」-备忘录-行为型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:54:16 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:54:16 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h4 id=目的>目的
<a class=header-anchor href=#%e7%9b%ae%e7%9a%84></a></h4><p>在不破坏封装性的前提下捕获对象内部状态，在对象外保存该状态以备恢复</p><h3 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h3><p>一个图形编辑器，它支持图形对象间的连线。用户可用一条直线连接两个矩形，而当用户移动任意一个矩形时，这两个矩形仍能保持连接
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5.6-Memento%E3%80%8CToken%E3%80%8D-%E5%A4%87%E5%BF%98%E5%BD%95-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-13_17-44-47-122.png alt>
考虑需要撤销移动命令的情形：</p><ul><li>备忘录存储内部状态：某个对象（称为原发器 originator ）保存自身某个瞬间的内部状态为备忘录对象。</li><li>对象可以导出内部状态为备忘录：当需要设置原发器的检查点时，取消操作机制会<em>向原发器</em>请求一个备忘录。</li><li>也可以依据备忘录恢复内部状态：需要恢复时，编辑器向原发器提供备忘录供其恢复内部状态</li></ul><p>譬如计算图形对象连线的 ConstraintSolver 类，可以作为原发器：考虑取消移动的过程：</p><ul><li>作为移动操作的一个副作用，编辑器向 ConstraintSolver 请求一个备忘录；ConstraintSolver 创建并返回一个备忘录</li><li>此后当用户取消移动操作时，编辑器将上次请求的备忘录送回给 ConstraintSolver</li><li>ConstraintSolver 改变它的内部结构以精确地将它的等式和变量返回到它们各自先前的状态</li></ul><h3 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h3><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/5.6-Memento%E3%80%8CToken%E3%80%8D-%E5%A4%87%E5%BF%98%E5%BD%95-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-13_17-55-11-564.png alt></p><ul><li>Memento 备忘录：备忘录存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态<ul><li>防止原发器以外的其他对象访问备忘录。备忘录实际上有两个接口，<ul><li>管理者（caretaker）只能看到备忘录的窄接口——它只能将备忘录传递给其他对象。</li><li>原发器能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。</li></ul></li><li>理想的情况是只允许生成本备忘录的那个原发器访问本备忘录的内部状态。</li></ul></li><li>Originator 原发器：原发器创建一个备忘录，用以记录当前时刻它的内部状态；并使用备忘录恢复内部状态</li><li>Caretaker 管理者：负责保存好备忘录，但不能访问或修改备忘录的内容</li></ul><p>管理者向原发器请求一个备忘录，保留一段时间后，在需要回退状态时将其送回给原发器</p><h3 id=优缺点>优缺点
<a class=header-anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9></a></h3><ul><li>保护封装性</li><li>简化了原发器：Originator 无需考虑如何保存客户请求过的各个内部状态版本，版本管理由 caretaker 完成。</li><li>复制状态的开销：若生成备忘录时必须拷贝并存储大量的信息，或者客户非常频繁地创建备忘录和恢复原发器状态，可能会导致非常大的开销<ul><li>可能需要使用增量修改</li></ul></li><li>维护状态的开销：管理者负责删除它所维护的备忘录。然而，管理者不知道备忘录中有多少个状态。因此当存储备忘录时，一个本来很小的管理者可能会产生大量的存储开销</li><li>宽窄接口：在一些语言中可能难以保证只有原发器可访问备忘录的状态。</li></ul><h3 id=实现>实现
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0></a></h3><h4 id=宽窄接口>宽窄接口
<a class=header-anchor href=#%e5%ae%bd%e7%aa%84%e6%8e%a5%e5%8f%a3></a></h4><p>备忘录有两个接口：一个为原发器所使用的宽接口，一个为其他对象所使用的窄接口。</p><p>C++中，可将 Originator 作为 Memento 的一个友元，并使 Memento 宽接口为私有的，窄接口为公共的</p><h4 id=增量改变>增量改变
<a class=header-anchor href=#%e5%a2%9e%e9%87%8f%e6%94%b9%e5%8f%98></a></h4><p>如果备忘录的创建及其返回（给它们的原发器）的顺序是可预测的，备忘录可以仅存储原发器内部状态的增量改变。</p><p>例如，一个包含可撤销的命令的历史列表可使用备忘录：</p><ul><li>存在一个历史列表，定义了一个特定的顺序，按照这个顺序命令可以被撤销和重做</li><li>备忘录可以只存储一个命令所产生的增量改变而不是它所影响的每一个对象的完整状态</li></ul><h3 id=相关模式>相关模式
<a class=header-anchor href=#%e7%9b%b8%e5%85%b3%e6%a8%a1%e5%bc%8f></a></h3><p>Command（5.2）：命令可使用备忘录来为可撤销的操作维护状态。
Iterator（5.4）：如前所述，备忘录可用于迭代。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.6-MementoToken-%E5%A4%87%E5%BF%98%E5%BD%95-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.8-StateObject-for-state-%E7%8A%B6%E6%80%81-%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/images/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="5.8-State「Object for state」-状态-状态对象-行为型模式"><meta itemprop=description content="目的

允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类
示例

考虑一个表示网络连接的类 TCPConnection。
一个 TCPConnection 对象的状态处于若干不同状态之一：连接已建立（Established）、正在监听（Listening）、连接已关闭（Closed）。
当一个 TCPConnection 对象收到其他对象的请求时，它根据自身的当前状态做出不同的反应。

State 模式：

Key：引入了一个称为 TCPState 的抽象类来表示网络的连接状态：

TCPState 类为各表示不同的操作状态的子类声明了一个公共接口。
TCPState 的子类实现与特定状态相关的行为


TCPConnection 类维护一个表示 TCP 连接当前状态的状态对象（TCPState 子类的实例）

将所有与状态相关的请求委托给该对象
一旦连接状态改变，TCPConnection 对象就会改变它所使用的状态对象



适用性


一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。
一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。

State 模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化



结构



Context：定义面向客户的接口

维护 ConcreteState 实例，表征当前状态


State：定义接口，封装与 Context 的特定状态相关的行为
ConcreteStateX：每一子类实现一个与 Context 的一个状态相关的行为

关联

Context 将与状态相关的请求委托给当前的 ConcreteState 对象处理。

Context 可将自身作为一个参数传递给处理该请求的状态对象。这使得状态对象在必要时可访问 Context。
Context 是客户使用的主要接口。客户可用状态对象来配置一个 Context，一旦一个 Context 配置完毕，它的客户不再需要直接与状态对象打交道。


Context 或 ConcreteState 子类都可决定哪个状态是另外一个的后继者，以及是在何种条件下进行状态转换。

效果

将不同状态的行为分割开来：

不用 State 模式：使用数据值定义内部状态并且让 Context 操作来显式地检查这些数据。但这样将会使整个 Context 的实现中遍布看起来很相似的条件语句或 case 语句
使用 State 模式：

避免了庞大的条件语句
每一个状态转换和动作封装到一个类中，就把着眼点从执行状态提高到整个对象的状态。这将使代码结构化并使其意图更加清晰。



确保内部状态变量的一致性：从 Context 的角度看，状态转换是原子的——只需重新绑定一个 ConcreteState 实例，而无需为一组变量分别赋值。（仅以内部数据值来定义当前状态时，其状态仅表现为对一些变量的赋值）"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.8-StateObject-for-state-%E7%8A%B6%E6%80%81-%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>5.8-State「Object for state」-状态-状态对象-行为型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:54:24 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:54:24 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h3 id=目的>目的
<a class=header-anchor href=#%e7%9b%ae%e7%9a%84></a></h3><p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类</p><h3 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h3><p>考虑一个表示网络连接的类 TCPConnection。
一个 TCPConnection 对象的状态处于若干不同状态之一：连接已建立（Established）、正在监听（Listening）、连接已关闭（Closed）。
当一个 TCPConnection 对象收到其他对象的请求时，它根据自身的当前状态做出不同的反应。
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5.8-State%E3%80%8CObject%20for%20state%E3%80%8D-%E7%8A%B6%E6%80%81-%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-18_17-19-21-774.png alt></p><p>State 模式：</p><ul><li>Key：引入了一个称为 TCPState 的抽象类来表示网络的连接状态：<ul><li>TCPState 类为各表示不同的操作状态的子类声明了一个公共接口。</li><li>TCPState 的子类实现与特定状态相关的行为</li></ul></li><li>TCPConnection 类维护一个表示 TCP 连接当前状态的状态对象（TCPState 子类的实例）<ul><li>将所有与状态相关的请求委托给该对象</li><li>一旦连接状态改变，TCPConnection 对象就会改变它所使用的状态对象</li></ul></li></ul><h3 id=适用性>适用性
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%80%a7></a></h3><ul><li>一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。</li><li>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。<ul><li>State 模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化</li></ul></li></ul><h3 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h3><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/5.8-State%E3%80%8CObject%20for%20state%E3%80%8D-%E7%8A%B6%E6%80%81-%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-18_17-25-04-181.png alt></p><ul><li>Context：定义面向客户的接口<ul><li>维护 ConcreteState 实例，表征当前状态</li></ul></li><li>State：定义接口，封装与 Context 的特定状态相关的行为</li><li>ConcreteStateX：每一子类实现一个与 Context 的一个状态相关的行为</li></ul><p><strong>关联</strong></p><ul><li>Context 将与状态相关的请求委托给当前的 ConcreteState 对象处理。<ul><li>Context 可将自身作为一个参数传递给处理该请求的状态对象。这使得状态对象在必要时可访问 Context。</li><li>Context 是客户使用的主要接口。客户可用状态对象来配置一个 Context，一旦一个 Context 配置完毕，它的客户不再需要直接与状态对象打交道。</li></ul></li><li>Context 或 ConcreteState 子类都可决定哪个状态是另外一个的后继者，以及是在何种条件下进行状态转换。</li></ul><h3 id=效果>效果
<a class=header-anchor href=#%e6%95%88%e6%9e%9c></a></h3><p><strong>将不同状态的行为分割开来</strong>：</p><ul><li>不用 State 模式：使用数据值定义内部状态并且让 Context 操作来显式地检查这些数据。但这样将会使整个 Context 的实现中遍布看起来很相似的条件语句或 case 语句</li><li>使用 State 模式：<ul><li>避免了庞大的条件语句</li><li>每一个状态转换和动作封装到一个类中，就把着眼点从执行状态提高到整个对象的状态。这将使代码结构化并使其意图更加清晰。</li></ul></li></ul><p><strong>确保内部状态变量的一致性</strong>：从 Context 的角度看，状态转换是原子的——只需重新绑定一个 ConcreteState 实例，而无需为一组变量分别赋值。（仅以内部数据值来定义当前状态时，其状态仅表现为对一些变量的赋值）</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.8-StateObject-for-state-%E7%8A%B6%E6%80%81-%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.9-StrategyPolicy-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/images/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="5.9-Strategy「Policy」-策略模式"><meta itemprop=description content="目的

封装算法，使之可以独立于客户变化
示例

文本分行有多种算法

若将程序类包含多种算法的代码，则使程序庞杂难维护
并非任何时候都需要所有的算法
若将算法嵌入客户程序内部，则变更算法将十分困难



Composition 维护对 Compositor 对象的一个引用。一旦 Composition 重新格式化它的文本，它就将这个职责转发给它的 Compositor 对象
Compositor 的子类实现具体的分行算法

适用性


许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。
需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。
算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。
一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的 Strategy 类中以代替这些条件语句。

结构



Strategy：算法的公共接口，Context 调用该接口
ConcreteStrategy：实现具体的策略
Context：用一个 ConcreteStrategy 对象来配置，维护一个 Strategy 实例，提供接口让 Strategy 访问其数据

Strategy 和 Context 相互作用以实现选定的算法。

客户仅与 Context 交互，通常创建并传递一个 Concrete-Strategy 对象给该 Context
Context 将客户的请求转发给它的 Strategy。
当算法被调用时， Context 可以将该算法所需要的所有数据都传递给该 Strategy。

或者 Context 可以将自身作为一个参数传递给 Strategy 操作，以便 Strategy 在适当时候回调。



效果


降低 Context 的复杂度：将算法和 Context 解耦合，易于切换算法
有利于复用算法
允许客户根据具体的时间/空间需要选择具体算法，但相应地，这意味着需要客户了解不同的 Strategy 之间的差异
消除了大量的条件判断：Context 内嵌多种算法/行为时，通常需要大量条件语句来选择合适的行为
缺陷
冗余参数：不同的 ConcreteStrategy 需要不同的参数集，因此抽象父类定义的接口必须提供这些参数集的并集。

这就意味着有时 Context 会创建和初始化一些永远不会用到的参数
如果存在这样的问题，那么将需要在 Strategy 和 Context 之间进行更紧密的耦合。


对象的数目：Strategy 增加了一个应用中的对象的数目。有时你可以将 Strategy 实现为可供各 Context 共享的无状态的对象来减少这一开销

实现

关于 Strategy 和 Context 的接口

这些接口必须让 ConcreteStrategy 能够有效地访问它所需要的 Context 中的任何数据，实现上有两种方法："></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.9-StrategyPolicy-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>5.9-Strategy「Policy」-策略模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:54:27 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:54:27 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h3 id=目的>目的
<a class=header-anchor href=#%e7%9b%ae%e7%9a%84></a></h3><p>封装算法，使之可以独立于客户变化</p><h3 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h3><p>文本分行有多种算法</p><ul><li>若将程序类包含多种算法的代码，则使程序庞杂难维护</li><li>并非任何时候都需要所有的算法</li><li>若将算法嵌入客户程序内部，则变更算法将十分困难</li></ul><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/5.9-Strategy%E3%80%8CPolicy%E3%80%8D-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/image-2023-10-18_20-27-56-390.png alt></p><ul><li>Composition 维护对 Compositor 对象的一个引用。一旦 Composition 重新格式化它的文本，它就将这个职责转发给它的 Compositor 对象</li><li>Compositor 的子类实现具体的分行算法</li></ul><h3 id=适用性>适用性
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%80%a7></a></h3><ul><li>许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。</li><li>需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。</li><li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的 Strategy 类中以代替这些条件语句。</li></ul><h3 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h3><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/5.9-Strategy%E3%80%8CPolicy%E3%80%8D-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/image-2023-10-19_16-10-40-788.png alt></p><ul><li>Strategy：算法的公共接口，Context 调用该接口</li><li>ConcreteStrategy：实现具体的策略</li><li>Context：用一个 ConcreteStrategy 对象来配置，维护一个 Strategy 实例，提供接口让 Strategy 访问其数据</li></ul><p>Strategy 和 Context 相互作用以实现选定的算法。</p><ul><li>客户仅与 Context 交互，通常创建并传递一个 Concrete-Strategy 对象给该 Context</li><li>Context 将客户的请求转发给它的 Strategy。</li><li>当算法被调用时， Context 可以将该算法所需要的所有数据都传递给该 Strategy。<ul><li>或者 Context 可以将自身作为一个参数传递给 Strategy 操作，以便 Strategy 在适当时候回调。</li></ul></li></ul><h3 id=效果>效果
<a class=header-anchor href=#%e6%95%88%e6%9e%9c></a></h3><ul><li>降低 Context 的复杂度：将算法和 Context 解耦合，易于切换算法</li><li>有利于复用算法</li><li>允许客户根据具体的时间/空间需要选择具体算法，但相应地，这意味着需要客户了解不同的 Strategy 之间的差异</li><li>消除了大量的条件判断：Context 内嵌多种算法/行为时，通常需要大量条件语句来选择合适的行为
缺陷</li><li>冗余参数：不同的 ConcreteStrategy 需要不同的参数集，因此抽象父类定义的接口必须提供这些参数集的并集。<ul><li>这就意味着有时 Context 会创建和初始化一些永远不会用到的参数</li><li>如果存在这样的问题，那么将需要在 Strategy 和 Context 之间进行更紧密的耦合。</li></ul></li><li>对象的数目：Strategy 增加了一个应用中的对象的数目。有时你可以将 Strategy 实现为可供各 Context 共享的无状态的对象来减少这一开销</li></ul><h3 id=实现>实现
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0></a></h3><h4 id=关于-strategy-和-context-的接口>关于 Strategy 和 Context 的接口
<a class=header-anchor href=#%e5%85%b3%e4%ba%8e-strategy-%e5%92%8c-context-%e7%9a%84%e6%8e%a5%e5%8f%a3></a></h4><p>这些接口必须让 ConcreteStrategy 能够有效地访问它所需要的 Context 中的任何数据，实现上有两种方法：</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.9-StrategyPolicy-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.2-CommandActionTransaction-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E4%BD%9C%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/images/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="5.2-Command「Action,Transaction」-命令模式-动作模式-事务模式-行为型模式"><meta itemprop=description content="目的

将请求封装为对象，从而可用不同的请求：

对客户行为参数化
对请求排队或记录日志
支持可撤销的操作

示例

有时必须向某对象提交请求，但并不知道关于被请求的操作或请求的接收者的任何信息。

  
    例如，用户界面工具箱包括按钮和菜单这样的对象，它们执行请求响应用户输入。但工具箱不能显式地在按钮或菜单中实现该请求，因为只有使用工具箱的应用知道该由哪个对象做哪个操作。
  
命令模式通过将请求本身变成一个可存储对象来使工具箱对象可向未指定的应用对象提出请求。

关键是一个抽象的 Command 类，它定义了一个执行操作的接口。
Command 子类将接收者作为它的一个实例变量，并实现 Execute 操作



  
    例如，PasteCommand 支持从剪贴板向一个文档（document）粘贴正文。
PasteCommand 的接收者是一个文档对象，该对象是实例化时提供的。Execute 操作将调用该 Document 的 Paste 操作。

  
MacroCommand：有时一个操作需要多个子操作完成，因此可定义 MacroCommand 执行一个命令序列

MacroCommand 没有明确的接收者，而序列中的命令各自定义其接收者。


优势：灵活。因为提交一个请求的对象仅需要知道如何提交它，而不需要知道该请求将会被如何执行。

一个应用如果想让一个菜单与一个按钮代表同一项功能，只需让它们共享相应具体 Command 子类的同一个实例即可
可以动态地替换 Command 对象，这可用于实现上下文有关的菜单
可通过将几个命令组成更大的命令的形式来支持命令脚本

适用性


抽象出待执行的动作以参数化某对象（Command 模式是回调机制的一个面向对象的替代品）
在不同的时刻指定、排列和执行请求。一个 Command 对象可以有一个与初始请求无关的生存期。
支持取消操作：Command 的 Excute 操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。
支持修改日志：当系统崩溃后，可从磁盘中重新读入记录下来的命令并用 Execute 操作重新执行它们。（Command 接口中需添加装载操作和存储操作）
用构建在原语操作上的高层操作构造一个系统：在支持事务（transaction）的信息系统中，一个事务封装了对数据的一组变动。

Command 模式提供了对事务进行建模的方法。



结构



Command：操作的接口
ConcreteCommand：将一个接收者对象绑定于一个动作，调用接收者相应的操作，以实现 Execute
Invoker（示例中的MenuItem）：要求该命令执行这个请求
Receiver（示例中的 Document）：知道如何实施与执行一个请求相关的操作

工作流程："></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.2-CommandActionTransaction-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E4%BD%9C%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>5.2-Command「Action,Transaction」-命令模式-动作模式-事务模式-行为型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:57 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:57 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:54:02 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:54:02 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h3 id=目的>目的
<a class=header-anchor href=#%e7%9b%ae%e7%9a%84></a></h3><p>将请求封装为对象，从而可用不同的请求：</p><ul><li>对客户行为参数化</li><li>对请求排队或记录日志</li><li>支持可撤销的操作</li></ul><h3 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h3><p>有时必须向某对象提交请求，但并不知道关于被请求的操作或请求的接收者的任何信息。</p><blockquote><p>例如，用户界面工具箱包括按钮和菜单这样的对象，它们执行请求响应用户输入。但工具箱不能显式地在按钮或菜单中实现该请求，因为只有使用工具箱的应用知道该由哪个对象做哪个操作。</p></blockquote><p><strong>命令模式</strong>通过将请求本身变成一个<em>可存储对象</em>来使工具箱对象可向未指定的应用对象提出请求。</p><ul><li>关键是一个抽象的 Command 类，它定义了一个执行操作的接口。</li><li>Command 子类将接收者作为它的一个实例变量，并实现 Execute 操作
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5.2-Command%E3%80%8CAction,Transaction%E3%80%8D-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E4%BD%9C%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-34-53-110.png alt></li></ul><blockquote><p>例如，PasteCommand 支持从剪贴板向一个文档（document）粘贴正文。
PasteCommand 的接收者是一个文档对象，该对象是实例化时提供的。Execute 操作将调用该 Document 的 Paste 操作。
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5.2-Command%E3%80%8CAction,Transaction%E3%80%8D-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E4%BD%9C%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-44-14-818.png alt></p></blockquote><p><strong>MacroCommand</strong>：有时一个操作需要多个子操作完成，因此可定义 MacroCommand 执行一个命令序列</p><ul><li>MacroCommand 没有明确的接收者，而序列中的命令各自定义其接收者。
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5.2-Command%E3%80%8CAction,Transaction%E3%80%8D-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E4%BD%9C%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-47-37-766.png alt></li></ul><p><strong>优势：灵活</strong>。因为<em>提交一个请求的对象仅需要知道如何提交它，而不需要知道该请求将会被如何执行</em>。</p><ul><li>一个应用如果想让一个菜单与一个按钮代表同一项功能，只需让它们共享相应具体 Command 子类的同一个实例即可</li><li>可以动态地替换 Command 对象，这可用于实现上下文有关的菜单</li><li>可通过将几个命令组成更大的命令的形式来支持命令脚本</li></ul><h3 id=适用性>适用性
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%80%a7></a></h3><ul><li>抽象出待执行的动作以参数化某对象（Command 模式是回调机制的一个面向对象的替代品）</li><li>在不同的时刻指定、排列和执行请求。一个 Command 对象可以有一个与初始请求无关的生存期。</li><li>支持取消操作：Command 的 Excute 操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。</li><li>支持修改日志：当系统崩溃后，可从磁盘中重新读入记录下来的命令并用 Execute 操作重新执行它们。（Command 接口中需添加装载操作和存储操作）</li><li>用构建在原语操作上的高层操作构造一个系统：在支持事务（transaction）的信息系统中，一个事务封装了对数据的一组变动。<ul><li>Command 模式提供了对事务进行建模的方法。</li></ul></li></ul><h3 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h3><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/5.2-Command%E3%80%8CAction,Transaction%E3%80%8D-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E4%BD%9C%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-57-10-433.png alt></p><ul><li>Command：操作的接口</li><li>ConcreteCommand：将一个接收者对象绑定于一个动作，调用接收者相应的操作，以实现 Execute</li><li>Invoker（示例中的MenuItem）：要求该命令执行这个请求</li><li>Receiver（示例中的 Document）：知道如何实施与执行一个请求相关的操作</li></ul><p><strong>工作流程</strong>：</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.2-CommandActionTransaction-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E4%BD%9C%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.7-Observerpublish-subscribedependent-%E8%A7%82%E5%AF%9F%E8%80%85-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85-%E4%BE%9D%E8%B5%96/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/images/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="5.7-Observer「publish-subscribe,dependent」-观察者-发布订阅-依赖"><meta itemprop=description content="用途

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新
示例

将一个系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的一致性

  
    视图 View 依赖数据 Data
一个目标 Subject/publish 可以有任意数目的依赖它的观察者 Observer/subscribe。一旦目标的状态发生改变，所有的观察者都得到通知。
收到通知后，每个观察者都将查询目标以使其状态与目标的状态同步。
  

适用性


一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中，以使它们可以各自独立地改变和复用。
对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。
一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，你不希望这些对象是紧密耦合的。

结构



Subject（目标）

目标知道它的观察者。可以有任意多个观察者观察同一个目标。
状态改变时，通知自身的观察者
提供注册和删除观察者对象的接口。


ConcreteSubject（具体目标）：

为观察者提供获取/设置状态的接口


Observer（观察者）：为那些在目标发生改变时需要获得通知的对象定义一个更新接口。
ConcreteObserver：

维护一个指向 ConcreteSubject 对象的引用
存储状态，这些状态与 ConcreteSubject 的状态保持一致
实现 Observer 的更新接口，以使自身状态与目标的状态保持一致。



交互时序

当 ConcreteSubject 发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者。
在得到一个具体目标的改变通知后，ConcreteObserver 对象可向目标对象查询信息。ConcreteObserver 使用这些信息使它的状态与目标对象的状态一致。


注意：

观察者 setState 后不会立即更新自身状态，而是等到被 notify 后再更新
Notify 不总是由目标对象调用，它也可被一个观察者或其他对象调用。

效果

Publisher 和 Subscriber 彼此独立，允许增加新的观察者而无需对现有的 Publisher/Subscriber 做任何修改

低耦合：一个目标所知道的仅仅是它有一系列观察者，每个都符合抽象的 Observer 类的简单接口，而不知道其具体类型

一个处于较低层次的目标对象可与一个处于较高层次的观察者通信并通知它，反之则不行：

如果目标和观察者混在一块，那么得到的对象要么横贯两个层次（违反了层次性），要么必须放在这两层的某一层中（这可能会损害层次抽象）。




支持广播通信
意外的更新：

在目标上一个看似无害的的操作可能会引起一系列对观察者以及依赖于这些观察者的对象的更新
如果依赖准则的定义或维护不当，常常会引起错误的更新，这种错误通常很难捕捉。



实现

创建目标到其观察者之间的映射："></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.7-Observerpublish-subscribedependent-%E8%A7%82%E5%AF%9F%E8%80%85-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85-%E4%BE%9D%E8%B5%96/ itemprop=url class=post-title-link>5.7-Observer「publish-subscribe,dependent」-观察者-发布订阅-依赖</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:57 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:57 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:54:20 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:54:20 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h3 id=用途>用途
<a class=header-anchor href=#%e7%94%a8%e9%80%94></a></h3><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</p><h3 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h3><p>将一个系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的一致性</p><blockquote><p>视图 View 依赖数据 Data
一个目标 Subject/publish 可以有任意数目的依赖它的观察者 Observer/subscribe。一旦目标的状态发生改变，所有的观察者都得到通知。
收到通知后，每个观察者都将查询目标以使其状态与目标的状态同步。</p></blockquote><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/5.7-Observer%E3%80%8Cpublish-subscribe,dependent%E3%80%8D-%E8%A7%82%E5%AF%9F%E8%80%85-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85-%E4%BE%9D%E8%B5%96/image-2023-10-13_18-16-12-168.png alt></p><h3 id=适用性>适用性
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%80%a7></a></h3><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中，以使它们可以各自独立地改变和复用。</li><li>对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。</li><li>一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，你不希望这些对象是紧密耦合的。</li></ul><h3 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h3><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/5.7-Observer%E3%80%8Cpublish-subscribe,dependent%E3%80%8D-%E8%A7%82%E5%AF%9F%E8%80%85-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85-%E4%BE%9D%E8%B5%96/image-2023-10-13_18-18-30-331.png alt></p><ul><li>Subject（目标）<ul><li>目标知道它的观察者。可以有任意多个观察者观察同一个目标。</li><li>状态改变时，通知自身的观察者</li><li>提供注册和删除观察者对象的接口。</li></ul></li><li>ConcreteSubject（具体目标）：<ul><li>为观察者提供获取/设置状态的接口</li></ul></li><li>Observer（观察者）：为那些在目标发生改变时需要获得通知的对象定义一个更新接口。</li><li>ConcreteObserver：<ul><li>维护一个指向 ConcreteSubject 对象的引用</li><li>存储状态，这些状态与 ConcreteSubject 的状态保持一致</li><li>实现 Observer 的更新接口，以使自身状态与目标的状态保持一致。</li></ul></li></ul><p><strong>交互时序</strong></p><ul><li>当 ConcreteSubject 发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者。</li><li>在得到一个具体目标的改变通知后，ConcreteObserver 对象可向目标对象查询信息。ConcreteObserver 使用这些信息使它的状态与目标对象的状态一致。
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5.7-Observer%E3%80%8Cpublish-subscribe,dependent%E3%80%8D-%E8%A7%82%E5%AF%9F%E8%80%85-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85-%E4%BE%9D%E8%B5%96/image-2023-10-13_18-26-01-479.png alt></li></ul><p><strong>注意</strong>：</p><ul><li>观察者 setState 后不会立即更新自身状态，而是等到被 notify 后再更新</li><li>Notify 不总是由目标对象调用，它也可被一个观察者或其他对象调用。</li></ul><h3 id=效果>效果
<a class=header-anchor href=#%e6%95%88%e6%9e%9c></a></h3><p>Publisher 和 Subscriber 彼此独立，允许增加新的观察者而无需对现有的 Publisher/Subscriber 做任何修改</p><ul><li>低耦合：一个目标所知道的仅仅是它有一系列观察者，每个都符合抽象的 Observer 类的简单接口，而不知道其具体类型<ul><li>一个处于较低层次的目标对象可与一个处于较高层次的观察者通信并通知它，反之则不行：<ul><li>如果目标和观察者混在一块，那么得到的对象要么横贯两个层次（违反了层次性），要么必须放在这两层的某一层中（这可能会损害层次抽象）。</li></ul></li></ul></li><li>支持广播通信</li><li>意外的更新：<ul><li>在目标上一个看似无害的的操作可能会引起一系列对观察者以及依赖于这些观察者的对象的更新</li><li>如果依赖准则的定义或维护不当，常常会引起错误的更新，这种错误通常很难捕捉。</li></ul></li></ul><h3 id=实现>实现
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0></a></h3><p><strong>创建目标到其观察者之间的映射</strong>：</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.7-Observerpublish-subscribedependent-%E8%A7%82%E5%AF%9F%E8%80%85-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85-%E4%BE%9D%E8%B5%96/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/Work/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E9%A2%98%E7%9B%AE/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/images/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="LeetCode刷题记录-动态规划"><meta itemprop=description content="动态规划问题

这类问题的求解思路是：

先尝试有 Cache 的暴力搜索，列出递推式
将上述搜索转化为使用 dp 数组的方法



    70. 爬楼梯
    
    
    


假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

\begin{cases}
f(n)=f(n-2)+f(n-1)\\
f(<=0)=0,f(1)=1,f(2)=2
\end{cases}



    746. 使用最小花费爬楼梯
    
    
    


给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。

支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。



    62. 不同路径
    
    
    


一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/Work/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E9%A2%98%E7%9B%AE/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/ itemprop=url class=post-title-link>LeetCode刷题记录-动态规划</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-02-17 16:50:13 +00:00" itemprop="dateCreated datePublished" datetime="2024-02-17 16:50:13 +0000 UTC">2024-02-17
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 00:38:38 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 00:38:38 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ itemprop=url rel=index><span itemprop=name>算法与数据结构</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=动态规划问题>动态规划问题
<a class=header-anchor href=#%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e9%97%ae%e9%a2%98></a></h1><p>这类问题的求解思路是：</p><ul><li>先尝试有 Cache 的暴力搜索，列出递推式</li><li>将上述搜索转化为使用 dp 数组的方法</li></ul><h3 id=70-爬楼梯><a href=https://leetcode.cn/problems/climbing-stairs/description/ title="70. 爬楼梯" rel="noopener external nofollow noreferrer" target=_blank class=exturl>70. 爬楼梯
<i class="fa fa-external-link-alt"></i>
</a><a class=header-anchor href=#70-%e7%88%ac%e6%a5%bc%e6%a2%af></a></h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。
每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><div class="math display">\begin{cases}
f(n)=f(n-2)+f(n-1)\\
f(<=0)=0,f(1)=1,f(2)=2
\end{cases}</div><h3 id=746-使用最小花费爬楼梯><a href=https://leetcode.cn/problems/min-cost-climbing-stairs/ title="746. 使用最小花费爬楼梯" rel="noopener external nofollow noreferrer" target=_blank class=exturl>746. 使用最小花费爬楼梯
<i class="fa fa-external-link-alt"></i>
</a><a class=header-anchor href=#746-%e4%bd%bf%e7%94%a8%e6%9c%80%e5%b0%8f%e8%8a%b1%e8%b4%b9%e7%88%ac%e6%a5%bc%e6%a2%af></a></h3><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。</p><ul><li>支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。</li></ul><h3 id=62-不同路径><a href=https://leetcode.cn/problems/unique-paths/ title="62. 不同路径" rel="noopener external nofollow noreferrer" target=_blank class=exturl>62. 不同路径
<i class="fa fa-external-link-alt"></i>
</a><a class=header-anchor href=#62-%e4%b8%8d%e5%90%8c%e8%b7%af%e5%be%84></a></h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/Work/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E9%A2%98%E7%9B%AE/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/page/2/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/>1</a>
<a class=page-number href=/page/2/>2</a>
<span class="page-number current">3</span></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2024 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>CSMTC</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.145.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.7.2 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script class=next-config data-name=page type=application/json>{"comments":false,"expired":false,"isHome":true,"isPage":false,"math":{"js":{"file":"es5/tex-mml-svg.js","name":"mathjax","version":"3.2.2"},"render":"mathjax"},"path":"localhost:1313","permalink":"//localhost:1313/","title":"CSMTC Blog","toc":true,"waline":{"commentcnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/comment.js","name":"comment","version":"2.15.8"}}}</script><script type=text/javascript src=//localhost:1313/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=//localhost:1313/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"//localhost:1313/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"slideInRight","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":true,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"//localhost:1313/js/3rd"}},"version":"4.7.2","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"2.15.8"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"2.15.8"}}}</script><script type=text/javascript src="/js/main.js?=1741733787" defer></script><script>MathJax={tex:{inlineMath:[["$","$"]],macros:{"\\":"\\\\"}},displayMath:[["$$","$$"],["[[","]]"]],svg:{fontCache:"global"}}</script></body></html>