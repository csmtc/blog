<!doctype html><html lang=zh-CN data-theme=light><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.145.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Posts"><meta itemprop=description content="分享让自我更强大"><meta name=description content="分享让自我更强大"><meta itemprop=image content="//localhost:1313/imgs/csmtc.png"><meta itemprop=keywords content="blog"><link type=text/css rel=stylesheet href=//localhost:1313/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=//localhost:1313/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=//localhost:1313/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.css?=1741730422"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>post - CSMTC Blog</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>CSMTC Blog</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>share make powerful</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>Home</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>Categories</a></li><li class="menu-item menu-item-tag"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tag hvr-icon"></i>Tags</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=CSMTC src=/imgs/img-lazy-loading.gif data-src=/imgs/csmtc.png><p class=site-author-name itemprop=name>CSMTC</p><div class=site-description itemprop=description>分享让自我更强大</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/><span class=site-state-item-count>29</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>2</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>0</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/csmtc title="Github → https://github.com/csmtc" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=https://gitee.com/csmtce title="Gitee → https://gitee.com/csmtce" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Gitee</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/small/by_nc_sa.svg alt=共享知识></a></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg>
</a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.5-singleton-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="3.5-Singleton-单例模式-对象创建模式"><meta itemprop=description content="用途

保证一个类仅有一个实例，并提供一个访问它的全局访问点。
示例

让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求），并且它可以提供一个访问该实例的方法。
适用性


唯一实例应该是通过子类化可扩展的，并且客户应该无须更改代码就能使用一个扩展的实例时。
类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。

结构



Singleton：定义一个 Instance 操作，允许客户访问它的唯一实例。Instance 是
一个类操作（即 Java 中的一个类方法和 C++中的一个静态成员函数）。

客户只能通过 Singleton 的 Instance 操作访问一个 Singleton 的实例。
优缺点


对唯一实例的受控访问：因为 Singleton 类封装它的唯一实例，所以它可以严格地控制客户怎样以及何时访问它。
缩小名字空间：Singleton 模式是对全局变量的一种改进，它避免了那些存储唯一实例的全局变量污染名字空间。
允许可变数目的实例：可以用相同的方法来控制应用所使用的实例的数目。
比类操作更灵活：C++等语言不允许一个类有多个实例。此外，C++中的静态成员函数不是虚函数，因此子类不能多态地重定义它们。

实现

类型定义

方法实现：在 Instance 方法中懒初始化



注意构造器是 protected 的。试图直接实例化 Singleton 的客户将得到一个编译时的错误信息。这就保证了仅有一个实例可以被创建。


关于全局变量法实现单例的问题：在 C++中将单件定义为一个全局或静态的对象，然后依赖于自动初始化，这是不够的（应当使用静态成员函数）。这是因为：

不能保证静态对象只有一个实例会被声明
可能没有足够的信息在静态初始化时实例化每一个单件（例如初始化需要依赖后续计算的值）
C++没有定义转换单元（translation unit）上全局对象的构造器的调用顺序



使用一个 Singleton 创建不同类型的单件

由 Singleton 派生子类，不同子类用于创建不同单件
对于 C++：在不同的文件中创建不同的 Singleton 的实现，然后链接时选择具体的实现。
使用单件注册表：可能的 Singleton 类的集合不是由 Instance 定义的。Singleton 类可以根据名字在一个众所周知的注册表（存储实例名→单件实例的映射关系）中注册它们的单件实例；收到请求时查询相应的单件（如果存在的话）并返回它。

Singleton 类不再负责创建单件。它的主要职责是使得供选择的单件对象在系统中可以被访问
所有可能的 Singleton 子类的实例都必须被创建，否则它们不会被注册






如何实现单件注册表："></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.5-singleton-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>3.5-Singleton-单例模式-对象创建模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:53:17 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:53:17 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h4 id=用途>用途
<a class=header-anchor href=#%e7%94%a8%e9%80%94></a></h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h4 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h4><p>让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求），并且它可以提供一个访问该实例的方法。</p><h4 id=适用性>适用性
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%80%a7></a></h4><ul><li>唯一实例应该是通过子类化可扩展的，并且客户应该无须更改代码就能使用一个扩展的实例时。</li><li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</li></ul><h4 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h4><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/3.5-Singleton-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/image-2023-09-26_16-43-30-386.png alt></p><ul><li>Singleton：定义一个 Instance 操作，允许客户访问它的唯一实例。Instance 是
一个类操作（即 Java 中的一个类方法和 C++中的一个静态成员函数）。</li></ul><p>客户只能通过 Singleton 的 Instance 操作访问一个 Singleton 的实例。</p><h4 id=优缺点>优缺点
<a class=header-anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9></a></h4><ul><li>对唯一实例的受控访问：因为 Singleton 类封装它的唯一实例，所以它可以严格地控制客户怎样以及何时访问它。</li><li>缩小名字空间：Singleton 模式是对全局变量的一种改进，它避免了那些存储唯一实例的全局变量污染名字空间。</li><li>允许可变数目的实例：可以用相同的方法来控制应用所使用的实例的数目。</li><li>比类操作更灵活：C++等语言不允许一个类有多个实例。此外，C++中的静态成员函数不是虚函数，因此子类不能多态地重定义它们。</li></ul><h4 id=实现>实现
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0></a></h4><p>类型定义
<img src=/imgs/img-lazy-loading.gif data-src=./assets/3.5-Singleton-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/image-2023-09-26_16-50-46-325.png alt>
方法实现：在 Instance 方法中懒初始化
<img src=/imgs/img-lazy-loading.gif data-src=./assets/3.5-Singleton-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/image-2023-09-26_16-50-57-559.png alt></p><ul><li><p>注意构造器是 protected 的。试图直接实例化 Singleton 的客户将得到一个编译时的错误信息。这就保证了仅有一个实例可以被创建。</p></li><li><p>关于全局变量法实现单例的问题：在 C++中将单件定义为一个全局或静态的对象，然后依赖于自动初始化，这是不够的（应当使用静态成员函数）。这是因为：</p><ul><li>不能保证静态对象只有一个实例会被声明</li><li>可能没有足够的信息在静态初始化时实例化每一个单件（例如初始化需要依赖后续计算的值）</li><li>C++没有定义转换单元（translation unit）上全局对象的构造器的调用顺序</li></ul></li><li><p><strong>使用一个 Singleton 创建不同类型的单件</strong></p><ul><li>由 Singleton 派生子类，不同子类用于创建不同单件</li><li>对于 C++：在不同的文件中创建不同的 Singleton 的实现，然后链接时选择具体的实现。</li><li>使用<strong>单件注册表</strong>：可能的 Singleton 类的集合不是由 Instance 定义的。Singleton 类可以根据名字在一个众所周知的注册表（存储实例名→单件实例的映射关系）中注册它们的单件实例；收到请求时查询相应的单件（如果存在的话）并返回它。<ul><li>Singleton 类不再负责创建单件。它的主要职责是使得供选择的单件对象在系统中可以被访问</li><li>所有可能的 Singleton 子类的实例都必须被创建，否则它们不会被注册
<img src=/imgs/img-lazy-loading.gif data-src=./assets/3.5-Singleton-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/image-2023-09-26_17-15-24-020.png alt></li></ul></li></ul></li></ul><p>如何实现单件注册表：</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.5-singleton-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="4-结构型模式"><meta itemprop=description content="结构型模式涉及如何组合类和对象以获得更大的结构。结构型类模式采用继承机制来组合接口或实现。

Adapter（4.1）模式：适配器使得一个接口（adaptee 的接口）与其他接口兼容，从而给出多个不同接口的统一抽象。
Composite（4.3）模式是结构型对象模式的一个实例。它描述了如何构造一个类层次式结构，这一结构由两种类型的对象（基元对象和组合对象）所对应的类构成。

组合对象可以组合基元对象和组合对象


Flyweight（4.6）模式为了共享对象定义了一个结构。

为何要求对象共享：效率和一致性。使用对象共享而不是进行对象复制，可以节省大量的空间资源。
Flyweight 的对象共享机制主要强调对象的空间效率


Proxy（4.7）模式中，proxy 对象作为其他对象的一个方便的替代或占位符。

它可以在局部空间中代表一个远程地址空间中的对象
可以表示一个要求被加载的较大的对象



0.1.1 Adapter、Facade 与 Bridge

Adapter 与 Bridge共同点：

都给另一对象提供了一定程度的间接性，因而有利于系统的灵活性
都涉及从自身以外的一个接口向这个对象转发请求。

Adapter 与 Bridge不同点：

用途：

Adapter 模式主要是为了解决两个已有接口之间不匹配的问题。它不考虑这些接口是怎样实现的，也不考虑它们各自可能会如何演化
Bridge 模式则对抽象接口与它的（可能是多个）实现部分进行桥接。虽然这一模式允许你修改实现它的类，但是它仍然为用户提供了一个稳定的接口。


阶段：

Adapter 模式在类已经设计好后实施，其目的一般是避免代码重复。此处耦合不可预见。
Bridge 模式在设计类之前实施：一个抽象将有多个实现部分，并且抽象和实现两者是独立演化的



facade 定义一个新的接口，而 Adapter 则复用一个原有的接口（适配器使两个已有的接口协同工作而非定义新的接口）
0.1.2 Composite、Decorator

Composite（4.3）模式和 Decorator（4.4）

相同点：仅限于都是递归组合
不同点：

Decorator 用于添加功能而不产生新的子类
Composite 用于构造类


"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>4-结构型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:53:22 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:53:22 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>结构型模式涉及如何组合类和对象以获得更大的结构。结构型类模式采用继承机制来组合接口或实现。</p><ul><li>Adapter（4.1）模式：适配器使得一个接口（adaptee 的接口）与其他接口兼容，从而给出多个不同接口的统一抽象。</li><li>Composite（4.3）模式是结构型对象模式的一个实例。它描述了如何构造一个类层次式结构，这一结构由两种类型的对象（基元对象和组合对象）所对应的类构成。<ul><li>组合对象可以组合基元对象和组合对象</li></ul></li><li>Flyweight（4.6）模式为了共享对象定义了一个结构。<ul><li>为何要求对象共享：效率和一致性。使用对象共享而不是进行对象复制，可以节省大量的空间资源。</li><li>Flyweight 的对象共享机制主要强调对象的空间效率</li></ul></li><li>Proxy（4.7）模式中，proxy 对象作为其他对象的一个方便的替代或占位符。<ul><li>它可以在局部空间中代表一个远程地址空间中的对象</li><li>可以表示一个要求被加载的较大的对象</li></ul></li></ul><h3 id=011-adapterfacade-与-bridge>0.1.1 Adapter、Facade 与 Bridge
<a class=header-anchor href=#011-adapterfacade-%e4%b8%8e-bridge></a></h3><p>Adapter 与 Bridge共同点：</p><ul><li>都给另一对象提供了一定程度的间接性，因而有利于系统的灵活性</li><li>都涉及从自身以外的一个接口向这个对象转发请求。</li></ul><p>Adapter 与 Bridge不同点：</p><ul><li>用途：<ul><li>Adapter 模式主要是为了解决两个已有接口之间不匹配的问题。它不考虑这些接口是怎样实现的，也不考虑它们各自可能会如何演化</li><li>Bridge 模式则对抽象接口与它的（可能是多个）实现部分进行桥接。虽然这一模式允许你修改实现它的类，但是它仍然为用户提供了一个稳定的接口。</li></ul></li><li>阶段：<ul><li>Adapter 模式在类已经设计好后实施，其目的一般是避免代码重复。此处耦合不可预见。</li><li>Bridge 模式在设计类之前实施：一个抽象将有多个实现部分，并且抽象和实现两者是独立演化的</li></ul></li></ul><p>facade 定义一个新的接口，而 Adapter 则复用一个原有的接口（适配器使两个已有的接口协同工作而非定义新的接口）</p><h3 id=012-compositedecorator>0.1.2 Composite、Decorator
<a class=header-anchor href=#012-compositedecorator></a></h3><p>Composite（4.3）模式和 Decorator（4.4）</p><ul><li>相同点：仅限于都是递归组合</li><li>不同点：<ul><li>Decorator 用于添加功能而不产生新的子类</li><li>Composite 用于构造类</li></ul></li></ul></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.1-adapterwrapper-%E9%80%82%E9%85%8D%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="4.1-Adapter「wrapper」-适配器-结构型模式"><meta itemprop=description content="又称包装器（wrapper）
用途

将一个类的接口转换成客户希望的另外一个接口。

Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
Adapter 经常还要负责提供那些被匹配的类所没有提供的功能

示例

已有类型 A 的接口和实现，考虑使之适配类型 B 的接口：

类版本：继承 B 的接口和 A 的实现
对象版本：类型 B 中存储一个类型 A 的实例，调用其接口实现类型 B 的自身接口

例如：有一个 TreeDisplay 窗口组件用于展示目录树，现在要展示继承层次树
结构

类适配器：Adapter 同时继承 Target 和 Adaptee

对象适配器

参与者

Target（Shape）：定义 Client 使用的与特定领域相关的接口。
Client（DrawingEditor）：与符合 Target 接口的对象协同。
Adaptee（TextView）：定义一个已经存在的接口，这个接口需要适配。
Adapter（TextShape）：对 Adaptee 的接口与 Target 接口进行适配。

Client 调用 Adapter 的接口，然后 Adapter 调用 Adaptee 接口实现请求
适用情形


你想使用一个已经存在的类，而它的接口不符合你的需求。
你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。
（仅适用于对象 Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。

优缺点

类适配器和对象适配器互有优缺点：

类适配器

优点：Adapter 可以重定义 Adaptee 的部分行为，因为 Adapter 是 Adaptee 的一个子类。
缺点：无法兼容该 Adaptee 的子类型


对象适配器

可以兼容 Adaptee 的子类型
重定义 Adaptee 的行为较为困难（需要构建 Adaptee 的新子类，并在 Adapter 中引用该类型）



实现

使用 C++实现适配器类

在使用 C++实现适配器类时，Adapter 类应该采用公共方式继承 Target 类，并且用私有方式继承 Adaptee 类。因此，Adapter 类应该是 Target 的子类型，但不是 Adaptee 的子类型。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.1-adapterwrapper-%E9%80%82%E9%85%8D%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>4.1-Adapter「wrapper」-适配器-结构型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:53:26 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:53:26 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>又称包装器（wrapper）</p><h4 id=用途>用途
<a class=header-anchor href=#%e7%94%a8%e9%80%94></a></h4><p>将一个类的接口转换成客户希望的另外一个接口。</p><ul><li>Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li><li>Adapter 经常还要负责提供那些被匹配的类所没有提供的功能</li></ul><h4 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h4><p>已有类型 A 的接口和实现，考虑使之适配类型 B 的接口：</p><ul><li>类版本：继承 B 的接口和 A 的实现</li><li>对象版本：类型 B 中存储一个类型 A 的实例，调用其接口实现类型 B 的自身接口</li></ul><p>例如：有一个 TreeDisplay 窗口组件用于展示目录树，现在要展示继承层次树</p><h4 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h4><p>类适配器：Adapter 同时继承 Target 和 Adaptee
<img src=/imgs/img-lazy-loading.gif data-src=./assets/4.1-Adapter%E3%80%8Cwrapper%E3%80%8D-%E9%80%82%E9%85%8D%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-28_15-07-30-553.png alt>
对象适配器
<img src=/imgs/img-lazy-loading.gif data-src=./assets/4.1-Adapter%E3%80%8Cwrapper%E3%80%8D-%E9%80%82%E9%85%8D%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-28_15-08-24-490.png alt></p><p><strong>参与者</strong></p><ul><li>Target（Shape）：定义 Client 使用的与特定领域相关的接口。</li><li>Client（DrawingEditor）：与符合 Target 接口的对象协同。</li><li>Adaptee（TextView）：定义一个已经存在的接口，这个接口需要适配。</li><li>Adapter（TextShape）：对 Adaptee 的接口与 Target 接口进行适配。</li></ul><p>Client 调用 Adapter 的接口，然后 Adapter 调用 Adaptee 接口实现请求</p><h4 id=适用情形>适用情形
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%83%85%e5%bd%a2></a></h4><ul><li>你想使用一个已经存在的类，而它的接口不符合你的需求。</li><li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。</li><li>（仅适用于对象 Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li></ul><h4 id=优缺点>优缺点
<a class=header-anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9></a></h4><p>类适配器和对象适配器互有优缺点：</p><ul><li>类适配器<ul><li>优点：Adapter 可以重定义 Adaptee 的部分行为，因为 Adapter 是 Adaptee 的一个子类。</li><li>缺点：无法兼容该 Adaptee 的子类型</li></ul></li><li>对象适配器<ul><li>可以兼容 Adaptee 的子类型</li><li>重定义 Adaptee 的行为较为困难（需要构建 Adaptee 的新子类，并在 Adapter 中引用该类型）</li></ul></li></ul><h3 id=实现>实现
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0></a></h3><h4 id=使用-c实现适配器类>使用 C++实现适配器类
<a class=header-anchor href=#%e4%bd%bf%e7%94%a8-c%e5%ae%9e%e7%8e%b0%e9%80%82%e9%85%8d%e5%99%a8%e7%b1%bb></a></h4><p>在使用 C++实现适配器类时，Adapter 类应该采用公共方式继承 Target 类，并且用私有方式继承 Adaptee 类。因此，Adapter 类应该是 Target 的子类型，但不是 Adaptee 的子类型。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.1-adapterwrapper-%E9%80%82%E9%85%8D%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.2-bridgehandle-%E6%A1%A5%E6%8E%A5-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="4.2-Bridge「Handle」-桥接-结构型模式"><meta itemprop=description content="又称 Handle/Body
0.1.1 用途

将抽象部分与它的实现部分分离，使它们可以独立地变化。
继承 VS Bridge：

0.1.2 示例

场景：一个 GUI 工具箱中的可移植窗口需要支持 XWindows 和 PM 系统
实现方法：

继承：定义 Window 抽象类和它的两个子类 XWindow 与 PMWindow，由它们分别实现不同系统平台上的 Window 界面。

缺陷：

扩展 Window 抽象使之适用于不同种类的窗口或新的系统平台很不方便（需要为 Windows 的每个子类针对每个平台分别创建一个类）
继承机制使得客户代码与平台相关。




Bridge 模式：将接口抽象和实现放在彼此独立的类层次结构中：

对 Window 子类的所有操作都是用 WindowImp 接口中的抽象操作实现的
将 Window 与 WindowImp 之间的关系称为桥接，它在抽象类与它的实现之间起到了桥梁作用，使它们可以独立地变化。




0.1.3 适用性


不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如，这种情况可能是因为，在程序运行时实现部分应可以被选择或者切换。
类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时 Bridge 模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。
对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。
（C++）你想对客户完全隐藏抽象的实现部分。在 C++中，类的表示在类接口中是可见的。
若采用继承模式会有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。

Rumbaugh 称这种类层次结构为“嵌套的泛化”（nested generalization） [RBP+91]。


你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。

0.1.4 结构



Abstraction：抽象接口（例如示例中的 Window），维护一个指向实现（Implementor）的指针
RefinedAbstraction：精化的接口（例如示例中的 IconWindow）
Implementor：实现类的接口（示例中的 WindowImp）

该接口无需和 Abstraction 的接口一致。一般来讲：

Implementor 接口仅提供基本操作
Abstraction 则定义了基于这些基本操作的较高层次的操作




ConcreteImplementor：实现 Implementor 的具体接口（示例中的 XWindowImp、PMWindowImp）

Abstraction 将 client 的请求转发给它的 Implementor 对象"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.2-bridgehandle-%E6%A1%A5%E6%8E%A5-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>4.2-Bridge「Handle」-桥接-结构型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:53:32 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:53:32 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>又称 Handle/Body</p><h3 id=011-用途>0.1.1 用途
<a class=header-anchor href=#011-%e7%94%a8%e9%80%94></a></h3><h2 id=继承-vs-bridge>将抽象部分与它的实现部分分离，使它们可以独立地变化。
继承 VS Bridge：
<a class=header-anchor href=#%e7%bb%a7%e6%89%bf-vs-bridge></a></h2><h3 id=012-示例>0.1.2 示例
<a class=header-anchor href=#012-%e7%a4%ba%e4%be%8b></a></h3><p>场景：一个 GUI 工具箱中的可移植窗口需要支持 XWindows 和 PM 系统
实现方法：</p><ul><li>继承：定义 Window 抽象类和它的两个子类 XWindow 与 PMWindow，由它们分别实现不同系统平台上的 Window 界面。<ul><li>缺陷：<ul><li>扩展 Window 抽象使之适用于不同种类的窗口或新的系统平台很不方便（需要为 Windows 的每个子类针对每个平台分别创建一个类）</li><li>继承机制使得客户代码与平台相关。</li></ul></li></ul></li><li>Bridge 模式：将接口抽象和实现放在彼此独立的类层次结构中：<ul><li>对 Window 子类的所有操作都是用 WindowImp 接口中的抽象操作实现的</li><li>将 Window 与 WindowImp 之间的关系称为<strong>桥接</strong>，它在抽象类与它的实现之间起到了桥梁作用，使它们可以独立地变化。</li></ul></li></ul><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/4.2-Bridge%E3%80%8CHandle%E3%80%8D-%E6%A1%A5%E6%8E%A5-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-28_17-37-36-790.png alt></p><h3 id=013-适用性>0.1.3 适用性
<a class=header-anchor href=#013-%e9%80%82%e7%94%a8%e6%80%a7></a></h3><ul><li>不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如，这种情况可能是因为，在程序运行时实现部分应可以被选择或者切换。</li><li>类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时 Bridge 模式使你可以<em>对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充</em>。</li><li>对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。</li><li>（C++）你想对客户完全隐藏抽象的实现部分。在 C++中，类的表示在类接口中是可见的。</li><li>若采用继承模式会有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。<ul><li>Rumbaugh 称这种类层次结构为“嵌套的泛化”（nested generalization） [RBP+91]。</li></ul></li><li>你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。</li></ul><h3 id=014-结构>0.1.4 结构
<a class=header-anchor href=#014-%e7%bb%93%e6%9e%84></a></h3><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/4.2-Bridge%E3%80%8CHandle%E3%80%8D-%E6%A1%A5%E6%8E%A5-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-28_18-21-07-218.png alt></p><ul><li>Abstraction：抽象接口（例如示例中的 Window），维护一个指向实现（Implementor）的指针</li><li>RefinedAbstraction：精化的接口（例如示例中的 IconWindow）</li><li>Implementor：实现类的接口（示例中的 WindowImp）<ul><li>该接口无需和 Abstraction 的接口一致。一般来讲：<ul><li><em>Implementor 接口仅提供基本操作</em></li><li><em>Abstraction 则定义了基于这些基本操作的较高层次的操作</em></li></ul></li></ul></li><li>ConcreteImplementor：实现 Implementor 的具体接口（示例中的 XWindowImp、PMWindowImp）</li></ul><p>Abstraction 将 client 的请求转发给它的 Implementor 对象</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.2-bridgehandle-%E6%A1%A5%E6%8E%A5-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.3-composite-%E7%BB%84%E5%90%88-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="4.3-Composite-组合-结构型模式"><meta itemprop=description content="目的


将对象组合成树形结构以表示“部分–整体”的层次结构。
Composite 使得用户对单个对象和组合对象的使用具有一致性。

示例

例如 GUI 框架允许用户可以组合多个简单组件以递归形成一些较大的组件。这有 2 种实现方式：

使用图元类和容器类：使用这些类的代码必须区别对待图元对象与容器对象，而实际上大多数情况下用户认为它们是一样的。
使用 Composite 模式递归构建

Composite 模式的关键是一个抽象类，它既可以代表图元，又可以代表图元的容器。其内部提供图元和图元容器所需的所有接口

它的图元子类（树的叶结点，Line，Text 等）无需实现容器相关的操作
聚合类 Picture 定义了一个 Graphic 的集合，它的 Draw 递归调用子部件的 Draw 操作。由于 Picture 接口与 Graphic 接口是一致的，因此 Picture 对象可以递归地组合其他 Picture 对象。


适用性


你想表示对象的部分–整体层次结构。
你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

结构

组合结构如下：

继承结构如下：

参与者

Component：

提供 Leaf 所需的操作，提供用于访问管理 Component 子组件所需的操作
通常需要，实现所有类共有接口的默认行为
如果需要，在 Component 类中提供访问父组件的接口，Leaf 和 Composite 按需实现这个接口。

父部件引用可以简化结构的上移和组件的删除




Composite（Picture）

定义有子部件的那些部件的行为。
存储子部件。
在 Component 接口中实现与子部件有关的操作。


Leaf：定义图元对象的行为
Client：通过 Component 接口操纵组合部件的对象

用户使用 Component 类接口与组合结构中的对象进行交互。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.3-composite-%E7%BB%84%E5%90%88-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>4.3-Composite-组合-结构型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:53:36 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:53:36 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h3 id=目的>目的
<a class=header-anchor href=#%e7%9b%ae%e7%9a%84></a></h3><ul><li>将对象组合成<em>树形结构</em>以表示“部分–整体”的层次结构。</li><li>Composite 使得用户<em>对单个对象和组合对象的使用具有一致性</em>。</li></ul><h3 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h3><p>例如 GUI 框架允许用户可以组合多个简单组件以递归形成一些较大的组件。这有 2 种实现方式：</p><ul><li>使用图元类和容器类：使用这些类的代码必须区别对待图元对象与容器对象，而实际上大多数情况下用户认为它们是一样的。</li><li>使用 Composite 模式递归构建</li></ul><p>Composite 模式的关键是一个抽象类，它既可以代表图元，又可以代表图元的容器。其内部提供图元和图元容器所需的所有接口</p><ul><li>它的图元子类（树的叶结点，Line，Text 等）无需实现容器相关的操作</li><li>聚合类 Picture 定义了一个 Graphic 的集合，它的 Draw 递归调用子部件的 Draw 操作。由于 Picture 接口与 Graphic 接口是一致的，因此 Picture 对象可以递归地组合其他 Picture 对象。
<img src=/imgs/img-lazy-loading.gif data-src=./assets/4.3-Composite-%E7%BB%84%E5%90%88-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-30_09-37-45-676.png alt></li></ul><h3 id=适用性>适用性
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%80%a7></a></h3><ul><li>你想表示对象的部分–整体层次结构。</li><li>你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li></ul><h3 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h3><p>组合结构如下：
<img src=/imgs/img-lazy-loading.gif data-src=./assets/4.3-Composite-%E7%BB%84%E5%90%88-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-30_09-40-59-855.png alt>
继承结构如下：
<img src=/imgs/img-lazy-loading.gif data-src=./assets/4.3-Composite-%E7%BB%84%E5%90%88-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-30_09-40-54-198.png alt></p><p><strong>参与者</strong></p><ul><li>Component：<ul><li>提供 Leaf 所需的操作，提供用于访问管理 Component 子组件所需的操作</li><li>通常需要，实现所有类共有接口的默认行为</li><li>如果需要，在 Component 类中提供访问父组件的接口，Leaf 和 Composite 按需实现这个接口。<ul><li>父部件引用可以简化结构的上移和组件的删除</li></ul></li></ul></li><li>Composite（Picture）<ul><li>定义有子部件的那些部件的行为。</li><li>存储子部件。</li><li>在 Component 接口中实现与子部件有关的操作。</li></ul></li><li>Leaf：定义图元对象的行为</li><li>Client：通过 Component 接口操纵组合部件的对象</li></ul><p>用户使用 Component 类接口与组合结构中的对象进行交互。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.3-composite-%E7%BB%84%E5%90%88-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.4-decoratorwrapper-%E8%A3%85%E9%A5%B0%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="4.4-Decorator「wrapper」-装饰器-结构型模式"><meta itemprop=description content="目的

动态地向对象添加额外功能，比创建子类更加灵活
示例

GUI 工具箱允许你对任意一个用户界面组件添加一些特性（例如边框），或是一些行为（例如窗口滚动）。
一种较为灵活的方式是将组件嵌入另一个对象中，由这个对象添加边框。我们称这个嵌入的对象为装饰。

这个装饰与它所装饰的组件接口一致，因此它对使用该组件的客户透明（因此可以递归地嵌套）
它将客户请求转发给该组件，并且可能在转发前后执行一些额外的动作（例如画一个边框）。


适用性


在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
处理那些可以撤销的职责。
当不能采用生成子类的方法进行扩充时，例如：

可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长
类定义被隐藏或类是 final 的



结构



Component：对象接口
ConcreteComponent
Decorator：维护指向 Component 的指针，定义和 Component 一致的接口
ConcreteDecorator：向组件添加职责（将操作代理给所持有的对象，并附加自身的操作）


优缺点


比静态继承更灵活：

可以用添加和分离装饰器的方法，用装饰在运行时增加和删除职责。
可以很容易地重复添加一个特性


避免在层次结构高层的类有太多的特征
Decorator 相比 Component 模式而言，是完全透明的包装，使用装饰时不应当依赖对象标识

缺点：有许多小对象：采用 Decorator 模式进行系统设计往往会产生许多看上去类似的小对象，这些对象仅仅在它们相互连接的方式上有所不同，而不是它们的类或是它们的属性值有所不同。尽管对于那些了解这些系统的人来说，很容易对它们进行定制，但是很难学习这些系统，排错也很困难。
实现


接口一致性：装饰器必须和被装饰的对象接口一致
省略抽象的装饰器：仅需要添加一个职责时，没有必要定义抽象 Decorator 类
保持 Component 类的简单性：为保证一致性，组件和装饰器必须有共同的 Component 父类，因此需要避免这个类过大。这个父类应集中于定义接口而不是存储数据，对数据表示的定义应延迟到子类中

相关模式


Adapter（4.1）：Decorator 模式不同于 Adapter 模式，因为装饰仅改变对象的职责而不改变它的接口；而适配器将给对象一个全新的接口。
Composite（4.3）：可以将装饰视为一个退化的、仅有一个组件的组合。然而，装饰仅给对象添加一些额外的职责——它的目的不在于对象聚集。

装饰器 VS 策略模式

改变对象的行为主要有两种方式：

Decorator 模式改变外壳
Strategy 模式改变内核

当 Component 类原本就很庞大时，使用 Decorator 模式代价太高， Strategy 模式相对好一些"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.4-decoratorwrapper-%E8%A3%85%E9%A5%B0%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>4.4-Decorator「wrapper」-装饰器-结构型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:53:40 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:53:40 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h3 id=目的>目的
<a class=header-anchor href=#%e7%9b%ae%e7%9a%84></a></h3><p>动态地向对象添加额外功能，比创建子类更加灵活</p><h3 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h3><p>GUI 工具箱允许你对任意一个用户界面组件添加一些特性（例如边框），或是一些行为（例如窗口滚动）。</p><p>一种较为灵活的方式是将组件嵌入另一个对象中，由这个对象添加边框。我们称这个嵌入的对象为<strong>装饰</strong>。</p><ul><li>这个装饰与它所装饰的组件接口一致，因此它对使用该组件的客户透明（因此可以递归地嵌套）</li><li>它将客户请求转发给该组件，并且可能在转发前后执行一些额外的动作（例如画一个边框）。
<img src=/imgs/img-lazy-loading.gif data-src=./assets/4.4-Decorator%E3%80%8Cwrapper%E3%80%8D-%E8%A3%85%E9%A5%B0%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-30_14-10-58-351.png alt=600></li></ul><h3 id=适用性>适用性
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%80%a7></a></h3><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>处理那些可以撤销的职责。</li><li>当不能采用生成子类的方法进行扩充时，例如：<ul><li>可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长</li><li>类定义被隐藏或类是 final 的</li></ul></li></ul><h3 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h3><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/4.4-Decorator%E3%80%8Cwrapper%E3%80%8D-%E8%A3%85%E9%A5%B0%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-30_14-13-50-387.png alt></p><ul><li>Component：对象接口</li><li>ConcreteComponent</li><li>Decorator：维护指向 Component 的指针，定义和 Component 一致的接口</li><li>ConcreteDecorator：向组件添加职责（将操作代理给所持有的对象，并附加自身的操作）
<img src=/imgs/img-lazy-loading.gif data-src=./assets/4.4-Decorator%E3%80%8Cwrapper%E3%80%8D-%E8%A3%85%E9%A5%B0%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-30_14-32-31-015.png alt></li></ul><h3 id=优缺点>优缺点
<a class=header-anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9></a></h3><ul><li>比静态继承更灵活：<ul><li>可以用添加和分离装饰器的方法，用装饰在<strong>运行时增加和删除职责</strong>。</li><li>可以很容易地<strong>重复添加一个特性</strong></li></ul></li><li>避免在层次结构高层的类有太多的特征</li><li>Decorator 相比 Component 模式而言，是完全透明的包装，使用装饰时不应当依赖对象标识</li></ul><p>缺点：<strong>有许多小对象</strong>：采用 Decorator 模式进行系统设计往往会产生许多看上去类似的小对象，这些对象仅仅在它们相互连接的方式上有所不同，而不是它们的类或是它们的属性值有所不同。尽管对于那些了解这些系统的人来说，很容易对它们进行定制，但是<em>很难学习这些系统，排错也很困难</em>。</p><h3 id=实现>实现
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0></a></h3><ul><li>接口一致性：装饰器必须和被装饰的对象接口一致</li><li>省略抽象的装饰器：仅需要添加一个职责时，没有必要定义抽象 Decorator 类</li><li>保持 Component 类的简单性：为保证一致性，组件和装饰器必须有共同的 Component 父类，因此需要避免这个类过大。<em>这个父类应集中于定义接口而不是存储数据，对数据表示的定义应延迟到子类中</em></li></ul><h3 id=相关模式>相关模式
<a class=header-anchor href=#%e7%9b%b8%e5%85%b3%e6%a8%a1%e5%bc%8f></a></h3><ul><li>Adapter（4.1）：Decorator 模式不同于 Adapter 模式，因为装饰仅改变对象的职责而不改变它的接口；而适配器将给对象一个全新的接口。</li><li>Composite（4.3）：可以将装饰视为一个退化的、仅有一个组件的组合。然而，装饰仅给对象添加一些额外的职责——它的目的不在于对象聚集。</li></ul><h4 id=装饰器-vs-策略模式>装饰器 VS 策略模式
<a class=header-anchor href=#%e8%a3%85%e9%a5%b0%e5%99%a8-vs-%e7%ad%96%e7%95%a5%e6%a8%a1%e5%bc%8f></a></h4><p>改变对象的行为主要有两种方式：</p><ul><li>Decorator 模式改变外壳</li><li>Strategy 模式改变内核</li></ul><p>当 Component 类原本就很庞大时，使用 Decorator 模式代价太高， Strategy 模式相对好一些</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.4-decoratorwrapper-%E8%A3%85%E9%A5%B0%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.5-facade-%E5%A4%96%E8%A7%82-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="4.5-Facade-外观-结构型模式"><meta itemprop=description content="用途


定义一个高层接口，为子系统的一组接口提供一个一致的界面，使得子系统更加易用
Facade/fəˈsɑd/ 还可以降低子系统间的依赖关系


示例

有一个编译子系统，包含了若干个类来实现这一编译器，如 Scanner、Parse 等。

多数普通用户不关心语法分析等细节，只是希望实现一些代码。

因此子系统提供一个 Compiler 对象提供统一的高层接口，隐藏了内部实现


对于了解内部细节、有特殊需求的高级用户，可以绕过外观类 Complier 使用低层类实现功能

外观类不会隐藏内部实现




适用性


当你要为一个复杂子系统提供一个简单接口时。

Facade 可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够
而那些需要更多的可定制性的用户可以越过 Facade 层。


客户程序与抽象类的实现部分之间存在着很大的依赖性。引入 Facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。
当你需要构建一个层次结构的子系统时，使用 Facade 模式定义子系统中每层的入口点。
如果子系统之间是相互依赖的，可以让它们仅通过 Facade 进行通信，从而简化了它们之间的依赖关系。

结构



Facade：知道系统的内部结构，并将客户请求代理给适当的子系统对象
Subsystemclasses：

实现子系统的功能，处理 Facade 分派的任务
没有 Facade 的任何信息



使用 Facade 的客户程序不需要直接访问子系统对象，而通过发送请求给 Facade 的方式与子系统通信。Facade 将这些消息转发给适当的子系统对象。
优缺点

优点：

对客户屏蔽子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便。
它实现了子系统与客户之间的松耦合关系（子系统内部的功能组件往往是紧耦合的）

Facade 模式有助于建立层次结构系统
Facade 模式可以消除复杂的循环依赖关系
Facade 模式同样也有利于降低编译依赖性，使得编译一个子系统一般不需要编译所有其他的子系统。


如果应用需要，它并不限制它们使用子系统类。因此你可以在系统易用性和通用性之间加以选择。

实现


进一步降低客户-子系统耦合度的方法：

Facade 定义为抽象类而其具体子类对应不同的子系统实现可以进一步降低客户和子系统的耦合度
还可以用不同的子系统对象配置 Facade 对象


公共子系统类与私有子系统类：子系统和一个类都可用于功能的封装，相应地可以考虑提供公有和私有接口

子系统的公共接口包含所有的客户程序可以访问的类（包括 Facade），私有接口仅用于对子系统进行扩充



相关模式



Abstract Factory（3.1）模式可以与 Facade 模式一起使用以提供一个接口，这一接口可用来以一种子系统独立的方式创建子系统对象。 Abstract Factory 也可以代替 Facade 模式隐藏那些与平台相关的类。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.5-facade-%E5%A4%96%E8%A7%82-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>4.5-Facade-外观-结构型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:53:45 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:53:45 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h3 id=用途>用途
<a class=header-anchor href=#%e7%94%a8%e9%80%94></a></h3><ul><li>定义一个高层接口，为子系统的一组接口提供一个一致的界面，使得子系统更加易用</li><li>Facade/fəˈsɑd/ 还可以降低子系统间的依赖关系
<img src=/imgs/img-lazy-loading.gif data-src=./assets/4.5-Facade-%E5%A4%96%E8%A7%82-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-03_06-38-33-854.png alt></li></ul><h3 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h3><p>有一个编译子系统，包含了若干个类来实现这一编译器，如 Scanner、Parse 等。</p><ul><li>多数普通用户不关心语法分析等细节，只是希望实现一些代码。<ul><li>因此子系统提供一个 Compiler 对象提供统一的高层接口，隐藏了内部实现</li></ul></li><li>对于了解内部细节、有特殊需求的高级用户，可以绕过外观类 Complier 使用低层类实现功能<ul><li>外观类不会隐藏内部实现
<img src=/imgs/img-lazy-loading.gif data-src=./assets/4.5-Facade-%E5%A4%96%E8%A7%82-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-03_06-39-35-694.png alt></li></ul></li></ul><h3 id=适用性>适用性
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%80%a7></a></h3><ul><li>当你要为一个复杂子系统提供一个简单接口时。<ul><li>Facade 可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够</li><li>而那些需要更多的可定制性的用户可以越过 Facade 层。</li></ul></li><li>客户程序与抽象类的实现部分之间存在着很大的依赖性。引入 Facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。</li><li>当你需要构建一个层次结构的子系统时，使用 Facade 模式定义子系统中每层的入口点。</li><li>如果子系统之间是相互依赖的，可以让它们仅通过 Facade 进行通信，从而简化了它们之间的依赖关系。</li></ul><h3 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h3><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/4.5-Facade-%E5%A4%96%E8%A7%82-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-03_06-59-02-665.png alt></p><ul><li>Facade：知道系统的内部结构，并将客户请求代理给适当的子系统对象</li><li>Subsystemclasses：<ul><li>实现子系统的功能，处理 Facade 分派的任务</li><li><em>没有 Facade 的任何信息</em></li></ul></li></ul><p>使用 Facade 的客户程序不需要直接访问子系统对象，而通过发送请求给 Facade 的方式与子系统通信。Facade 将这些消息转发给适当的子系统对象。</p><h3 id=优缺点>优缺点
<a class=header-anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9></a></h3><p>优点：</p><ul><li>对客户屏蔽子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便。</li><li>它实现了子系统与客户之间的松耦合关系（子系统内部的功能组件往往是紧耦合的）<ul><li>Facade 模式有助于建立层次结构系统</li><li>Facade 模式可以消除复杂的循环依赖关系</li><li>Facade 模式同样也有利于降低编译依赖性，使得编译一个子系统一般不需要编译所有其他的子系统。</li></ul></li><li>如果应用需要，它并不限制它们使用子系统类。因此你可以在系统易用性和通用性之间加以选择。</li></ul><h3 id=实现>实现
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0></a></h3><ul><li>进一步降低客户-子系统耦合度的方法：<ul><li>Facade 定义为抽象类而其具体子类对应不同的子系统实现可以进一步降低客户和子系统的耦合度</li><li>还可以用不同的子系统对象配置 Facade 对象</li></ul></li><li>公共子系统类与私有子系统类：子系统和一个类都可用于功能的封装，相应地可以考虑提供公有和私有接口<ul><li>子系统的公共接口包含所有的客户程序可以访问的类（包括 Facade），私有接口仅用于对子系统进行扩充</li></ul></li></ul><h3 id=相关模式>相关模式
<a class=header-anchor href=#%e7%9b%b8%e5%85%b3%e6%a8%a1%e5%bc%8f></a></h3><ul><li><p>Abstract Factory（3.1）模式可以与 Facade 模式一起使用以提供一个接口，这一接口可用来以一种子系统独立的方式创建子系统对象。 Abstract Factory 也可以代替 Facade 模式隐藏那些与平台相关的类。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.5-facade-%E5%A4%96%E8%A7%82-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.7-proxy-%E4%BB%A3%E7%90%86-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="4.7-Proxy-代理-结构型模式"><meta itemprop=description content="目的

为其他对象提供一种代理以控制该对象的访问。
类似网络中的反向代理
示例

需求：

为了改善打开执行速度，文档编辑器应当按需创建开销很大的对象（例如大型图像）
需要隐藏根据需要创建图像这一事实，从而不会使得编辑器的实现复杂化

方法：

使用图像 Proxy 替代真正的图像，Proxy 可以代替一个图像对象，并且在需要（文档编辑器调用图像代理的 Draw 操作）时负责实例化这个图像对象



图像 Proxy 存储图像路径和分辨率，以及对真正的 Image 实例的指引。因此不需要真正实例化这个图像就可以响应格式化程序对图像尺寸的请求

适用性

在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用 Proxy 模式。例如：

远程代理（Remote Proxy）为一个对象在不同的地址空间提供局部代表
虚代理（Virtual Proxy）根据需要创建开销很大的对象。
保护代理 （Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。
智能指针（Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。它的典型用途包括：

对指向实际对象的引用计数，可用于内存自动回收
当第一次引用一个持久对象时，将它装入内存
读写锁：在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它


copy-on-write：用代理延迟复杂大对象的拷贝过程，保证只有当这个对象被修改的时候才对它进行拷贝

在实现 Copy-on-write 时必须对实体进行引用计数。

拷贝代理仅会增加引用计数。只有当用户请求一个修改该实体的操作时，代理才会真正地拷贝它。
当引用的数目为零时，这个实体将被删除。





结构



Proxy：

基本功能

保存一个引用使得代理可以访问实体。若 RealSubject 和 Subject 的接口相同，Proxy 会引用 Subject。
提供一个与 Subject 的接口相同的接口，这样代理就可以用来替代实体。
控制对实体的存取，并可能负责创建和删除它。


其他功能：

Remote Proxy 负责对请求及其参数进行编码，并向不同地址空间中的实体发送已编码的请求。
Virtual Proxy 可以缓存实体的附加信息，以便延迟对它的访问。例如，动机一节中提到的 ImageProxy 缓存了图像实体的尺寸。
Protection Proxy 检查调用者是否具有实现一个请求所必需的访问权限。




Subject（Graphic）：定义 RealSubject 和 Proxy 的共用接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy。
RealSubject（Image）：定义 Proxy 所代表的实体。

代理根据其种类，在适当的时候向 RealSubject 转发请求"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.7-proxy-%E4%BB%A3%E7%90%86-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>4.7-Proxy-代理-结构型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:53:49 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:53:49 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h3 id=目的>目的
<a class=header-anchor href=#%e7%9b%ae%e7%9a%84></a></h3><p>为其他对象提供一种代理以控制该对象的访问。
类似网络中的反向代理</p><h3 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h3><p>需求：</p><ul><li>为了改善打开执行速度，文档编辑器应当按需创建开销很大的对象（例如大型图像）</li><li>需要隐藏根据需要创建图像这一事实，从而不会使得编辑器的实现复杂化</li></ul><p>方法：</p><ul><li>使用图像 Proxy 替代真正的图像，Proxy 可以代替一个图像对象，并且在需要（文档编辑器调用图像代理的 Draw 操作）时负责实例化这个图像对象</li></ul><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/4.7-Proxy-%E4%BB%A3%E7%90%86-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-03_13-19-51-038.png alt></p><ul><li>图像 Proxy 存储图像路径和分辨率，以及对真正的 Image 实例的指引。因此不需要真正实例化这个图像就可以响应格式化程序对图像尺寸的请求</li></ul><h3 id=适用性>适用性
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%80%a7></a></h3><p>在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用 Proxy 模式。例如：</p><ul><li><strong>远程代理</strong>（Remote Proxy）为一个对象在不同的地址空间提供局部代表</li><li><strong>虚代理</strong>（Virtual Proxy）根据需要创建开销很大的对象。</li><li><strong>保护代理</strong> （Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。</li><li><strong>智能指针</strong>（Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。它的典型用途包括：<ul><li>对指向实际对象的<strong>引用计数</strong>，可用于内存自动回收</li><li>当第一次引用一个持久对象时，将它装入内存</li><li><strong>读写锁</strong>：在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它</li></ul></li><li><strong>copy-on-write</strong>：用代理延迟复杂大对象的拷贝过程，保证只有当这个对象被修改的时候才对它进行拷贝<ul><li>在实现 Copy-on-write 时必须对实体进行引用计数。<ul><li>拷贝代理仅会增加引用计数。只有当用户请求一个修改该实体的操作时，代理才会真正地拷贝它。</li><li>当引用的数目为零时，这个实体将被删除。</li></ul></li></ul></li></ul><h3 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h3><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/4.7-Proxy-%E4%BB%A3%E7%90%86-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-03_13-25-32-488.png alt></p><ul><li>Proxy：<ul><li>基本功能<ul><li>保存一个引用使得代理可以访问实体。若 RealSubject 和 Subject 的接口相同，Proxy 会引用 Subject。</li><li>提供一个与 Subject 的接口相同的接口，这样代理就可以用来替代实体。</li><li>控制对实体的存取，并可能负责创建和删除它。</li></ul></li><li>其他功能：<ul><li>Remote Proxy 负责对请求及其参数进行编码，并向不同地址空间中的实体发送已编码的请求。</li><li>Virtual Proxy 可以缓存实体的附加信息，以便延迟对它的访问。例如，动机一节中提到的 ImageProxy 缓存了图像实体的尺寸。</li><li>Protection Proxy 检查调用者是否具有实现一个请求所必需的访问权限。</li></ul></li></ul></li><li>Subject（Graphic）：定义 RealSubject 和 Proxy 的共用接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy。</li><li>RealSubject（Image）：定义 Proxy 所代表的实体。</li></ul><p>代理根据其种类，在适当的时候向 RealSubject 转发请求</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.7-proxy-%E4%BB%A3%E7%90%86-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="5-行为型模式"><meta itemprop=description content="行为型模式涉及算法和对象间职责的分配。行为型模式不仅描述对象或类的模式，还描述它们之间的通信模式。

类行为型模式使用继承机制在类间分派行为
对象行为型模式描述了一组对等的对象怎样相互协作

大多数模式有两种对象：封装该方面特征的新对象，使用这些新对象的已有对象。

不使用这些模式的话，通常这些新对象的功能就会变成已有对象的难以分割的一部分。

通信的封装/协作


Observer 通过引入 Observer 和 Subject 对象来分布通信
Mediator 对象则封装了其他对象间的通信

解耦合

当合作的对象直接互相引用时，它们变得互相依赖。命令、观察者、中介者和职责链等模式都涉及如何对发送者和接收者解耦，但它们又各有不同的权衡考虑。
命令模式使用一个 Command 对象来定义发送者和接收者之间的绑定关系

Command 对象提供了一个提交请求的简单接口（即 Execute 操作）。
将发送者和接收者之间的连接定义在一个单独的对象中使得该发送者可以与不同的接收者一起工作。


观察者模式通过定义一个接口来通知目标中发生的改变，从而将发送者（目标）与接收者（观察者）解耦

当对象间有数据依赖时，最好用观察者模式来对它们进行解耦。


中介者模式让对象通过一个 Mediator 对象间接地互相引用，从而对它们解耦

它将通信行为集中到一个类中而不是将其分布在各个子类中
为增加灵活性 Mediator 可能不得不实现它自己的分发策略（例如用一定方式对请求编码并打包参数），但这通常会导致类型安全问题


职责链模式通过沿一个潜在接收者链传递请求而将发送者与接收者解耦
"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>5-行为型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:53:53 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:53:53 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><p>行为型模式涉及<strong>算法和对象间职责的分配</strong>。行为型模式不仅描述对象或类的模式，还描述它们之间的<strong>通信模式</strong>。</p><ul><li>类行为型模式使用继承机制在类间分派行为</li><li>对象行为型模式描述了一组对等的对象怎样相互协作</li></ul><p>大多数模式有两种对象：封装该方面特征的新对象，使用这些新对象的已有对象。</p><ul><li>不使用这些模式的话，通常这些新对象的功能就会变成已有对象的难以分割的一部分。</li></ul><h3 id=通信的封装协作>通信的封装/协作
<a class=header-anchor href=#%e9%80%9a%e4%bf%a1%e7%9a%84%e5%b0%81%e8%a3%85%e5%8d%8f%e4%bd%9c></a></h3><ul><li>Observer 通过引入 Observer 和 Subject 对象来分布通信</li><li>Mediator 对象则封装了其他对象间的通信</li></ul><h3 id=解耦合>解耦合
<a class=header-anchor href=#%e8%a7%a3%e8%80%a6%e5%90%88></a></h3><p>当合作的对象直接互相引用时，它们变得互相依赖。命令、观察者、中介者和职责链等模式都涉及如何对发送者和接收者解耦，但它们又各有不同的权衡考虑。</p><p>命令模式使用一个 Command 对象来定义发送者和接收者之间的绑定关系</p><ul><li>Command 对象提供了一个提交请求的简单接口（即 Execute 操作）。</li><li>将发送者和接收者之间的连接定义在一个单独的对象中使得该发送者可以与不同的接收者一起工作。
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-20_12-17-25-128.png alt></li></ul><p>观察者模式通过定义一个接口来通知目标中发生的改变，从而将发送者（目标）与接收者（观察者）解耦</p><ul><li>当对象间有数据依赖时，最好用观察者模式来对它们进行解耦。
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-20_12-53-44-164.png alt></li></ul><p>中介者模式让对象通过一个 Mediator 对象间接地互相引用，从而对它们解耦</p><ul><li>它将通信行为集中到一个类中而不是将其分布在各个子类中</li><li>为增加灵活性 Mediator 可能不得不实现它自己的分发策略（例如用一定方式对请求编码并打包参数），但这通常会导致类型安全问题
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-20_12-54-29-879.png alt></li></ul><p>职责链模式通过沿一个潜在接收者链传递请求而将发送者与接收者解耦
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-20_12-56-10-591.png alt></p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.10-templatemethod-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.png"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="5.10-TemplateMethod-模板方法"><meta itemprop=description content="目的

定义一个操作的算法骨架，而将一些步骤延迟到子类中。通过子类来实现这些步骤，使得不改变算法结构的情况下，可重新定义算法中的某些特定步骤
适用性


一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。
各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。

首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。
然后，用一个调用新的操作的模板方法来替换不同的代码。


控制子类扩展。模板方法只在特定点调用 hook 操作，这样就只允许在这些点进行扩展。

结构



AbstractClass：

定义抽象的原语操作（primitive operation），具体的子类将重定义它们以实现一个算法的各步骤
实现一个模板方法，定义一个算法的骨架。该模板方法不仅调用原语操作，也调用定义在 AbstractClass 或其他对象中的操作。


ConcreteClass：实现原语操作以完成算法中与特定子类相关的步骤。

效果

模板方法是一种代码复用的基本技术。它们在类库中尤为重要，提取了类库中的公共行为。
模板方法导致一种反向的控制结构，父类调用一个子类的操作。
模板方法调用下列类型的操作：

原语操作（即抽象操作）：子类必须重载以提供具体实现。
钩子操作（hook operation），它提供了缺省的行为，子类可以在必要时通过重载进行扩展。钩子操作在缺省情况下通常是空操作。
其他操作：不应重定义这些操作

很重要的一点是模板方法应该区分哪些操作是原语操作（必须重载），哪些是钩子操作（可以重载）
实现


访问控制：

在 C++中，一个模板方法调用的原语操作可以被定义为 protected 的纯虚函数，保证它们只被模板方法调用，同时必须重载。
模板方法自身不需要被重定义，因此可以将模板方法定义为一个非虚成员函数。


尽量减少原语操作
命名约定：可以给应被重定义的操作的名字加上一个前缀以识别它们

相关模式

Strategy（5.9）：模板方法使用继承来改变算法的一部分， Strategy 使用委托来改变整个算法。
Factory Method（3.3）常被模板方法调用。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.10-templatemethod-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/ itemprop=url class=post-title-link>5.10-TemplateMethod-模板方法</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:54:31 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:54:31 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class=post-body itemprop=articleBody><h3 id=目的>目的
<a class=header-anchor href=#%e7%9b%ae%e7%9a%84></a></h3><p>定义一个操作的算法骨架，而将一些步骤延迟到子类中。通过子类来实现这些步骤，使得不改变算法结构的情况下，可重新定义算法中的某些特定步骤</p><h3 id=适用性>适用性
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%80%a7></a></h3><ul><li>一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。<ul><li>首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。</li><li>然后，用一个调用新的操作的模板方法来替换不同的代码。</li></ul></li><li>控制子类扩展。模板方法只在特定点调用 hook 操作，这样就只允许在这些点进行扩展。</li></ul><h3 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h3><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/5.10-TemplateMethod-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/image-2023-10-19_17-05-39-615.png alt></p><ul><li>AbstractClass：<ul><li>定义抽象的原语操作（primitive operation），具体的子类将重定义它们以实现一个算法的各步骤</li><li>实现一个模板方法，定义一个算法的骨架。该模板方法不仅调用原语操作，也调用定义在 AbstractClass 或其他对象中的操作。</li></ul></li><li>ConcreteClass：实现原语操作以完成算法中与特定子类相关的步骤。</li></ul><h3 id=效果>效果
<a class=header-anchor href=#%e6%95%88%e6%9e%9c></a></h3><p>模板方法是一种代码复用的基本技术。它们在类库中尤为重要，提取了类库中的公共行为。
模板方法导致一种反向的控制结构，父类调用一个子类的操作。</p><p>模板方法调用下列类型的操作：</p><ul><li>原语操作（即抽象操作）：子类必须重载以提供具体实现。</li><li>钩子操作（hook operation），它提供了缺省的行为，子类可以在必要时通过重载进行扩展。钩子操作在缺省情况下通常是空操作。</li><li>其他操作：不应重定义这些操作</li></ul><p>很重要的一点是模板方法应该区分哪些操作是原语操作（必须重载），哪些是钩子操作（可以重载）</p><h3 id=实现>实现
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0></a></h3><ul><li>访问控制：<ul><li>在 C++中，一个模板方法调用的原语操作可以被定义为 protected 的纯虚函数，保证它们只被模板方法调用，同时必须重载。</li><li>模板方法自身不需要被重定义，因此可以将模板方法定义为一个非虚成员函数。</li></ul></li><li>尽量减少原语操作</li><li>命名约定：可以给应被重定义的操作的名字加上一个前缀以识别它们</li></ul><h3 id=相关模式>相关模式
<a class=header-anchor href=#%e7%9b%b8%e5%85%b3%e6%a8%a1%e5%bc%8f></a></h3><p>Strategy（5.9）：模板方法使用继承来改变算法的一部分， Strategy 使用委托来改变整个算法。
Factory Method（3.3）常被模板方法调用。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.10-templatemethod-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" rel=prev href=/post/><i class="fa fa-angle-left"></i>
</a><a class=page-number href=/post/>1</a>
<span class="page-number current">2</span>
<a class=page-number href=/post/page/3/>3</a>
<a class="extend next" rel=next href=/post/page/3/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2024 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>CSMTC</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.145.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.7.2 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script class=next-config data-name=page type=application/json>{"comments":false,"expired":false,"isHome":false,"isPage":false,"math":{"js":{"file":"es5/tex-mml-svg.js","name":"mathjax","version":"3.2.2"},"render":"mathjax"},"path":"post","permalink":"//localhost:1313/post/","title":"Posts","toc":true,"waline":{"commentcnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/comment.js","name":"comment","version":"2.15.8"}}}</script><script type=text/javascript src=//localhost:1313/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=//localhost:1313/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"//localhost:1313/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"slideInRight","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":true,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"//localhost:1313/js/3rd"}},"version":"4.7.2","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"2.15.8"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"2.15.8"}}}</script><script type=text/javascript src="/js/main.js?=1741730422" defer></script><script>MathJax={tex:{inlineMath:[["$","$"]],macros:{"\\":"\\\\"}},displayMath:[["$$","$$"],["[[","]]"]],svg:{fontCache:"global"}}</script></body></html>