<!doctype html><html lang=zh-CN data-theme=light><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.145.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Posts"><meta itemprop=description content="分享让自我更强大"><meta name=description content="分享让自我更强大"><meta itemprop=image content="//localhost:1313/imgs/csmtc.jpg"><meta itemprop=keywords content="blog"><meta property="og:type" content="website"><meta property="og:title" content="Posts"><meta property="og:description" content="分享让自我更强大"><meta property="og:image" content="/imgs/csmtc.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="//localhost:1313/post/"><meta property="og:site_name" content="CSMTC Blog"><meta property="og:locale" content="zh-CN"><link type=text/css rel=stylesheet href=//localhost:1313/js/3rd/font-awesome/6.7.2/css/all.min.css><link type=text/css rel=stylesheet href=//localhost:1313/js/3rd/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=//localhost:1313/js/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href="/css/main.css?=1741723521"><style type=text/css>.post-footer hr:after{content:"~ 我可是有底线的哟 ~"}.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>post - CSMTC Blog</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>CSMTC Blog</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>share make powerful</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>Home</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-tag hvr-icon"></i>Categories</a></li><li class="menu-item menu-item-tag"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tag hvr-icon"></i>Tags</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=CSMTC src=/imgs/img-lazy-loading.gif data-src=/imgs/csmtc.jpg><p class=site-author-name itemprop=name>CSMTC</p><div class=site-description itemprop=description>分享让自我更强大</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>29</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>2</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>0</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/csmtc title="Github → https://github.com/csmtc" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=https://gitee.com/csmtce title="Gitee → https://gitee.com/csmtce" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Gitee</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/small/by_nc_sa.svg alt=共享知识></a></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg>
</a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.1-chainofresponsibility-%E8%81%8C%E8%B4%A3%E9%93%BE-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.jpg"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="5.1-ChainOfResponsibility-职责链-行为型模式"><meta itemprop=description content="目的

使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。
对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
示例

GUI 中的组件 Tips：用户界面对象中会有一个对象来处理帮助请求，至于是哪一个对象则取决于上下文以及可用的帮助具体到何种程度。

问题：提交帮助请求的对象（如按钮）并不明确知道谁是最终提供帮助的对象，需要有一种办法将提交帮助请求的对象与可能提供帮助信息的对象解耦（decouple）
职责链：将可选的处理对象排成一条链，链中对象收到请求的对象要么亲自处理它，要么转发给链中的下一个候选者。

要求：每个在链上的对象都有一致的处理请求和访问链上后继者的接口

按钮、对话框和应用类都使用 HelpHandler 操作来处理帮助请求。 HelpHandler 的 HandleHelp 操作默认是将请求转发给后继。



适用性


有多个对象可以处理一个请求，哪个对象处理该请求运行时自动确定。
你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
可处理一个请求的对象集合应被动态指定。

结构



Handler：定义处理请求的接口

可选：实现后继链（successor）


ConcreteHandler：处理请求，访问后继对象

若能处理就处理，否则就将请求转发给后继


Client：向职责链上的 ConcreteHandler 提交请求
当客户提交一个请求时，请求沿链传递直至有一个 ConcreteHandler 对象负责处理它。

请求传递过程可能如下

优缺点


降低耦合度：该模式使得一个对象无须知道是其他哪一个对象处理其请求。

接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构。


增强了给对象指派职责的灵活性：可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的那些职责。
不保证处理：既然一个请求没有明确的接收者，那么就不能保证它一定会被处理（可能一直到链尾都没有对象处理请求）

实现

实现后继者链的方法


使用已有的链接：例如，在一个部分–整体层次结构中，父构件引用可定义一个部件的后继者。窗口组件（widget）结构可能早已有这样的链接。
由 Handler 实现：如果没有已有的引用可定义一个链，则必须构建新的链。这种情况下 Handler 不仅定义该请求的接口，通常也维护后继者


表示请求


请求是一个硬编码的（hard-coded）操作调用（如上述 HelpHandler）
使用一个处理函数，这个函数以一个请求码（如一个整型常数或一个字符串）为参数

无法用类型安全的方法来传递请求参数，因此它们必须被手工打包和解包。显然，相对于直接调用一个操作来说它不太安全。



解决上述参数传递问题：

使用独立的请求对象来封装请求参数
Request 可定义一个访问器（accessor）函数以返回该类的标识符（对于支持的语言，可使用运行时的类型信息）
子类可通过重定义 HandleRequest 扩展该分派函数。子类只处理它感兴趣的请求，其他的请求被转发给父类。


相关模式

职责链常与 Composite（4.3）一起使用。这种情况下，一个构件的父构件可作为它的后继。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.1-chainofresponsibility-%E8%81%8C%E8%B4%A3%E9%93%BE-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>5.1-ChainOfResponsibility-职责链-行为型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-09-09 20:03:09 +00:00" itemprop="dateCreated datePublished" datetime="2024-09-09 20:03:09 +0000 UTC">2024-09-09
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:53:58 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:53:58 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h3 id=目的>目的
<a class=header-anchor href=#%e7%9b%ae%e7%9a%84></a></h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。
对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><h3 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h3><p>GUI 中的组件 Tips：用户界面对象中会有一个对象来处理帮助请求，至于是哪一个对象则取决于上下文以及可用的帮助具体到何种程度。</p><ul><li>问题：提交帮助请求的对象（如按钮）并不明确知道谁是最终提供帮助的对象，需要有一种办法将提交帮助请求的对象与可能提供帮助信息的对象解耦（decouple）</li><li><strong>职责链</strong>：将可选的处理对象排成一条链，链中对象收到请求的对象要么亲自处理它，要么转发给链中的下一个候选者。<ul><li>要求：每个在链上的对象都有一致的<em>处理请求</em>和<em>访问链上后继者</em>的接口
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5.1-ChainOfResponsibility-%E8%81%8C%E8%B4%A3%E9%93%BE-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-04-55-745.png alt>
按钮、对话框和应用类都使用 HelpHandler 操作来处理帮助请求。 HelpHandler 的 HandleHelp 操作默认是将请求转发给后继。</li></ul></li></ul><h3 id=适用性>适用性
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%80%a7></a></h3><ul><li>有多个对象可以处理一个请求，哪个对象处理该请求运行时自动确定。</li><li>你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</li><li>可处理一个请求的对象集合应被动态指定。</li></ul><h3 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h3><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/5.1-ChainOfResponsibility-%E8%81%8C%E8%B4%A3%E9%93%BE-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-05-58-915.png alt></p><ul><li>Handler：定义处理请求的接口<ul><li>可选：实现后继链（successor）</li></ul></li><li>ConcreteHandler：处理请求，访问后继对象<ul><li>若能处理就处理，否则就将请求转发给后继</li></ul></li><li>Client：向职责链上的 ConcreteHandler 提交请求
当客户提交一个请求时，请求沿链传递直至有一个 ConcreteHandler 对象负责处理它。</li></ul><p>请求传递过程可能如下
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5.1-ChainOfResponsibility-%E8%81%8C%E8%B4%A3%E9%93%BE-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-06-26-399.png alt></p><h3 id=优缺点>优缺点
<a class=header-anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9></a></h3><ul><li>降低耦合度：该模式使得一个对象无须知道是其他哪一个对象处理其请求。<ul><li>接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构。</li></ul></li><li>增强了给对象指派职责的灵活性：可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的那些职责。</li><li>不保证处理：既然一个请求没有明确的接收者，那么就不能保证它一定会被处理（可能一直到链尾都没有对象处理请求）</li></ul><h3 id=实现>实现
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0></a></h3><h4 id=实现后继者链的方法>实现后继者链的方法
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0%e5%90%8e%e7%bb%a7%e8%80%85%e9%93%be%e7%9a%84%e6%96%b9%e6%b3%95></a></h4><ul><li><strong>使用已有的链接</strong>：例如，在一个部分–整体层次结构中，父构件引用可定义一个部件的后继者。窗口组件（widget）结构可能早已有这样的链接。</li><li><strong>由 Handler 实现</strong>：如果没有已有的引用可定义一个链，则必须构建新的链。这种情况下 Handler 不仅定义该请求的接口，通常也维护后继者
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5.1-ChainOfResponsibility-%E8%81%8C%E8%B4%A3%E9%93%BE-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-22-13-233.png alt></li></ul><h4 id=表示请求>表示请求
<a class=header-anchor href=#%e8%a1%a8%e7%a4%ba%e8%af%b7%e6%b1%82></a></h4><ol><li>请求是一个硬编码的（hard-coded）操作调用（如上述 HelpHandler）</li><li>使用一个处理函数，这个函数以一个请求码（如一个整型常数或一个字符串）为参数<ol><li>无法用类型安全的方法来传递请求参数，因此它们必须被手工打包和解包。显然，相对于直接调用一个操作来说它不太安全。</li></ol></li></ol><p><strong>解决上述参数传递问题</strong>：</p><ul><li>使用独立的请求对象来封装请求参数</li><li>Request 可定义一个访问器（accessor）函数以返回该类的标识符（对于支持的语言，可使用运行时的类型信息）</li><li>子类可通过重定义 HandleRequest 扩展该分派函数。子类只处理它感兴趣的请求，其他的请求被转发给父类。
<img src=/imgs/img-lazy-loading.gif data-src=./assets/5.1-ChainOfResponsibility-%E8%81%8C%E8%B4%A3%E9%93%BE-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-26-57-404.png alt></li></ul><h3 id=相关模式>相关模式
<a class=header-anchor href=#%e7%9b%b8%e5%85%b3%e6%a8%a1%e5%bc%8f></a></h3><p>职责链常与 Composite（4.3）一起使用。这种情况下，一个构件的父构件可作为它的后继。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.1-chainofresponsibility-%E8%81%8C%E8%B4%A3%E9%93%BE-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E9%A2%98%E7%9B%AE/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E8%B4%AA%E5%BF%83/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.jpg"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="LeetCode刷题记录-贪心"><meta itemprop=description content="

    55. 跳跃游戏
    
    
    


给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。
核心策略：看覆盖范围，覆盖范围内⼀定是可以跳过来的，不⽤管是怎么跳的。问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点。


    45. 跳跃游戏 II
    
    
    


给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。
每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:

0 <= j <= nums[i] 
i + j < n

返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例保证可以到达 nums[n - 1] 。
核心策略：同样看覆盖范围，当前下标达到了上次跳跃的最大位置，且未达到终点，则需要跳跃一次。



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


if (nums.size() == 1)
  return 0;
int max_pos = 0, last_max_pos = 0, cnt = 0, target = nums.size() - 1;

for (int i = 0; i <= target; ++i) {
  // 跳跃的情况：当前下标达到了上次跳跃的最大位置，且未达到终点，则需要跳跃一次
  max_pos = max(max_pos, i + nums[i]);
  if (i == last_max_pos) {
    ++cnt;
    last_max_pos = max_pos;
    if (last_max_pos >= target)
      break;
  }
}





    134. 加油站
    
    
    





1
2
3


情况⼀：如果 gas 的总和⼩于 cost 总和，那么⽆论从哪⾥出发，⼀定是跑不了⼀圈的
情况⼆：rest[i] = gas[i]-cost[i]为⼀天剩下的油，i 从 0 开始计算累加到最后⼀站，如果累加没有出现负数，说明从 0 出发，油就没有断过，那么 0 就是起点。
情况三：如果累加的最⼩值是负数，汽⻋就要从⾮0 节点出发，从后向前，看哪个节点能把这个负数填平，能把这个负数填平的节点就是出发节点。





    376. 摆动序列
    
    
    


如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E9%A2%98%E7%9B%AE/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E8%B4%AA%E5%BF%83/ itemprop=url class=post-title-link>LeetCode刷题记录-贪心</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-07-25 17:13:03 +00:00" itemprop="dateCreated datePublished" datetime="2024-07-25 17:13:03 +0000 UTC">2024-07-25
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ itemprop=url rel=index><span itemprop=name>算法与数据结构</span></a></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h3 id=55-跳跃游戏><a href=https://leetcode.cn/problems/jump-game/description/ title="55. 跳跃游戏" rel="noopener external nofollow noreferrer" target=_blank class=exturl>55. 跳跃游戏
<i class="fa fa-external-link-alt"></i>
</a><a class=header-anchor href=#55-%e8%b7%b3%e8%b7%83%e6%b8%b8%e6%88%8f></a></h3><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>核心策略：看覆盖范围，覆盖范围内⼀定是可以跳过来的，不⽤管是怎么跳的。问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点。</p><h3 id=45-跳跃游戏-ii><a href=https://leetcode.cn/problems/jump-game-ii/description title="45. 跳跃游戏 II" rel="noopener external nofollow noreferrer" target=_blank class=exturl>45. 跳跃游戏 II
<i class="fa fa-external-link-alt"></i>
</a><a class=header-anchor href=#45-%e8%b7%b3%e8%b7%83%e6%b8%b8%e6%88%8f-ii></a></h3><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p><p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code> </li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例保证可以到达 <code>nums[n - 1]</code> 。</p><p>核心策略：同样看覆盖范围，当前下标达到了上次跳跃的最大位置，且未达到终点，则需要跳跃一次。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>max_pos</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>last_max_pos</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>target</span> <span class=o>=</span> <span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>target</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 跳跃的情况：当前下标达到了上次跳跃的最大位置，且未达到终点，则需要跳跃一次
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>max_pos</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>max_pos</span><span class=p>,</span> <span class=n>i</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=n>last_max_pos</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>++</span><span class=n>cnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>last_max_pos</span> <span class=o>=</span> <span class=n>max_pos</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>last_max_pos</span> <span class=o>&gt;=</span> <span class=n>target</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=134-加油站><a href=https://leetcode.cn/problems/gas-station/ title="134. 加油站" rel="noopener external nofollow noreferrer" target=_blank class=exturl>134. 加油站
<i class="fa fa-external-link-alt"></i>
</a><a class=header-anchor href=#134-%e5%8a%a0%e6%b2%b9%e7%ab%99></a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>情况⼀：如果 gas 的总和⼩于 cost 总和，那么⽆论从哪⾥出发，⼀定是跑不了⼀圈的
</span></span><span class=line><span class=cl>情况⼆：rest[i] = gas[i]-cost[i]为⼀天剩下的油，i 从 0 开始计算累加到最后⼀站，如果累加没有出现负数，说明从 0 出发，油就没有断过，那么 0 就是起点。
</span></span><span class=line><span class=cl>情况三：如果累加的最⼩值是负数，汽⻋就要从⾮0 节点出发，从后向前，看哪个节点能把这个负数填平，能把这个负数填平的节点就是出发节点。</span></span></code></pre></td></tr></table></div></div><h3 id=376-摆动序列><a href=https://leetcode.cn/problems/wiggle-subsequence/ title="376. 摆动序列" rel="noopener external nofollow noreferrer" target=_blank class=exturl>376. 摆动序列
<i class="fa fa-external-link-alt"></i>
</a><a class=header-anchor href=#376-%e6%91%86%e5%8a%a8%e5%ba%8f%e5%88%97></a></h3><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E9%A2%98%E7%9B%AE/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E8%B4%AA%E5%BF%83/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/hard4.6-flyweight-%E4%BA%AB%E5%85%83-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.jpg"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="「HARD」4.6-Flyweight-享元-结构型模式"><meta itemprop=description content="用途

运用共享技术支持大量细粒度的对象节约空间
示例

面向对象中创建一个对象的开销是相对较大的，有时这是难以承受的。例如文本编辑器若将每个字符均采用一个相应的对象描述将产生巨大的内存负担

Flyweight 模式描述了如何共享对象，使得可以细粒度地使用它们而不需要高昂的代价

说明：flyweight 是一个共享对象，它可以同时在多个场景/上下文（context）中使用，并且在每个场景中 flyweight 都可以作为一个独立的对象

关于内部与外部状态：

flyweight 存储独立于上下文的信息，在每个场景中使用
有关上下文的外部状态由用户在合适的时候提供




Flyweight 模式对那些通常由于数量太大而难以用对象来表示的概念或实体进行建模

例如文本编辑器中：

逻辑上每个字符对应一个对象
物理上每种字符共享同一个 Flyweight 对象（存储在 Flyweight 对象池），只存储字符编码，不存储相应的图元位置和字体等信息
行对象绘制字符对象时传递位置、字体等信息






适用性

条件全部成立时使用：

一个应用程序使用了大量的对象，完全由于使用大量的对象造成很大的存储开销。
对象的大多数状态都可变为外部状态。
如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。
应用程序不依赖于对象标识（共享对象 a equal b 会返回真值）。

结构



FlyweightFactory：创建、管理、共享 Flyweight 对象。（采用懒加载创建）
Flyweight（示例中的 Glyph）：描述接口，通过这个接口 flyweight 可以接受并作用于外部状态。
ConcreteFlyweight（示例中的 Character）：（该对象必须是可共享的）实现 Flyweight 接口，并为内部状态（如果有的话）分配存储空间。
UnsharedConcreteFlyweight（示例中的 Row、Column）：并非所有的 Flyweight 子类都需要被共享
Client

引用 Flyweight
计算/存储 Flyweight 的外部状态
用户不应直接对 ConcreteFlyweight 类进行实例化，而只能从 FlyweightFactory 对象得到 ConcreteFlyweight 对象，这可以保证对它们适当地进行共享。



优缺点


增大时间开销：传输、查找和/或计算外部状态都会产生运行时开销
减少空间开销：

共享的 flyweight 越多，存储节约也就越多。
节约量随着共享状态的增多而增大。
当对象使用大量的内部及外部状态，并且外部状态是计算出来的而非存储的时候，节约量将达到最大。



Flyweight 模式经常和 Composite（4.3）模式结合起来表示一个层次式结构，这一层次式结构是一个共享叶结点的图。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/hard4.6-flyweight-%E4%BA%AB%E5%85%83-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>「HARD」4.6-Flyweight-享元-结构型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:50:58 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:50:58 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h3 id=用途>用途
<a class=header-anchor href=#%e7%94%a8%e9%80%94></a></h3><p>运用共享技术支持大量细粒度的对象<strong>节约空间</strong></p><h3 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h3><p>面向对象中创建一个对象的开销是相对较大的，有时这是难以承受的。例如文本编辑器若将每个字符均采用一个相应的对象描述将产生巨大的内存负担</p><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/%E3%80%8CHARD%E3%80%8D4.6-Flyweight-%E4%BA%AB%E5%85%83-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-03_12-30-49-151.png alt>
Flyweight 模式描述了如何共享对象，使得可以细粒度地使用它们而不需要高昂的代价</p><ul><li>说明：flyweight 是一个共享对象，它可以同时在多个<strong>场景/上下文</strong>（context）中使用，并且在每个场景中 flyweight 都可以作为一个独立的对象<ul><li>关于内部与外部状态：<ul><li>flyweight 存储独立于上下文的信息，在每个场景中使用</li><li>有关上下文的外部状态由用户在合适的时候提供</li></ul></li></ul></li><li>Flyweight 模式对那些通常由于数量太大而难以用对象来表示的概念或实体进行建模<ul><li>例如文本编辑器中：<ul><li>逻辑上<em>每个</em>字符对应一个对象</li><li>物理上<em>每种</em>字符共享同一个 Flyweight 对象（存储在 Flyweight 对象池），只存储字符编码，不存储相应的图元位置和字体等信息</li><li>行对象绘制字符对象时传递位置、字体等信息
<img src=/imgs/img-lazy-loading.gif data-src=./assets/%E3%80%8CHARD%E3%80%8D4.6-Flyweight-%E4%BA%AB%E5%85%83-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-03_12-42-29-654.png alt></li></ul></li></ul></li></ul><h3 id=适用性>适用性
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%80%a7></a></h3><p>条件全部成立时使用：</p><ul><li>一个应用程序使用了大量的对象，完全由于使用大量的对象造成很大的存储开销。</li><li>对象的大多数状态都可变为外部状态。</li><li>如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。</li><li>应用程序不依赖于对象标识（共享对象 a equal b 会返回真值）。</li></ul><h3 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h3><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/%E3%80%8CHARD%E3%80%8D4.6-Flyweight-%E4%BA%AB%E5%85%83-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-03_12-45-43-193.png alt></p><ul><li>FlyweightFactory：创建、管理、共享 Flyweight 对象。（采用懒加载创建）</li><li>Flyweight（示例中的 Glyph）：描述接口，通过这个接口 flyweight 可以接受并作用于外部状态。</li><li>ConcreteFlyweight（示例中的 Character）：（<em>该对象必须是可共享的</em>）实现 Flyweight 接口，并为内部状态（如果有的话）分配存储空间。</li><li>UnsharedConcreteFlyweight（示例中的 Row、Column）：并非所有的 Flyweight 子类都需要被共享</li><li>Client<ul><li>引用 Flyweight</li><li>计算/存储 Flyweight 的外部状态</li><li>用户不应直接对 ConcreteFlyweight 类进行实例化，而<em>只能从 FlyweightFactory 对象得到 ConcreteFlyweight 对象</em>，这可以保证对它们适当地进行共享。</li></ul></li></ul><h3 id=优缺点>优缺点
<a class=header-anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9></a></h3><ul><li>增大时间开销：传输、查找和/或计算外部状态都会产生运行时开销</li><li>减少空间开销：<ul><li>共享的 flyweight 越多，存储节约也就越多。</li><li>节约量随着共享状态的增多而增大。</li><li>当对象使用大量的内部及外部状态，并且外部状态是计算出来的而非存储的时候，节约量将达到最大。</li></ul></li></ul><p>Flyweight 模式经常和 Composite（4.3）模式结合起来表示一个层次式结构，这一层次式结构是一个共享叶结点的图。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/hard4.6-flyweight-%E4%BA%AB%E5%85%83-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/hard5.3-interpreter-%E8%A7%A3%E9%87%8A%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.jpg"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="「HARD」5.3-Interpreter-解释器-行为型模式"><meta itemprop=description content="目的

给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
示例

考虑解析简单的正则表达式，包含如下文法：

expression ::= literal | alternation | sequence | repretition |  &rsquo; (&rsquo; expression &lsquo;)&rsquo;
alternation ::= expression &lsquo;|&rsquo; expression
sequence ::= expression &lsquo;&&rsquo; expression
repetition ::= expression &lsquo;*&rsquo;
literal ::= &lsquo;a&rsquo; | &lsquo;b&rsquo; | &lsquo;c&rsquo;&mldr; ( &lsquo;a&rsquo; | &lsquo;b&rsquo; | &lsquo;c&rsquo;&mldr;)*

使用类去描述上述文法：


每个用这个文法定义的正则表达式都被表示为一个由这些类的实例构成的抽象语法树 AST
如果我们为 RegularExpression 的每一子类都定义解释（Interpret） 操作，那么就得到了这些正则表达式的一个解释器。

适用性

当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。
最好具备以下特性：

文法简单。对于复杂的文法，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无须构建抽象语法树即可解释表达式，这样可以节省空间而且还可能节省时间。
不太在意效率。最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下，转换器也可用解释器模式实现，该模式仍是有用的。

结构



AbstractExpression：定义抽象的解释操作
TerminalExpression：（终结符表达式，如 LiteralExpression）

定义终结符的解释操作
终结符：指的是文法中的运算单元，也就是不可再分的最小元素。
文法中的每一个终结符都有一个具体终结表达式与之相对应。


NonterminalExpression（非终结符表达式，如 AlternationExpression、Repetition-Expression、SequenceExpressions）：

文法中的每一条规则 R::=R1 R2…Rn 都需要一个 NonterminalExpression 类
为从 R1 到 Rn 的每个符号都维护一个 AbstractExpression 类型的实例变量。


Context（上下文）：解释器之外的全局信息
Client（客户）：构建（或被给定）表示该文法定义的语言中一个特定的句子的抽象语法树。

最后调用解释操作



工作流程：Client 构建（或被给定）一个句子，它是 NonterminalExpression 和 TerminalExpression 的实例的一个抽象语法树。然后初始化上下文并调用解释操作。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/hard5.3-interpreter-%E8%A7%A3%E9%87%8A%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>「HARD」5.3-Interpreter-解释器-行为型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:52:22 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:52:22 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h3 id=目的>目的
<a class=header-anchor href=#%e7%9b%ae%e7%9a%84></a></h3><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><h3 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h3><p>考虑解析简单的正则表达式，包含如下文法：</p><ul><li>expression ::= literal | alternation | sequence | repretition | &rsquo; (&rsquo; expression &lsquo;)&rsquo;</li><li>alternation ::= expression &lsquo;|&rsquo; expression</li><li>sequence ::= expression &lsquo;&&rsquo; expression</li><li>repetition ::= expression &lsquo;*&rsquo;</li><li>literal ::= &lsquo;a&rsquo; | &lsquo;b&rsquo; | &lsquo;c&rsquo;&mldr; ( &lsquo;a&rsquo; | &lsquo;b&rsquo; | &lsquo;c&rsquo;&mldr;)*</li></ul><p>使用类去描述上述文法：
<img src=/imgs/img-lazy-loading.gif data-src=./assets/%E3%80%8CHARD%E3%80%8D5.3-Interpreter-%E8%A7%A3%E9%87%8A%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-09_15-09-53-908.png alt></p><ul><li>每个用这个文法定义的正则表达式都被表示为一个由这些类的实例构成的抽象语法树 AST</li><li>如果我们为 RegularExpression 的每一子类都定义解释（Interpret） 操作，那么就得到了这些正则表达式的一个解释器。</li></ul><h3 id=适用性>适用性
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%80%a7></a></h3><p>当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。</p><p>最好具备以下特性：</p><ul><li>文法简单。对于复杂的文法，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无须构建抽象语法树即可解释表达式，这样可以节省空间而且还可能节省时间。</li><li>不太在意效率。最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下，转换器也可用解释器模式实现，该模式仍是有用的。</li></ul><h3 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h3><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/%E3%80%8CHARD%E3%80%8D5.3-Interpreter-%E8%A7%A3%E9%87%8A%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-09_15-17-01-856.png alt></p><ul><li>AbstractExpression：定义抽象的解释操作</li><li>TerminalExpression：（终结符表达式，如 LiteralExpression）<ul><li>定义终结符的解释操作</li><li><strong>终结符</strong>：指的是文法中的运算单元，也就是不可再分的最小元素。</li><li>文法中的每一个终结符都有一个具体终结表达式与之相对应。</li></ul></li><li>NonterminalExpression（非终结符表达式，如 AlternationExpression、Repetition-Expression、SequenceExpressions）：<ul><li>文法中的每一条规则 R::=R1 R2…Rn 都需要一个 NonterminalExpression 类</li><li>为从 R1 到 Rn 的每个符号都维护一个 AbstractExpression 类型的实例变量。</li></ul></li><li>Context（上下文）：解释器之外的全局信息</li><li>Client（客户）：构建（或被给定）表示该文法定义的语言中一个特定的句子的抽象语法树。<ul><li>最后调用解释操作</li></ul></li></ul><p><strong>工作流程</strong>：Client 构建（或被给定）一个句子，它是 NonterminalExpression 和 TerminalExpression 的实例的一个抽象语法树。然后初始化上下文并调用解释操作。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/hard5.3-interpreter-%E8%A7%A3%E9%87%8A%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%AE%BA/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.jpg"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="1-设计模式概论"><meta itemprop=description content="定义和组成要素

什么是模式：每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。
模式的组成要素：

模式名
问题：何时使用该模式
解决方案：描述设计的组成成分、相互关系和协作方式
影响：描述模式应当权衡的问题，对系统的灵活性、扩充性或可移植性的影响。如时空复杂度、语言和实现

由 MVC, Model-View-Controller 理解“模式”：

什么是 MVC：

模型：应用对象
视图：对象在屏幕上的显示
控制器：定义用户界面对用户输入的响应方式
MVC 通过建立订阅-通知协议来分离视图和模型。一旦模型的数据发生变化，模型将通知有关的视图，每个视图相应地得到刷新自己的机会。允许为一个模型提供不同的多个视图表现形式


推广 1：模型和视图分离→订阅对象和发布对象分离

将对象分离，使得一个对象的改变能够影响另一些对象，而这个对象并不需要知道那些被影响的对象的细节。这个更一般的设计被描述成 Observer


推广 2：MVC 允许视图嵌套，将组合 View 与单个 View 平等对待→将对象组视为一般对象

将一些对象划为一组，并将该组对象当作一个对象来使用。这个设计被描述为 Composite



设计模式的组成要素：

模式名、别名和分类
意图：解决什么问题
动机：说明一个设计问题以及如何用模式中的类、对象来解决该问题的特定情景
适用性
结构：类图和交互图（描述对象之间的请求序列和协作关系）
参与者：涉及的类和/或对象以及它们各自的职责。
协作：模式的参与者怎样协作以实现它们的职责。
影响
实现：实现时的注意事项
实际应用案例
相关模式

设计模式目录




创建型模式与对象的创建有关；


结构型模式处理类或对象的组合；


行为型模式对类或对象怎样交互和怎样分配职责进行描述。


类模式：处理类和子类的关系


对象模式：处理对象间的关系


设计模式中可变的部分：


Abstract Factory（3.1）：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。
Adapter（4.1）：将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
Bridge（4.2）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
Builder（3.2）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
Chain of Responsibility（5.1）：解除请求的发送者和接收者之间的耦合，使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。Command（5.2）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。
Composite（4.3）：将对象组合成树形结构以表示“部分–整体”的层次结构。Composite 使得客户对单个对象和组合对象的使用具有一致性。
Decorator（4.4）：动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator 模式比生成子类方式更为灵活。
Facade（4.5）：为子系统中的一组接口提供一个一致的界面， Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
Factory Method（3.3）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method 使一个类的实例化延迟到其子类。
Flyweight（4.6）：运用共享技术有效地支持大量细粒度的对象。
Interpreter（5.3）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。Iterator（5.4）：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
Mediator（5.5）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
Memento（5.6）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。
Observer（5.7）：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。
Prototype（3.4）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。
Proxy（4.7）：为其他对象提供一个代理以控制对这个对象的访问。
Singleton（3.5）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。State（5.8）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。
Strategy（5.9）：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。
Template Method（5.10）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。
Visitor（5.11）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

面向对象设计的步骤

设计原则

对接口编程，而不是对实现编程。这可以极大地减少子系统实现之间的相互依赖关系："></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%AE%BA/ itemprop=url class=post-title-link>1-设计模式概论</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:52:29 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:52:29 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h2 id=定义和组成要素>定义和组成要素
<a class=header-anchor href=#%e5%ae%9a%e4%b9%89%e5%92%8c%e7%bb%84%e6%88%90%e8%a6%81%e7%b4%a0></a></h2><p><strong>什么是模式</strong>：每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。</p><p><strong>模式的组成要素</strong>：</p><ul><li>模式名</li><li>问题：何时使用该模式</li><li>解决方案：描述设计的组成成分、相互关系和协作方式</li><li>影响：描述模式应当权衡的问题，对系统的灵活性、扩充性或可移植性的影响。如时空复杂度、语言和实现</li></ul><p>由 MVC, Model-View-Controller 理解“模式”：</p><ul><li>什么是 MVC：<ul><li>模型：应用对象</li><li>视图：对象在屏幕上的显示</li><li>控制器：定义用户界面对用户输入的响应方式</li><li>MVC 通过建立订阅-通知协议来分离视图和模型。一旦模型的数据发生变化，模型将通知有关的视图，每个视图相应地得到刷新自己的机会。允许为一个模型提供不同的多个视图表现形式</li></ul></li><li>推广 1：模型和视图分离→订阅对象和发布对象分离<ul><li>将对象分离，使得一个对象的改变能够影响另一些对象，而这个对象并不需要知道那些被影响的对象的细节。这个更一般的设计被描述成 Observer</li></ul></li><li>推广 2：MVC 允许视图嵌套，将组合 View 与单个 View 平等对待→将对象组视为一般对象<ul><li>将一些对象划为一组，并将该组对象当作一个对象来使用。这个设计被描述为 Composite</li></ul></li></ul><p><strong>设计模式的组成要素</strong>：</p><ul><li>模式名、别名和分类</li><li>意图：解决什么问题</li><li>动机：说明一个设计问题以及如何用模式中的类、对象来解决该问题的特定情景</li><li>适用性</li><li>结构：类图和交互图（描述对象之间的请求序列和协作关系）</li><li>参与者：涉及的类和/或对象以及它们各自的职责。</li><li>协作：模式的参与者怎样协作以实现它们的职责。</li><li>影响</li><li>实现：实现时的注意事项</li><li>实际应用案例</li><li>相关模式</li></ul><h2 id=设计模式目录>设计模式目录
<a class=header-anchor href=#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e7%9b%ae%e5%bd%95></a></h2><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%AE%BA/image-2023-09-20_19-23-19-922.png alt></p><ul><li><p>创建型模式与对象的创建有关；</p></li><li><p>结构型模式处理类或对象的组合；</p></li><li><p>行为型模式对类或对象怎样交互和怎样分配职责进行描述。</p></li><li><p>类模式：处理类和子类的关系</p></li><li><p>对象模式：处理对象间的关系</p></li></ul><p><strong>设计模式中可变的部分</strong>：
<img src=/imgs/img-lazy-loading.gif data-src=./assets/1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%AE%BA/image-2023-09-20_20-49-05-817.png alt></p><ol><li>Abstract Factory（3.1）：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</li><li>Adapter（4.1）：将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li><li>Bridge（4.2）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。</li><li>Builder（3.2）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li><li>Chain of Responsibility（5.1）：解除请求的发送者和接收者之间的耦合，使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。Command（5.2）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</li><li>Composite（4.3）：将对象组合成树形结构以表示“部分–整体”的层次结构。Composite 使得客户对单个对象和组合对象的使用具有一致性。</li><li>Decorator（4.4）：动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator 模式比生成子类方式更为灵活。</li><li>Facade（4.5）：为子系统中的一组接口提供一个一致的界面， Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li><li>Factory Method（3.3）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method 使一个类的实例化延迟到其子类。</li><li>Flyweight（4.6）：运用共享技术有效地支持大量细粒度的对象。</li><li>Interpreter（5.3）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。Iterator（5.4）：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</li><li>Mediator（5.5）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</li><li>Memento（5.6）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</li><li>Observer（5.7）：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。</li><li>Prototype（3.4）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</li><li>Proxy（4.7）：为其他对象提供一个代理以控制对这个对象的访问。</li><li>Singleton（3.5）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。State（5.8）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。</li><li>Strategy（5.9）：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</li><li>Template Method（5.10）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。</li><li>Visitor（5.11）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</li></ol><h2 id=面向对象设计的步骤>面向对象设计的步骤
<a class=header-anchor href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e8%ae%be%e8%ae%a1%e7%9a%84%e6%ad%a5%e9%aa%a4></a></h2><h3 id=设计原则>设计原则
<a class=header-anchor href=#%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99></a></h3><p><strong>对接口编程，而不是对实现编程</strong>。这可以极大地减少子系统实现之间的相互依赖关系：</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%AE%BA/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.jpg"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="3-创建型模式"><meta itemprop=description content="创建型模式

创建型设计模式抽象了实例化过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。
主要特征：

第一，它们都将关于该系统使用哪些具体的类的信息封装起来。
第二，它们隐藏了这些类的实例是如何被创建和放在一起的。

常用的对象创建型模式有：

抽象工厂 Abstract Factory：

    3.1-AbstractFactory「Kit」-抽象工厂-创建型模式
    

生成器 Builder
工厂方法 Factory Method
原型 Prototype
单例模式 Singleton

背景

游戏中的功能类

以一个地牢探索游戏创建房间为例，讨论 5 种模式。涉及的主要类有：



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39


// 房间的方向，北南东西
enum Direction {N,S,E,W}; 

// 创建迷宫的类
class MazeGame{
public:
	Maze* CreateMaze();
}

// 地图点的抽象类，有Room，Wall，Door3个子类
class MapSite{
public:
	virtual void Enter() = 0; // 进入该地点
}
// 墙
class Wall:public MapSite{
public:
	virtual void Enter();
}
// 门
class Door:public MapSite{  
public:
	Door(Room*=0,Room*=0);
	Room* OtherSideFrom(Room*);
	virtual void Enter();
private:
	Room *_room1,*_room2;
	bool _isOpen;
}
// 房间
class Room:public MapSite{
public:
	Room(int roomNo);
	MapSite *GetSide(Direction) const;
	virtual void Enter();
private:
	MapSite *_sides[4]; // 东西南北的地图点
	int _roomNumber;    // 房间编号
}



各类创建方法比较




 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16


// 硬编码
Maze* MazeGame::CreateMaze(){
	Maze* aMazenew Maze;
	Room* r1 = new Room(1); 
	Room* r2 new Room(2);
	Door* theDoor = new Door(rl, r2);
	
	aMaze->AddRoom (r1);
	aMaze->AddRoom (r2);
	
	r1->SetSide (North, new Wall); rl—>SetSide（East.theDoor）；
	rl->SetSide (South, new Wall); rl->SetSide (West, new Wall);
	r2->SetSide (North, new Wal1); r2->SetSide (East, new Wall): 
	r2->SetSide(South, new Wall); r2->SetSide (West, theDoor) 
	return aMaze;
}




硬编码方式的主要缺点是不灵活，修改迷宫的布局意味着修改这个实例方法，这容易产生错误也不易于复用
Factory Method：CreateMaze 调用虚函数而不是构造器来创建它需要的房间、墙壁和门，那么你可以创建一个 MazeGame 的子类并重定义这些虚函数，从而改变被实例化的类。
Abstract Factory：传递一个对象给 CreateMaze 作为参数来创建房间、墙壁和门，那么你可以传递不同的参数来改变房间、墙壁和门的类
Builder：传递一个对象给 CreateMaze，这个对象可以在它所建造的迷宫中使用增加房间、墙壁和门的操作来全面创建一个新的迷宫，那么你可以使用继承来改变迷宫的一些部分或迷宫的建造方式。
Prototype：CreateMaze 由多种原型的房间、墙壁和门对象参数化，它复制并将这些对象增加到迷宫中，那么你可以用不同的对象替换这些原型对象以改变迷宫的构成。
Singleton：可以保证每个游戏中仅有一个迷宫而且所有的游戏对象都可以迅速访问它——不需要求助于全局变
量或函数。Singleton 也使得迷宫易于扩展或替换，且不需要变动已有的代码。

讨论

对系统进行参数化主要有 2 种方法："></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>3-创建型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:52:36 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:52:36 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h1 id=创建型模式>创建型模式
<a class=header-anchor href=#%e5%88%9b%e5%bb%ba%e5%9e%8b%e6%a8%a1%e5%bc%8f></a></h1><p>创建型设计模式抽象了实例化过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。</p><p><strong>主要特征</strong>：</p><ul><li>第一，它们都将关于该系统使用哪些具体的类的信息封装起来。</li><li>第二，它们隐藏了这些类的实例是如何被创建和放在一起的。</li></ul><p>常用的对象创建型模式有：</p><ul><li>抽象工厂 Abstract Factory：
<a href=./3.1-AbstractFactory%E3%80%8CKit%E3%80%8D-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.md# title=3.1-AbstractFactory「Kit」-抽象工厂-创建型模式>3.1-AbstractFactory「Kit」-抽象工厂-创建型模式</a></li><li>生成器 Builder</li><li>工厂方法 Factory Method</li><li>原型 Prototype</li><li>单例模式 Singleton</li></ul><h2 id=背景>背景
<a class=header-anchor href=#%e8%83%8c%e6%99%af></a></h2><h3 id=游戏中的功能类>游戏中的功能类
<a class=header-anchor href=#%e6%b8%b8%e6%88%8f%e4%b8%ad%e7%9a%84%e5%8a%9f%e8%83%bd%e7%b1%bb></a></h3><p>以一个地牢探索游戏创建房间为例，讨论 5 种模式。涉及的主要类有：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span><span class=lnt id=hl-0-32><a class=lnlinks href=#hl-0-32>32</a>
</span><span class=lnt id=hl-0-33><a class=lnlinks href=#hl-0-33>33</a>
</span><span class=lnt id=hl-0-34><a class=lnlinks href=#hl-0-34>34</a>
</span><span class=lnt id=hl-0-35><a class=lnlinks href=#hl-0-35>35</a>
</span><span class=lnt id=hl-0-36><a class=lnlinks href=#hl-0-36>36</a>
</span><span class=lnt id=hl-0-37><a class=lnlinks href=#hl-0-37>37</a>
</span><span class=lnt id=hl-0-38><a class=lnlinks href=#hl-0-38>38</a>
</span><span class=lnt id=hl-0-39><a class=lnlinks href=#hl-0-39>39</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 房间的方向，北南东西
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>enum</span> <span class=nc>Direction</span> <span class=p>{</span><span class=n>N</span><span class=p>,</span><span class=n>S</span><span class=p>,</span><span class=n>E</span><span class=p>,</span><span class=n>W</span><span class=p>};</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 创建迷宫的类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>MazeGame</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Maze</span><span class=o>*</span> <span class=n>CreateMaze</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 地图点的抽象类，有Room，Wall，Door3个子类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>MapSite</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=n>Enter</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// 进入该地点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 墙
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Wall</span><span class=o>:</span><span class=k>public</span> <span class=n>MapSite</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=n>Enter</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 门
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Door</span><span class=o>:</span><span class=k>public</span> <span class=n>MapSite</span><span class=p>{</span>  
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Door</span><span class=p>(</span><span class=n>Room</span><span class=o>*=</span><span class=mi>0</span><span class=p>,</span><span class=n>Room</span><span class=o>*=</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>Room</span><span class=o>*</span> <span class=nf>OtherSideFrom</span><span class=p>(</span><span class=n>Room</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Enter</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Room</span> <span class=o>*</span><span class=n>_room1</span><span class=p>,</span><span class=o>*</span><span class=n>_room2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=n>_isOpen</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 房间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Room</span><span class=o>:</span><span class=k>public</span> <span class=n>MapSite</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Room</span><span class=p>(</span><span class=kt>int</span> <span class=n>roomNo</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>MapSite</span> <span class=o>*</span><span class=nf>GetSide</span><span class=p>(</span><span class=n>Direction</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Enter</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>MapSite</span> <span class=o>*</span><span class=n>_sides</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span> <span class=c1>// 东西南北的地图点
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>int</span> <span class=n>_roomNumber</span><span class=p>;</span>    <span class=c1>// 房间编号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=各类创建方法比较>各类创建方法比较
<a class=header-anchor href=#%e5%90%84%e7%b1%bb%e5%88%9b%e5%bb%ba%e6%96%b9%e6%b3%95%e6%af%94%e8%be%83></a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 硬编码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Maze</span><span class=o>*</span> <span class=n>MazeGame</span><span class=o>::</span><span class=n>CreateMaze</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>Maze</span><span class=o>*</span> <span class=n>aMazenew</span> <span class=n>Maze</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>Room</span><span class=o>*</span> <span class=n>r1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Room</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>	<span class=n>Room</span><span class=o>*</span> <span class=n>r2</span> <span class=k>new</span> <span class=nf>Room</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>Door</span><span class=o>*</span> <span class=n>theDoor</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Door</span><span class=p>(</span><span class=n>rl</span><span class=p>,</span> <span class=n>r2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=n>aMaze</span><span class=o>-&gt;</span><span class=n>AddRoom</span> <span class=p>(</span><span class=n>r1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>aMaze</span><span class=o>-&gt;</span><span class=n>AddRoom</span> <span class=p>(</span><span class=n>r2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=n>r1</span><span class=o>-&gt;</span><span class=n>SetSide</span> <span class=p>(</span><span class=n>North</span><span class=p>,</span> <span class=k>new</span> <span class=n>Wall</span><span class=p>);</span> <span class=n>rl</span><span class=err>—</span><span class=o>&gt;</span><span class=n>SetSide</span><span class=err>（</span><span class=n>East</span><span class=p>.</span><span class=n>theDoor</span><span class=err>）；</span>
</span></span><span class=line><span class=cl>	<span class=n>rl</span><span class=o>-&gt;</span><span class=n>SetSide</span> <span class=p>(</span><span class=n>South</span><span class=p>,</span> <span class=k>new</span> <span class=n>Wall</span><span class=p>);</span> <span class=n>rl</span><span class=o>-&gt;</span><span class=n>SetSide</span> <span class=p>(</span><span class=n>West</span><span class=p>,</span> <span class=k>new</span> <span class=n>Wall</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>r2</span><span class=o>-&gt;</span><span class=n>SetSide</span> <span class=p>(</span><span class=n>North</span><span class=p>,</span> <span class=k>new</span> <span class=n>Wal1</span><span class=p>);</span> <span class=n>r2</span><span class=o>-&gt;</span><span class=n>SetSide</span> <span class=p>(</span><span class=n>East</span><span class=p>,</span> <span class=k>new</span> <span class=n>Wall</span><span class=p>)</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>	<span class=n>r2</span><span class=o>-&gt;</span><span class=n>SetSide</span><span class=p>(</span><span class=n>South</span><span class=p>,</span> <span class=k>new</span> <span class=n>Wall</span><span class=p>);</span> <span class=n>r2</span><span class=o>-&gt;</span><span class=n>SetSide</span> <span class=p>(</span><span class=n>West</span><span class=p>,</span> <span class=n>theDoor</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>aMaze</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ul><li>硬编码方式的主要缺点是不灵活，修改迷宫的布局意味着修改这个实例方法，这容易产生错误也不易于复用</li><li><strong>Factory Method</strong>：CreateMaze 调用虚函数而不是构造器来创建它需要的房间、墙壁和门，那么你可以创建一个 MazeGame 的子类并重定义这些虚函数，从而改变被实例化的类。</li><li><strong>Abstract Factory</strong>：传递一个对象给 CreateMaze 作为参数来创建房间、墙壁和门，那么你可以传递不同的参数来改变房间、墙壁和门的类</li><li><strong>Builder</strong>：传递一个对象给 CreateMaze，这个对象可以在它所建造的迷宫中使用增加房间、墙壁和门的操作来全面创建一个新的迷宫，那么你可以使用继承来改变迷宫的一些部分或迷宫的建造方式。</li><li><strong>Prototype</strong>：CreateMaze 由多种原型的房间、墙壁和门对象参数化，它复制并将这些对象增加到迷宫中，那么你可以用不同的对象替换这些原型对象以改变迷宫的构成。</li><li><strong>Singleton</strong>：可以保证每个游戏中仅有一个迷宫而且所有的游戏对象都可以迅速访问它——不需要求助于全局变
量或函数。Singleton 也使得迷宫易于扩展或替换，且不需要变动已有的代码。</li></ul><h2 id=讨论>讨论
<a class=header-anchor href=#%e8%ae%a8%e8%ae%ba></a></h2><p>对系统进行参数化主要有 2 种方法：</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.1-abstractfactorykit-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.jpg"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="3.1-AbstractFactory「Kit」-抽象工厂-创建型模式"><meta itemprop=description content="又称 Kit
Abstract Factory 抽象工厂

用途

用途：提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。
示例

示例： GUI 程序需要支持 Motif 和 PW 这 2 种视窗标准：

抽象工厂提供 CreateXXX 接口生产抽象组件 XXX，用户调用该函数获取 XXX 组件
抽象工厂的具象工厂子类实现 CreateXXX 接口，生产自己这种类型的具象组件 YYXXX（YYWindow，YYScrollBar,&mldr;）
客户仅与抽象类定义的接口交互，而不使用特定的具体类的接口


结构



AbstractFactory：声明一个创建抽象产品对象的接口
ConcreteFactory：实现创建具体产品对象的操作
AbstractProduct：为一类产品对象声明一个接口
ConcreteProduct：定义具体的产品对象，实现 AbstractProduct 接口
Client：只使用 Abstract 的接口

协作过程：

通常在运行时创建一个 ConcreteFactroy 类的实例。这一具体的工厂创建具有特定实现的产品对象。为创建不同的产品对象，客户应使用不同的具体工厂。

说明：简单实现时，AbstractFactory 和 ConcreteFactory 可以合二为一


AbstractFactory 将产品对象的创建延迟到它的 ConcreteFactory 子类。

适用条件


系统独立于产品的创建、组合和表示
系统包含多个产品系列，用其中的一种进行表示
强调一个系列的产品设计，以便联合使用
提供产品类库，但是只显示接口而隐藏实现

优缺点


优点：

分离实现：工厂封装了创建产品对象的责任和过程，将客户和具体实现分离。客户只操作抽象接口，避免硬编码具体的类名
易于切换产品系列
有利于产品风格的一致性：应用一次只能使用同一个系列中的对象，这有利于维护一致性


缺点：

难以支持新种类的产品：AbstractFactory 定义了可被其创建的产品集合，创建新产品意味着需要扩展 AbstractFactory 和其所有子类的接口。



实现的注意事项


工厂使用单例模式：一个应用通常每个产品系列只需要一个 ConcreteFactory 实例
创建产品的方法：

常用方法：为每个产品定义一个工厂方法，具体的工厂为每个工厂重载该工厂方法以指定产品
简化具体工厂类：可以使用 Prototype 模式实现具体工厂。具体工厂使用产品系列中每一个产品的原型实例来初始化，且它通过复制它的原型来创建新的产品。基于原型的方法使得并非每个新的产品系列都需要一个新的具体工厂类。


可扩展的工厂：

通常增加一种新的产品要求改变 AbstractFactory 的接口以及所有与它相关的类。
一个更灵活但不太安全的设计是给创建对象的操作增加一个参数（例如类标识符，字符串，整数索引等）该参数指定了将被创建的对象的种类。使用这种方法 AbstractFactory 只需要一个“Make”操作和一个指示要创建对象的种类的参数。
客户需要使用执行向下类型转换（downcast，例如 cpp 中的 dynamic_cast）才能获得具体的子类型，而这会带来安全隐患


"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.1-abstractfactorykit-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>3.1-AbstractFactory「Kit」-抽象工厂-创建型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:52:58 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:52:58 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><p>又称 <strong>Kit</strong></p><h2 id=abstract-factory-抽象工厂>Abstract Factory 抽象工厂
<a class=header-anchor href=#abstract-factory-%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82></a></h2><h4 id=用途>用途
<a class=header-anchor href=#%e7%94%a8%e9%80%94></a></h4><p>用途：提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。</p><h4 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h4><p>示例： GUI 程序需要支持 Motif 和 PW 这 2 种视窗标准：</p><ul><li>抽象工厂提供 CreateXXX 接口生产抽象组件 XXX，用户调用该函数获取 XXX 组件</li><li>抽象工厂的具象工厂子类实现 CreateXXX 接口，生产自己这种类型的具象组件 YYXXX（YYWindow，YYScrollBar,&mldr;）</li><li><strong>客户仅与抽象类定义的接口交互，而不使用特定的具体类的接口</strong>
<img src=/imgs/img-lazy-loading.gif data-src=./assets/3.1-AbstractFactory%E3%80%8CKit%E3%80%8D-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-24_13-01-22-769.png alt></li></ul><h4 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h4><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/3.1-AbstractFactory%E3%80%8CKit%E3%80%8D-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-24_15-12-44-904.png alt></p><ul><li>AbstractFactory：声明一个创建抽象产品对象的接口</li><li>ConcreteFactory：实现创建具体产品对象的操作</li><li>AbstractProduct：为一类产品对象声明一个接口</li><li>ConcreteProduct：定义具体的产品对象，实现 AbstractProduct 接口</li><li>Client：只使用 Abstract 的接口</li></ul><p>协作过程：</p><ul><li>通常在运行时创建一个 ConcreteFactroy 类的实例。这一具体的工厂创建具有特定实现的产品对象。为创建不同的产品对象，客户应使用不同的具体工厂。<ul><li>说明：简单实现时，AbstractFactory 和 ConcreteFactory 可以合二为一</li></ul></li><li>AbstractFactory 将产品对象的创建延迟到它的 ConcreteFactory 子类。</li></ul><h4 id=适用条件>适用条件
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%9d%a1%e4%bb%b6></a></h4><ul><li>系统独立于产品的创建、组合和表示</li><li>系统包含多个产品系列，用其中的一种进行表示</li><li>强调一个系列的产品设计，以便联合使用</li><li>提供产品类库，但是只显示接口而隐藏实现</li></ul><h4 id=优缺点>优缺点
<a class=header-anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9></a></h4><ul><li>优点：<ul><li>分离实现：工厂封装了创建产品对象的责任和过程，将客户和具体实现分离。客户只操作抽象接口，避免硬编码具体的类名</li><li>易于切换产品系列</li><li>有利于产品风格的一致性：应用一次只能使用同一个系列中的对象，这有利于维护一致性</li></ul></li><li>缺点：<ul><li>难以支持新种类的产品：AbstractFactory 定义了可被其创建的产品集合，创建新产品意味着需要扩展 AbstractFactory 和其<em>所有</em>子类的接口。</li></ul></li></ul><h4 id=实现的注意事项>实现的注意事项
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0%e7%9a%84%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9></a></h4><ul><li><strong>工厂使用单例模式</strong>：一个应用通常每个产品系列只需要一个 ConcreteFactory 实例</li><li><strong>创建产品的方法</strong>：<ul><li>常用方法：为每个产品定义一个工厂方法，具体的工厂为每个工厂重载该工厂方法以指定产品</li><li>简化具体工厂类：可以使用 Prototype 模式实现具体工厂。具体工厂使用产品系列中每一个产品的原型实例来初始化，且它通过复制它的原型来创建新的产品。基于原型的方法<em>使得并非每个新的产品系列都需要一个新的具体工厂类。</em></li></ul></li><li><strong>可扩展的工厂</strong>：<ul><li>通常增加一种新的产品要求改变 AbstractFactory 的接口以及所有与它相关的类。</li><li>一个更灵活但不太安全的设计是给创建对象的操作增加一个参数（例如类标识符，字符串，整数索引等）该参数指定了将被创建的对象的种类。使用这种方法 AbstractFactory 只需要一个“Make”操作和一个指示要创建对象的种类的参数。</li><li>客户需要使用执行<strong>向下类型转换</strong>（downcast，例如 cpp 中的 dynamic_cast）才能获得具体的子类型，而这会带来安全隐患</li></ul></li></ul></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.1-abstractfactorykit-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.2-builder-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.jpg"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="3.2-Builder-生成器模式-创建型模式"><meta itemprop=description content="Builder

用途

将复杂对象的构建和表示分离，使得同样的构建过程可以创建不同的表示。
示例

考虑应用场景：将 RTF 文档转换为其他多种文本格式，对于任意结构的文档，可能的转换数目是无限的


RTFReader：分析文档，每次遇到一个标记时发送请求调用 TextConverter 转换该标记。


TextConverter 对象负责进行数据转换以及用特定格式表示该标记，其子类对不同转换和不同格式进行特殊处理。


解释：Builder 模式描述了所有这些关系。

每一个转换器类在该模式中被称为生成器（builder），而阅读器则称为导向器（director）
Builder 模式将分析文本格式的算法（即 RTF 文档的语法分析程序）与描述怎样创建和表示一个转换后格式的算法分离开来。这使我们可以复用 RTFReader 的语法分析算法，根据 RTF 文档创建不同的文本表示——仅需使用不同的 TextConverter 的子类配置该 RTFReader 即可。




适用情形


当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。
当构造过程必须允许被构造的对象有不同的表示时。

结构



Builder：创建 Product 的抽象接口
ConcreteBuilder：（ASCIIConverter、TeXConverter、 TextWidgetConverter）

构造和装配产品的各个部件
定义和跟踪自己创建的表示
提供检索产品的接口（例如，GetASCIIText 和 GetTextWidget）


Director：（RTFReader）构造使用 builder 接口的对象
Product（ASCIIText、TeXText、TextWidget）

被构建的复杂对象，具体生成器创建该产品的内部表示并定义装配过程
包含定义组件部件的类，以及将这些部件装配成最终产品的接口



协作过程如下：

客户创建 Director 对象，并用它所想要的 Builder 对象进行配置。
一旦生成了产品部件，导向器就会通知生成器。
生成器处理导向器的请求，并将部件添加到该产品中。
客户从生成器中获取最终产品。


优缺点


可以改变一个产品的内部表示：因为产品是通过抽象接口构造的，你在改变该产品的内部表示时所要做的只是定义一个新的生成器。
将构造代码和表示代码分开：Builder 模式通过封装一个复杂对象的创建和表示方式提高了对象的模块性。构造代码只写一次，不同的 Director 可以反复复用构造代码在同一套部件集合上创建不同的表示
可以精细控制构造过程：它是在导向器的控制下一步一步构造产品的。仅当该产品完成时导向器才从生成器中取回它。

实现

通常有一个抽象的 Builder 类为导向器可能要求创建的每一个构件定义一个操作（默认什么都不做）。
一个 ConcreteBuilder 类对它有兴趣创建的构件重定义这些操作。"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.2-builder-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>3.2-Builder-生成器模式-创建型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:53:04 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:53:04 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h1 id=builder>Builder
<a class=header-anchor href=#builder></a></h1><h4 id=用途>用途
<a class=header-anchor href=#%e7%94%a8%e9%80%94></a></h4><p>将复杂对象的构建和表示分离，使得同样的构建过程可以创建不同的表示。</p><h4 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h4><p>考虑应用场景：将 RTF 文档转换为其他多种文本格式，对于任意结构的文档，可能的转换数目是无限的</p><ul><li><p>RTFReader：分析文档，每次遇到一个标记时发送请求调用 TextConverter 转换该标记。</p></li><li><p>TextConverter 对象负责进行数据转换以及用特定格式表示该标记，其子类对不同转换和不同格式进行特殊处理。</p></li><li><p>解释：Builder 模式描述了所有这些关系。</p><ul><li>每一个转换器类在该模式中被称为生成器（builder），而阅读器则称为导向器（director）</li><li>Builder 模式将分析文本格式的算法（即 RTF 文档的语法分析程序）与描述怎样创建和表示一个转换后格式的算法分离开来。这使我们可以复用 RTFReader 的语法分析算法，根据 RTF 文档创建不同的文本表示——仅需使用不同的 TextConverter 的子类配置该 RTFReader 即可。</li></ul></li></ul><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/3.2-Builder-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-24_15-03-46-060.png alt></p><h4 id=适用情形>适用情形
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%83%85%e5%bd%a2></a></h4><ul><li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li><li>当构造过程必须允许被构造的对象有不同的表示时。</li></ul><h4 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h4><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/3.2-Builder-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-24_15-12-06-045.png alt></p><ul><li>Builder：创建 Product 的抽象接口</li><li>ConcreteBuilder：（ASCIIConverter、TeXConverter、 TextWidgetConverter）<ul><li>构造和装配产品的各个部件</li><li>定义和跟踪自己创建的表示</li><li>提供检索产品的接口（例如，GetASCIIText 和 GetTextWidget）</li></ul></li><li>Director：（RTFReader）构造使用 builder 接口的对象</li><li>Product（ASCIIText、TeXText、TextWidget）<ul><li>被构建的复杂对象，具体生成器创建该产品的内部表示并定义装配过程</li><li>包含定义组件部件的类，以及将这些部件装配成最终产品的接口</li></ul></li></ul><p><strong>协作过程如下</strong>：</p><ul><li>客户创建 Director 对象，并用它所想要的 Builder 对象进行配置。</li><li>一旦生成了产品部件，导向器就会通知生成器。</li><li>生成器处理导向器的请求，并将部件添加到该产品中。</li><li>客户从生成器中获取最终产品。
<img src=/imgs/img-lazy-loading.gif data-src=./assets/3.2-Builder-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-24_15-22-11-430.png alt></li></ul><h4 id=优缺点>优缺点
<a class=header-anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9></a></h4><ul><li>可以改变一个产品的内部表示：因为产品是通过抽象接口构造的，你在改变该产品的内部表示时所要做的只是定义一个新的生成器。</li><li>将构造代码和表示代码分开：Builder 模式通过封装一个复杂对象的创建和表示方式提高了对象的模块性。构造代码只写一次，不同的 Director 可以反复复用构造代码在同一套部件集合上创建不同的表示</li><li>可以精细控制构造过程：它是在导向器的控制下一步一步构造产品的。仅当该产品完成时导向器才从生成器中取回它。</li></ul><h4 id=实现>实现
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0></a></h4><p>通常有一个抽象的 Builder 类为导向器可能要求创建的<em>每一个构件</em>定义一个操作（默认什么都不做）。
一个 ConcreteBuilder 类对它有兴趣创建的构件重定义这些操作。</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.2-builder-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.3-factorymethod-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.jpg"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="3.3-FactoryMethod-工厂方法-创建型模式"><meta itemprop=description content="又称虚构造器（virtual constructor）
用途

定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method 使一个类的实例化延迟到其子类。
示例

框架用抽象类定义和维护对象之间的关系。
Eg：框架定义了 App 抽象类，它包含一个 Document 抽象内容。但是 App 类无法确认应当实例化哪个 Document 的具象子类：

方法：

抽象类 App 中提供接口 CreateDocument。
具象 App 子类重载接口 CreateDocument，并创建自己要用到具象的 Document




结构



Product：定义工厂方法要创建的对象的类别
ConcreteProduct：
Creator：抽象工厂，定义用于返回 Product 的工厂方法（接口），该接口可以是抽象的，也可以提供一个默认实现返回缺省的 ConcreteProduct
ConcreteCreator：具象工厂，重载工厂接口

说明：

Creator 依赖子类重载工厂方法以返回合适的 ConcreteProduct

适用性


一个类不确定自己要创建的对象的类
一个类希望由子类指定自己创建的对象的类

优缺点

工厂方法的潜在缺点：客户可能只是为了创建一个特定的 ConcreteProduct 对象，就必须创建 Creator 的新的子类
优点：

工厂方法不再将应用相关的类绑定到程序代码中。代码只处理 Product 接口
可以为子类提供钩子 Hook（提供合理的缺省实现）
可以连接平行的类层次：例如图形类和用户的操作是平行的类层次，而抽象父类 Figure 可以提供 CreateManipulator 方法连接 Manipulate 类层次，并为子类提供默认实现


实现


Creator 可以是抽象类，也可以是提供了缺省实现的具象类

抽象类不提供默认实现，可以避免不得不实例化不可预见类的问题
具象类：这种情况比直接 new 个实例具有更好的灵活性


参数化工厂方法：这允许工厂方法创建多种类型的对象。工厂方法可以采用一个标识（指定要被创建的对象种类的参数）区分不同类型的对象（这些对象都必须是 Product 的子类型）

重定义一个参数化的工厂方法使你可以简单而有选择性地扩展或改变一个 Creator 生产的产品。注意最后需要调用父类的 Create


命名约定：使用命名约定是一个好习惯，它可以清楚地说明你正在使用工厂方法


Cpp 中的工厂方法："></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.3-factorymethod-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/ itemprop=url class=post-title-link>3.3-FactoryMethod-工厂方法-创建型模式</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:53:09 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:53:09 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><p>又称<strong>虚构造器（virtual constructor）</strong></p><h4 id=用途>用途
<a class=header-anchor href=#%e7%94%a8%e9%80%94></a></h4><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method 使一个类的实例化延迟到其子类。</p><h4 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h4><p>框架用抽象类定义和维护对象之间的关系。
Eg：框架定义了 App 抽象类，它包含一个 Document 抽象内容。但是 App 类无法确认应当实例化哪个 Document 的具象子类：</p><ul><li>方法：<ul><li>抽象类 App 中提供接口 CreateDocument。</li><li>具象 App 子类重载接口 CreateDocument，并创建自己要用到具象的 Document
<img src=/imgs/img-lazy-loading.gif data-src=./assets/3.3-FactoryMethod-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-26_10-24-30-852.png alt></li></ul></li></ul><h4 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h4><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/3.3-FactoryMethod-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-26_10-35-30-090.png alt></p><ul><li>Product：定义工厂方法要创建的对象的类别</li><li>ConcreteProduct：</li><li>Creator：抽象工厂，定义用于返回 Product 的工厂方法（接口），该接口可以是抽象的，也可以提供一个默认实现返回缺省的 ConcreteProduct</li><li>ConcreteCreator：具象工厂，重载工厂接口</li></ul><p>说明：</p><ul><li>Creator 依赖子类重载工厂方法以返回合适的 ConcreteProduct</li></ul><h4 id=适用性>适用性
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%80%a7></a></h4><ul><li>一个类不确定自己要创建的对象的类</li><li>一个类希望由子类指定自己创建的对象的类</li></ul><h4 id=优缺点>优缺点
<a class=header-anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9></a></h4><p>工厂方法的潜在缺点：客户可能只是为了创建一个特定的 ConcreteProduct 对象，就必须创建 Creator 的新的子类</p><p>优点：</p><ul><li>工厂方法不再将应用相关的类绑定到程序代码中。代码只处理 Product 接口</li><li>可以为子类提供钩子 Hook（提供合理的缺省实现）</li><li>可以连接平行的类层次：例如图形类和用户的操作是平行的类层次，而抽象父类 Figure 可以提供 CreateManipulator 方法连接 Manipulate 类层次，并为子类提供默认实现
<img src=/imgs/img-lazy-loading.gif data-src=./assets/3.3-FactoryMethod-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-26_10-48-51-858.png alt></li></ul><h4 id=实现>实现
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0></a></h4><ul><li>Creator 可以是抽象类，也可以是提供了缺省实现的具象类<ul><li>抽象类不提供默认实现，可以避免不得不实例化不可预见类的问题</li><li>具象类：这种情况比直接 new 个实例具有更好的灵活性</li></ul></li><li>参数化工厂方法：这允许工厂方法创建多种类型的对象。工厂方法可以采用一个标识（指定要被创建的对象种类的参数）区分不同类型的对象（这些对象都必须是 Product 的子类型）<ul><li>重定义一个参数化的工厂方法使你可以简单而有选择性地扩展或改变一个 Creator 生产的产品。注意最后需要调用父类的 Create</li></ul></li><li><strong>命名约定</strong>：使用命名约定是一个好习惯，它可以清楚地说明你正在使用工厂方法
<img src=/imgs/img-lazy-loading.gif data-src=./assets/3.3-FactoryMethod-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-26_10-58-47-704.png alt=600></li></ul><p><strong>Cpp 中的工厂方法</strong>：</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.3-factorymethod-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.4-prototype-%E5%8E%9F%E5%9E%8B-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%96%B9%E6%B3%95/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/csmtc.jpg"><meta itemprop=name content="CSMTC"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="CSMTC"><meta itemprop=description content="分享让自我更强大"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="3.4-Prototype-原型-创建型方法"><meta itemprop=description content="用途

用原型指定创建对象的种类，拷贝这些原型创建新的对象
示例


例如采用工具类操作图形元素：

若为每个图形元素创建相应工具类，则过于冗杂
采用原型方法：

工具类拷贝一个图形元素的实例，添加到文档中



适用情形


当一个系统应该独立于它的产品创建、构成和表示时。
当要实例化的类是在运行时指定时，例如，通过动态装载。
为了避免创建一个与产品类层次平行的工厂类层次时。
当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

结构


Prototype：提供 clone 自身的接口

ConcretePrototype：实现 clone 的操作


Client：用原型 clone 自身从而创建新的对象


优缺点

Prototype 有许多与 Abstract Factory（3.1）和 Builder（3.2）一样的效果：

它对客户隐藏了具体的产品类，因此减少了客户知道的名字的数目。
此外，这些模式使客户无须改变自身代码即可使用与特定应用相关的类。

其他优点：

运行时增加和删除产品
改变值以指定新对象：高度动态的系统允许你通过对象组合定义新的行为——例如，通过为一个对象变量指定值——并且不定义新的类。
克隆一个原型类似于实例化一个类。Prototype 模式可以极大地减少系统所需要的类的数目。
改变结构以指定新对象许多应用由部件和子部件来创建对象。

例如电路设计编辑器就是由子电路来构造电路的：这样的应用通常允许你实例化复杂的、用户定义的结构，比方说，一次又一次地重复使用一个特定的子电路。
Prototype 模式只要组合电路对象将 Clone 实现为一个深拷贝（deep copy），具有不同结构的电路就可以是原型了。


减少子类的构造：Factory Method（3.3）经常产生一个与产品类层次平行的 Creator 类层次。Prototype 模式使得你克隆一个原型而不是请求一个工厂方法去产生一个新的对象，因此你根本不需要 Creator 类层次。

主要适用于像 C++这样不将类作为一级类对象的语言（通常是静态语言）。这种语言中，类本身不是一种对象，而是一种特殊的数据类型或结构。这意味着，这种语言中，类不能被当作参数传递给函数，也不能被当作返回值返回，也不能被动态创建或销毁。例如，C++中的类只能在编译时静态定义，而不能在运行时动态生成或修改。
相反，将类作为一级类对象的语言（通常是动态语言），则认为类本身也是一种对象，只不过是用来创建其他对象的对象。这意味着，这种语言中，类可以被当作参数传递给函数，也可以被当作返回值返回，也可以被动态创建或销毁。例如，Python 就是一种将类作为一级类对象的语言，因为 Python 中的类是由 type 这个元类创建的对象，而且可以在运行时动态生成或修改2。


用类动态配置应用一些运行时环境允许你动态地将类装载到应用中。

一个希望创建动态载入类的实例的应用不能静态引用类的构造器，而应该由运行环境在载入时自动创建每个类的实例，并用原型管理器来注册这个实例。这样应用就可以向原型管理器请求新装载的类的实例，这些类原本并没有和程序相连接。



缺陷：

每个 Prototype 子类必须实现 clone 操作，而这可能非常困难

实现

在像 C++这样的静态语言中，类不是对象，并且运行时只能得到很少或者得不到任何类型信息，所以 Prototype 特别有用。
相反，在类似 Python 这样的语言中意义不大，语言自带等价于原型的东西（类对象、元类等）"></span><header class=post-header><h2 class=post-title itemprop="name headline"><a href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.4-prototype-%E5%8E%9F%E5%9E%8B-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%96%B9%E6%B3%95/ itemprop=url class=post-title-link>3.4-Prototype-原型-创建型方法</a></h2><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-03-28 15:49:58 +00:00" itemprop="dateCreated datePublished" datetime="2024-03-28 15:49:58 +0000 UTC">2024-03-28
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title="修改时间：2025-03-12 02:53:13 +00:00" itemprop="dateModified dateLastmod" datetime="2025-03-12 02:53:13 +0000 UTC">2025-03-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h4 id=用途>用途
<a class=header-anchor href=#%e7%94%a8%e9%80%94></a></h4><p>用原型指定创建对象的种类，拷贝这些原型创建新的对象</p><h4 id=示例>示例
<a class=header-anchor href=#%e7%a4%ba%e4%be%8b></a></h4><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/3.4-Prototype-%E5%8E%9F%E5%9E%8B-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%96%B9%E6%B3%95/image-2023-09-26_12-32-40-532.png alt></p><p>例如采用工具类操作图形元素：</p><ul><li>若为每个图形元素创建相应工具类，则过于冗杂</li><li>采用原型方法：<ul><li>工具类拷贝一个图形元素的实例，添加到文档中</li></ul></li></ul><h4 id=适用情形>适用情形
<a class=header-anchor href=#%e9%80%82%e7%94%a8%e6%83%85%e5%bd%a2></a></h4><ul><li>当一个系统应该独立于它的产品创建、构成和表示时。</li><li>当要实例化的类是在运行时指定时，例如，通过动态装载。</li><li>为了避免创建一个与产品类层次平行的工厂类层次时。</li><li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li></ul><h4 id=结构>结构
<a class=header-anchor href=#%e7%bb%93%e6%9e%84></a></h4><ul><li>Prototype：提供 clone 自身的接口<ul><li>ConcretePrototype：实现 clone 的操作</li></ul></li><li>Client：用原型 clone 自身从而创建新的对象</li></ul><p><img src=/imgs/img-lazy-loading.gif data-src=./assets/3.4-Prototype-%E5%8E%9F%E5%9E%8B-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%96%B9%E6%B3%95/image-2023-09-26_12-51-54-343.png alt></p><h4 id=优缺点>优缺点
<a class=header-anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9></a></h4><p>Prototype 有许多与 Abstract Factory（3.1）和 Builder（3.2）一样的效果：</p><ul><li>它对客户隐藏了具体的产品类，因此减少了客户知道的名字的数目。</li><li>此外，这些模式使客户无须改变自身代码即可使用与特定应用相关的类。</li></ul><p><strong>其他优点</strong>：</p><ul><li>运行时增加和删除产品</li><li>改变值以指定新对象：高度动态的系统允许你通过对象组合定义新的行为——例如，通过为一个对象变量指定值——并且不定义新的类。
克隆一个原型类似于实例化一个类。Prototype 模式可以极大地减少系统所需要的类的数目。</li><li>改变结构以指定新对象许多应用由部件和子部件来创建对象。<ul><li>例如电路设计编辑器就是由子电路来构造电路的：这样的应用通常允许你实例化复杂的、用户定义的结构，比方说，一次又一次地重复使用一个特定的子电路。</li><li>Prototype 模式只要组合电路对象将 Clone 实现为一个深拷贝（deep copy），具有不同结构的电路就可以是原型了。</li></ul></li><li>减少子类的构造：Factory Method（3.3）经常产生一个与产品类层次平行的 Creator 类层次。Prototype 模式使得你克隆一个原型而不是请求一个工厂方法去产生一个新的对象，因此你根本不需要 Creator 类层次。<ul><li>主要适用于像 C++这样不将类作为一级类对象的语言（通常是<strong>静态语言</strong>）。这种语言中，类本身不是一种对象，而是一种特殊的数据类型或结构。这意味着，这种语言中，类不能被当作参数传递给函数，也不能被当作返回值返回，也不能被动态创建或销毁。例如，C++中的类只能在编译时静态定义，而不能在运行时动态生成或修改。</li><li>相反，将<strong>类作为一级类对象</strong>的语言（通常是<strong>动态语言</strong>），则<em>认为类本身也是一种对象</em>，只不过是用来创建其他对象的对象。这意味着，这种语言中，类可以被当作参数传递给函数，也可以被当作返回值返回，也可以被动态创建或销毁。例如，Python 就是一种将类作为一级类对象的语言，因为 Python 中的类是由 type 这个元类创建的对象，而且可以在运行时动态生成或修改2。</li></ul></li><li>用类动态配置应用一些运行时环境允许你动态地将类装载到应用中。<ul><li>一个希望创建动态载入类的实例的应用不能静态引用类的构造器，而应该由运行环境在载入时自动创建每个类的实例，并用原型管理器来注册这个实例。这样应用就可以向原型管理器请求新装载的类的实例，这些类原本并没有和程序相连接。</li></ul></li></ul><p><strong>缺陷</strong>：</p><ul><li>每个 Prototype 子类必须实现 clone 操作，而这可能非常困难</li></ul><h4 id=实现>实现
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0></a></h4><p>在像 C++这样的静态语言中，类不是对象，并且运行时只能得到很少或者得不到任何类型信息，所以 Prototype 特别有用。
相反，在类似 Python 这样的语言中意义不大，语言自带等价于原型的东西（类对象、元类等）</p></div><footer class=post-footer><div class=post-button><a class=btn href=/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.4-prototype-%E5%8E%9F%E5%9E%8B-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%96%B9%E6%B3%95/#more rel=contents>阅读全文 &#187;</a></div><div class=post-eof></div></footer></article></div><nav class=pagination><span class="page-number current">1</span>
<a class=page-number href=/post/page/2/>2</a>
<a class=page-number href=/post/page/3/>3</a>
<a class="extend next" rel=next href=/post/page/2/><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2024 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>CSMTC</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.145.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.7.2 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script class=next-config data-name=page type=application/json>{"comments":false,"expired":false,"isHome":false,"isPage":false,"math":{"js":{"file":"es5/tex-mml-svg.js","name":"mathjax","version":"3.2.2"},"render":"mathjax"},"path":"post","permalink":"//localhost:1313/post/","title":"Posts","toc":true,"waline":{"commentcnt":{"alias":"@waline/client","alias_name":"waline","file":"dist/comment.js","name":"comment","version":"2.15.8"}}}</script><script type=text/javascript src=//localhost:1313/js/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=//localhost:1313/js/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"//localhost:1313/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"isMultiLang":false,"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"slideInRight","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":true,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","share":{"addtoany":{"js":"https://static.addtoany.com/menu/page.js","locale":"zh-CN","num":8},"enable":false},"sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"//localhost:1313/js/3rd"}},"version":"4.7.2","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"2.15.8"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"2.15.8"}}}</script><script type=text/javascript src="/js/main.js?=1741723521" defer></script></body></html>