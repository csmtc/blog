<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>5.1-ChainOfResponsibility-职责链-行为型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.1-chainofresponsibility-%E8%81%8C%E8%B4%A3%E9%93%BE-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  目的使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。 对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
示例GUI 中的组件 Tips：用户界面对象中会有一个对象来处理帮助请求，至于是哪一个对象则取决于上下文以及可用的帮助具体到何种程度。
问题：提交帮助请求的对象（如按钮）并不明确知道谁是最终提供帮助的对象，需要有一种办法将提交帮助请求的对象与可能提供帮助信息的对象解耦（decouple） 职责链：将可选的处理对象排成一条链，链中对象收到请求的对象要么亲自处理它，要么转发给链中的下一个候选者。 要求：每个在链上的对象都有一致的处理请求和访问链上后继者的接口 按钮、对话框和应用类都使用 HelpHandler 操作来处理帮助请求。 HelpHandler 的 HandleHelp 操作默认是将请求转发给后继。 适用性有多个对象可以处理一个请求，哪个对象处理该请求运行时自动确定。 你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 可处理一个请求的对象集合应被动态指定。 结构Handler：定义处理请求的接口 可选：实现后继链（successor） ConcreteHandler：处理请求，访问后继对象 若能处理就处理，否则就将请求转发给后继 Client：向职责链上的 ConcreteHandler 提交请求 当客户提交一个请求时，请求沿链传递直至有一个 ConcreteHandler 对象负责处理它。 请求传递过程可能如下 优缺点降低耦合度：该模式使得一个对象无须知道是其他哪一个对象处理其请求。 接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构。 增强了给对象指派职责的灵活性：可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的那些职责。 不保证处理：既然一个请求没有明确的接收者，那么就不能保证它一定会被处理（可能一直到链尾都没有对象处理请求） 实现实现后继者链的方法使用已有的链接：例如，在一个部分–整体层次结构中，父构件引用可定义一个部件的后继者。窗口组件（widget）结构可能早已有这样的链接。 由 Handler 实现：如果没有已有的引用可定义一个链，则必须构建新的链。这种情况下 Handler 不仅定义该请求的接口，通常也维护后继者 表示请求请求是一个硬编码的（hard-coded）操作调用（如上述 HelpHandler） 使用一个处理函数，这个函数以一个请求码（如一个整型常数或一个字符串）为参数 无法用类型安全的方法来传递请求参数，因此它们必须被手工打包和解包。显然，相对于直接调用一个操作来说它不太安全。 解决上述参数传递问题：
使用独立的请求对象来封装请求参数 Request 可定义一个访问器（accessor）函数以返回该类的标识符（对于支持的语言，可使用运行时的类型信息） 子类可通过重定义 HandleRequest 扩展该分派函数。子类只处理它感兴趣的请求，其他的请求被转发给父类。 相关模式职责链常与 Composite（4.3）一起使用。这种情况下，一个构件的父构件可作为它的后继。
变种：规则树  </content></entry><entry><title>LeetCode刷题记录-贪心</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E9%A2%98%E7%9B%AE/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E8%B4%AA%E5%BF%83/</url><categories><category>算法与数据结构</category></categories><tags><tag><no value=/></tags><content type="html"><![CDATA[  55. 跳跃游戏给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。
核心策略：看覆盖范围，覆盖范围内⼀定是可以跳过来的，不⽤管是怎么跳的。问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点。
45. 跳跃游戏 II给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。
每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:
0 &lt;= j &lt;= nums[i] i + j &lt; n 返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例保证可以到达 nums[n - 1] 。
核心策略：同样看覆盖范围，当前下标达到了上次跳跃的最大位置，且未达到终点，则需要跳跃一次。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 if (nums.size() == 1) return 0; int max_pos = 0, last_max_pos = 0, cnt = 0, target = nums.size() - 1; for (int i = 0; i &lt;= target; ++i) { // 跳跃的情况：当前下标达到了上次跳跃的最大位置，且未达到终点，则需要跳跃一次 max_pos = max(max_pos, i + nums[i]); if (i == last_max_pos) { ++cnt; last_max_pos = max_pos; if (last_max_pos &gt;= target) break; } } 134. 加油站1 2 3 情况⼀：如果 gas 的总和⼩于 cost 总和，那么⽆论从哪⾥出发，⼀定是跑不了⼀圈的 情况⼆：rest[i] = gas[i]-cost[i]为⼀天剩下的油，i 从 0 开始计算累加到最后⼀站，如果累加没有出现负数，说明从 0 出发，油就没有断过，那么 0 就是起点。 情况三：如果累加的最⼩值是负数，汽⻋就要从⾮0 节点出发，从后向前，看哪个节点能把这个负数填平，能把这个负数填平的节点就是出发节点。 376. 摆动序列如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
思路 1：统计转折点个数，+1 即为摆动序列个数
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def wiggleMaxLength(self, nums: List[int]) -&gt; int: # 统计转折点个数即可 trend = 0 # 大于0增，小于0减 n = len(nums) cnt = 0 for i in range(1, n): diff = nums[i] - nums[i - 1] if diff &gt; 0 and (cnt == 0 or trend &lt; 0): cnt += 1 elif diff &lt; 0 and (cnt == 0 or trend &gt; 0): cnt += 1 elif diff == 0: continue trend = diff return cnt + 1 思路 2：动态规划 某个序列被称为「上升摆动序列」，当且仅当该序列是摆动序列，且最后一个元素呈上升趋势。如序列 [1,3,2,4] 即为「上升摆动序列」。 某个序列被称为「下降摆动序列」，当且仅当该序列是摆动序列，且最后一个元素呈下降趋势。如序列 [4,2,3,1] 即为「下降摆动序列」。
up[i] 表示以前 i 个元素中的某一个为结尾的最长的「上升摆动序列」的长度。up[i+1]=down[i]+1 down[i] 表示以前 i 个元素中的某一个为结尾的最长的「下降摆动序列」的长度。down[i+1]=up[i]+1
1 2 3 4 5 6 7 8 9 10 public int wiggleMaxLength(int[] nums) { int down = 1, up = 1; for (int i = 1; i &lt; nums.length; i++) { if (nums[i] &gt; nums[i - 1]) up = down + 1; else if (nums[i] &lt; nums[i - 1]) down = up + 1; } return nums.length == 0 ? 0 : Math.max(down, up); } 多维度问题135. 分发糖果其难点就在于贪⼼的策略，如果在考虑局部的时候想两边兼顾，就会顾此失彼。 那么本题我采⽤了两次贪⼼的策略：
⼀次是从左到右遍历，只⽐较右边孩⼦评分⽐左边⼤的情况。 ⼀次是从右到左遍历，只⽐较左边孩⼦评分⽐右边⼤的情况。 406. 根据身高重建队列#mark/leetcode
假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
目标：排序数组
思路：考虑多维度问题，首先确定一个维度。例如这里先确定身高维度（如身高降序），再考虑位序维度，将人插到合适的位置。
452. 用最少数量的箭引爆气球给定一些气球在 x 轴的投影范围，垂直 x 轴方向射箭，问击穿所有气球所需的最小箭的数量（若 x_start ≤ x ≤ x_end 该气球会被 引爆）。
思路：
将所有的投影区间按照左端点自小到大排序 当前交区间[L,R]，新区间[pL,pR]，两者存在交集的条件就是，R&gt;=pR 每多一个没有交集的区间，就要多一根箭 435. 无重叠区间给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回需要移除区间的最小数量，使剩余区间互不重叠。
策略：
将所有的区间按照左端点自小到大排序 当前的并区间(L,R)，新区间(pL,pR)，若存在重叠（即 pL&lt;R）,则需要移除 763. 划分字母区间给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。 注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。 返回一个表示每个字符串片段的长度的列表。 Example: 输入：s = &ldquo;ababcbacadefegdehijhklij&rdquo; 输出：[9,7,8] 解释：划分结果为 &ldquo;ababcbaca&rdquo;、&ldquo;defegde&rdquo;、&ldquo;hijhklij&rdquo; 。每个字母最多出现在一个片段中。像 &ldquo;ababcbacadefegde&rdquo;, &ldquo;hijhklij&rdquo; 这样的划分是错误的，因为划分的片段数较少。
策略：
统计字符串中每类字母出现的区间，将这些区间分为尽可能多的组，要求组和组之间不重叠 具体做法 将这些区间按照左端点递增排序 遍历区间，检查该区间和先前的区间是否重叠，若不重叠则意味着一个新的区间段可以执行一次划分 1 [0,8] [1,5] [4,7] / [9,14] [10,15] [11,11] [13,13] / [16,19] [17,22] [18,23] [20,20] [21,21] 738. 单调递增的数字#mark/leetcode 给定⼀个⾮负整数 N，找出⼩于或等于 N 的最⼤的整数，同时这个整数需要满⾜其各个位数上的数字是单调递增(eg.1234)。 当且仅当每个相邻位数上的数字 x 和 y 满⾜ x &lt;= y 时，我们称这个整数是单调递增的。
例如 98，一旦出现高位&gt;低位的情况，则需要将高位-1，并将高位以后的位均设置为 9，即 9-1,0=89
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int monotoneIncreasingDigits(int n) { string strNum = to_string(n); // flag⽤来标记赋值9从哪⾥开始 // 设置为这个默认值，为了防⽌第⼆个for循环在flag没有被赋值的情况下执⾏ int flag = strNum.size(); // 自低位向高位 for (int i = strNum.size() - 1; i &gt; 0; i--) { // 高位&gt;低位，需要舍入 if (strNum[i - 1] &gt; strNum[i]) { flag = i; strNum[i - 1]--; } } for (int i = flag; i &lt; strNum.size(); i++) { strNum[i] = &#39;9&#39;; } return stoi(strNum); } 968. 监控二叉树 - 力扣（LeetCode）给定一个二叉树，我们在树的节点上安装摄像头。 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。 计算监控树的所有节点所需的最小摄像头数量。
思路：从 NULL 结点往上，每隔 2 层安装一个摄像头 每个结点有 3 种情况：装了摄像头、被摄像头覆盖、未被摄像头覆盖
任何一个孩子没有摄像头都要安装摄像头 任何一个孩子有摄像头，则自身被摄像头覆盖 两个孩子都被信号覆盖，自身不被覆盖 最后，若根结点没有被覆盖，根结点再装一个摄像头   ]]></content></entry><entry><title>「HARD」4.6-Flyweight-享元-结构型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/hard4.6-flyweight-%E4%BA%AB%E5%85%83-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  用途运用共享技术支持大量细粒度的对象节约空间
示例面向对象中创建一个对象的开销是相对较大的，有时这是难以承受的。例如文本编辑器若将每个字符均采用一个相应的对象描述将产生巨大的内存负担
Flyweight 模式描述了如何共享对象，使得可以细粒度地使用它们而不需要高昂的代价
说明：flyweight 是一个共享对象，它可以同时在多个场景/上下文（context）中使用，并且在每个场景中 flyweight 都可以作为一个独立的对象 关于内部与外部状态： flyweight 存储独立于上下文的信息，在每个场景中使用 有关上下文的外部状态由用户在合适的时候提供 Flyweight 模式对那些通常由于数量太大而难以用对象来表示的概念或实体进行建模 例如文本编辑器中： 逻辑上每个字符对应一个对象 物理上每种字符共享同一个 Flyweight 对象（存储在 Flyweight 对象池），只存储字符编码，不存储相应的图元位置和字体等信息 行对象绘制字符对象时传递位置、字体等信息 适用性条件全部成立时使用：
一个应用程序使用了大量的对象，完全由于使用大量的对象造成很大的存储开销。 对象的大多数状态都可变为外部状态。 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。 应用程序不依赖于对象标识（共享对象 a equal b 会返回真值）。 结构FlyweightFactory：创建、管理、共享 Flyweight 对象。（采用懒加载创建） Flyweight（示例中的 Glyph）：描述接口，通过这个接口 flyweight 可以接受并作用于外部状态。 ConcreteFlyweight（示例中的 Character）：（该对象必须是可共享的）实现 Flyweight 接口，并为内部状态（如果有的话）分配存储空间。 UnsharedConcreteFlyweight（示例中的 Row、Column）：并非所有的 Flyweight 子类都需要被共享 Client 引用 Flyweight 计算/存储 Flyweight 的外部状态 用户不应直接对 ConcreteFlyweight 类进行实例化，而只能从 FlyweightFactory 对象得到 ConcreteFlyweight 对象，这可以保证对它们适当地进行共享。 优缺点增大时间开销：传输、查找和/或计算外部状态都会产生运行时开销 减少空间开销： 共享的 flyweight 越多，存储节约也就越多。 节约量随着共享状态的增多而增大。 当对象使用大量的内部及外部状态，并且外部状态是计算出来的而非存储的时候，节约量将达到最大。 Flyweight 模式经常和 Composite（4.3）模式结合起来表示一个层次式结构，这一层次式结构是一个共享叶结点的图。
由于共享，叶结点（Flyweight 对象）不能存储指向父结点的指针 实现删除外部状态该模式的可用性在很大程度上取决于是否容易识别外部状态并将它从共享对象中删除。
如果不同种类的外部状态和共享前对象的数目相同的话，删除外部状态不会降低存储消耗。 理想的状况是，外部状态可以由一个单独的对象结构计算得到，且该结构的存储要求非常小。 管理共享对象FlyweightFactory 对象经常使用关联存储帮助用户查找感兴趣的 flyweight 对象。 共享还意味着某种形式的引用计数和垃圾回收，这样当一个 flyweight 不再使用时，可以回收它的存储空间。 当 flyweight 的数目固定而且很小的时候（例如，用于 ACSII 码的 flyweight），这两种操作都不必要。在这种情况下，flyweight 完全可以永久保存。 相关模式Flyweight 模式通常和 Composite（4.3）模式结合起来，用共享叶结点的有向无环图实现一个逻辑上的层次结构。 通常，最好用 flyweight 实现 State（5.8）和 Strategy（5.9）对象。   </content></entry><entry><title>「HARD」5.3-Interpreter-解释器-行为型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/hard5.3-interpreter-%E8%A7%A3%E9%87%8A%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html"><![CDATA[  目的给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
示例考虑解析简单的正则表达式，包含如下文法：
expression ::= literal | alternation | sequence | repretition | &rsquo; (&rsquo; expression &lsquo;)&rsquo; alternation ::= expression &lsquo;|&rsquo; expression sequence ::= expression &lsquo;&amp;&rsquo; expression repetition ::= expression &lsquo;*&rsquo; literal ::= &lsquo;a&rsquo; | &lsquo;b&rsquo; | &lsquo;c&rsquo;&hellip; ( &lsquo;a&rsquo; | &lsquo;b&rsquo; | &lsquo;c&rsquo;&hellip;)* 使用类去描述上述文法： 每个用这个文法定义的正则表达式都被表示为一个由这些类的实例构成的抽象语法树 AST 如果我们为 RegularExpression 的每一子类都定义解释（Interpret） 操作，那么就得到了这些正则表达式的一个解释器。 适用性当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。
最好具备以下特性：
文法简单。对于复杂的文法，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无须构建抽象语法树即可解释表达式，这样可以节省空间而且还可能节省时间。 不太在意效率。最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下，转换器也可用解释器模式实现，该模式仍是有用的。 结构AbstractExpression：定义抽象的解释操作 TerminalExpression：（终结符表达式，如 LiteralExpression） 定义终结符的解释操作 终结符：指的是文法中的运算单元，也就是不可再分的最小元素。 文法中的每一个终结符都有一个具体终结表达式与之相对应。 NonterminalExpression（非终结符表达式，如 AlternationExpression、Repetition-Expression、SequenceExpressions）： 文法中的每一条规则 R::=R1 R2…Rn 都需要一个 NonterminalExpression 类 为从 R1 到 Rn 的每个符号都维护一个 AbstractExpression 类型的实例变量。 Context（上下文）：解释器之外的全局信息 Client（客户）：构建（或被给定）表示该文法定义的语言中一个特定的句子的抽象语法树。 最后调用解释操作 工作流程：Client 构建（或被给定）一个句子，它是 NonterminalExpression 和 TerminalExpression 的实例的一个抽象语法树。然后初始化上下文并调用解释操作。
说明：每一结点的解释操作用上下文来存储和访问解释器的状态。
优缺点易于修改、扩展文法：因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。 已有的表达式可被增量式地改变 新的表达式可定义为旧表达式的变体。 易于实现文法：定义抽象语法树中各个结点的类的实现大体类似。 这些类易于直接编写，通常它们也可用一个编译器或语法分析程序生成器自动生成。 复杂的文法难以维护： 解释器模式为文法中的每一条规则至少定义了一个类，文法过多时难以管理和维护 文法非常复杂时，建议使用语法分析器或者编译器 易于增加解释表达式的方式：解释器模式使得实现新表达式“计算”变得容易。 例如，你可以在表达式类上定义一个新的操作以支持优美打印或表达式的类型检查。 如果你经常创建新的解释表达式的方式，那么可以考虑使用 Visitor（5.11）模式以避免修改这些代表文法的类。 实现创建抽象语法树：解释器模式不涉及语法分析，AST 可以使用表示驱动的语法分析程序生成，也可以直接由用户提供 定义解释操作：并不一定要在表达式类中定义解释操作 如果经常要创建一种新的解释器，那么使用 Visitor（5.11）模式将解释放入一个独立的“访问者”对象更好一些 例如，一个程序设计语言会有许多在抽象语法树上的操作，比如类型检查、优化、代码生成，等等。恰当的做法是使用一个访问者以避免在每一个类上都定义这些操作。 与 Flyweight 模式共享终结符：一些文法中，一个句子可能多次出现同一个终结符。此时最好共享那个符号的单个拷贝 例如计算机程序的文法，每个程序变量在整个代码中将会出现多次。 为何适用 Flyweight 模式：终结结点通常不存储关于它们在抽象语法树中位置的信息。在解释过程中，任何它们所需要的上下文信息都由父结点传递给它们 相关模式Composite（4.3）：抽象语法树是一个组合模式的实例。 Flyweight（4.6）：说明了如何在抽象语法树中共享终结符。 Iterator（5.4）：解释器可用一个迭代器遍历该结构。 Visitor（5.11）：可用来在一个类中维护抽象语法树中各结点的行为。
  ]]></content></entry><entry><title>1-设计模式概论</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%AE%BA/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  定义和组成要素什么是模式：每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。
模式的组成要素：
模式名 问题：何时使用该模式 解决方案：描述设计的组成成分、相互关系和协作方式 影响：描述模式应当权衡的问题，对系统的灵活性、扩充性或可移植性的影响。如时空复杂度、语言和实现 由 MVC, Model-View-Controller 理解“模式”：
什么是 MVC： 模型：应用对象 视图：对象在屏幕上的显示 控制器：定义用户界面对用户输入的响应方式 MVC 通过建立订阅-通知协议来分离视图和模型。一旦模型的数据发生变化，模型将通知有关的视图，每个视图相应地得到刷新自己的机会。允许为一个模型提供不同的多个视图表现形式 推广 1：模型和视图分离→订阅对象和发布对象分离 将对象分离，使得一个对象的改变能够影响另一些对象，而这个对象并不需要知道那些被影响的对象的细节。这个更一般的设计被描述成 Observer 推广 2：MVC 允许视图嵌套，将组合 View 与单个 View 平等对待→将对象组视为一般对象 将一些对象划为一组，并将该组对象当作一个对象来使用。这个设计被描述为 Composite 设计模式的组成要素：
模式名、别名和分类 意图：解决什么问题 动机：说明一个设计问题以及如何用模式中的类、对象来解决该问题的特定情景 适用性 结构：类图和交互图（描述对象之间的请求序列和协作关系） 参与者：涉及的类和/或对象以及它们各自的职责。 协作：模式的参与者怎样协作以实现它们的职责。 影响 实现：实现时的注意事项 实际应用案例 相关模式 设计模式目录创建型模式与对象的创建有关；
结构型模式处理类或对象的组合；
行为型模式对类或对象怎样交互和怎样分配职责进行描述。
类模式：处理类和子类的关系
对象模式：处理对象间的关系
设计模式中可变的部分： Abstract Factory（3.1）：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。 Adapter（4.1）：将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 Bridge（4.2）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 Builder（3.2）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 Chain of Responsibility（5.1）：解除请求的发送者和接收者之间的耦合，使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。Command（5.2）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 Composite（4.3）：将对象组合成树形结构以表示“部分–整体”的层次结构。Composite 使得客户对单个对象和组合对象的使用具有一致性。 Decorator（4.4）：动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator 模式比生成子类方式更为灵活。 Facade（4.5）：为子系统中的一组接口提供一个一致的界面， Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 Factory Method（3.3）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method 使一个类的实例化延迟到其子类。 Flyweight（4.6）：运用共享技术有效地支持大量细粒度的对象。 Interpreter（5.3）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。Iterator（5.4）：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。 Mediator（5.5）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 Memento（5.6）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。 Observer（5.7）：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。 Prototype（3.4）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 Proxy（4.7）：为其他对象提供一个代理以控制对这个对象的访问。 Singleton（3.5）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。State（5.8）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。 Strategy（5.9）：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。 Template Method（5.10）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。 Visitor（5.11）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 面向对象设计的步骤设计原则对接口编程，而不是对实现编程。这可以极大地减少子系统实现之间的相互依赖关系：
客户无须知道他们使用对象的特定类型，只需要知道对象有客户所期望的接口。 客户无须知道他们使用的对象是用什么类来实现的，只需要知道定义接口的抽象类。 优先使用对象组合，而不是类继承：对象组合耦合度低，不破坏封装性
设计步骤与基本概念选择合适对象： 对象在收到客户请求后执行相应动作 对象的内部状态是被封装的。客户请求是使对象执行操作的唯一方法，操作又是对象改变内部数据的唯一方法。 决定对象的粒度 指定对象的接口： 操作的型构 (signature)：操作名、作为参数的对象和返回值 3 者唯一确定一个操作 接口 (interface)：对象操作所定义的所有操作型构的集合被称为该对象的~ 类型 type：即接口名。如果一个对象接受“Window”接口所定义的所有操作请求，那么我们就说该对象具有“Window”类型。 对象和类型是多对多的关系 子类型和超类型：当一个类型的接口包含另一个类型的接口时，我们就说它是另一个类型的子类型（subtype），而称另一个类型为它的超类型（supertype）。我们常说子类型继承了它的超类型的接口。 动态绑定（dynamic binding）：发送给对象的请求和它的相应操作在运行时的连接就称为动态绑定 多态（polymorphism）：动态绑定允许你在运行时彼此替换有相同接口的对象。这种可替换性就称为多态 比较类（class）与类型（type）对象的类定义了对象是怎样实现的，同时也定义了对象的内部状态和操作的实现。 对象的类型只与它的接口有关，接口即对象能响应的请求的集合。 class 是 type 的超集，class=type+内部状态和实现
类继承和接口继承
类继承根据一个对象的实现定义了另一个对象的实现。简而言之，它是代码和表示的共享机制。 接口继承（或子类型化）描述了一个对象什么时候能被用来替代另一个对象。 类和对象关系图类：类名、类方法、类变量实例化 ：用虚箭头从类指向实例由类 A 创建类 B 继承：三角箭头从子类指向父类 抽象类（abstract class）的主要目的是为它的子类定义公共接口。抽象类将把它的部分或全部操作的实现延迟到子类中，不能被实例化。
在抽象类中定义却没有实现的操作被称为抽象操作 （abstract operation） 抽象类的类名以斜体表示，以与具体类相区别。抽象操作也用斜体表示。 重载 override：子类能够改进和重新定义它们父类的操作 混入类（mixin class）是给其他类提供可选择的接口或功能的类。它与抽象类一样不能实例化。混入类要求多继承 聚合尾部菱形箭头、相识普通箭头聚合：尾部菱形箭头：称一个对象包含另一个对象或者是另一个对象的一部分。聚合意味着聚合对象和其所有者具有相同的生命周期。 相识、关联、引用：普通箭头：相识意味着一个对象仅仅知道另一个对象。相识的对象可能请求彼此的操作，但是它们不为对方负责。 伪代码实现：虚线引出3 种复用方式类继承、对象组合、参数化类型
类继承和对象组合类继承和对象组合：这是面向对象系统中最常用的功能复用技术
类继承：又称白箱复用（white-box reuse）：在继承方式中，父类的内部细节对子类可见。 优点：编译时静态定义且可以直接使用；程序设计语言直接支持类继承；易于改变实现； 缺点：无法在运行时改变从父类继承的实现；父子类依赖紧密（继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。） 对象组合：又称黑箱复用（black-box reuse）：新的更复杂的功能可以通过组装或组合对象来获得。 优点：依赖少，耦合度低；只通过接口访问不影响封装性 不应为获得复用而去创建新的构件，应该只使用对象组合技术，通过组装已有的构件就能获得你需要的功能。 委托（Sp 对象组合）委托 delegation：一种组合方法，它使组合具有与继承同样的复用能力
工作模式： 有两个对象参与处理一个请求，接受请求的对象将操作委托给它的代理者 delegate（类似于子类将请求交给它的父类处理） 接受请求的对象将自己传给被委托者（代理者），使被委托的操作可以引用接受请求的对象。 优点：便于运行时组合对象操作以及改变这些操作的组合方式。 缺点：动态的、高度参数化的软件比静态软件更难于理解；运行相对低效 Eg：Window 无需继承 Rectangle 而能够使用后者的功能 参数化类型参数化类型即 C++中的模板 template：允许你在定义一个类型时不用指定该类型所用到的其他所有类型。未经指定的类型在使用时以参数形式提供。 参数化类型在不执行编译时类型检查的语言中式完全不必要的
例如实现一个以元素比较操作为可变元的排序例程：
通过子类实现该操作（Template Method（5.10）的一个应用）。 实现要传给排序例程的对象的职责（Strategy（5.9））。 提供作为 C++模板的参数，以指定元素比较操作的名称 3 者比较： 对象组合技术允许你在运行时改变被组合的行为，但是它存在间接性，比较低效。 继承允许你提供操作的默认实现，并通过子类重定义这些操作。 参数化类型允许你改变类所用到的类型。但是继承和参数化类型都不能在运行时改变。 失败的设计必须考虑系统在它的生命周期内会发生怎样的变化：例如类的重新定义和实现，修改客户和重新测试
导致重新设计的一般原因和解决问题的相关设计模式：
通过显式地指定一个类来创建对象 危害：受特定实现的约束而不是特定接口的约束 方法：应该间接地创建对象 模式：Abstract Factory（3.1），Factory Method（3.3）， Prototype（3.4） 对特殊操作的依赖 危害：完成该请求的方式就固定下来了 方法：在编译时或运行时很方便地改变响应请求的方法 模式：Chain of Resposibility（5.1），Command（5.2） 对软硬件平台的依赖： 模式：Abstract Factory（3.1），Bridge（4.2） 对对象实现的依赖： 危害：知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化 方法：对客户隐藏这些信息能阻止连锁变化 模式：Abstract Factory（3.1），Bridge（4.2）， Memento（5.6），Proxy（4.7） 算法依赖： 危害：算法在开发和复用时常常被扩展、优化和替代。 方法：有可能发生变化的算法应该被孤立起来 模式：Builder（3.2），Iterator（5.4），Strategy（5.9）， Template Method（5.10），Visitor（5.11） 紧耦合： 危害：紧耦合的类很难独立地被复用 方法：设计模式使用抽象耦合和分层技术来提高系统的松散耦合性。 模式：Abstract Factory（3.1），Command（5.2）， Facade（4.5），Mediator（5.5），Observer（5.7），Chain of Responsibility（5.1） 通过生成子类来扩充功能 危害：每一个新类都有固定的实现开销（初始化、终止处理等）。定义子类还需要对父类有深入的了解。 方法：多用对象组合 模式：Bridge（4.2），Chain of Responsibility（5.1）， Composite（4.3），Decorator（4.4），Observer（5.7），Strategy（5.9） 不能方便地对类进行修改（例如你需要源代码而又没有，或者可能对类的任何改变会要求修改许多已存在的其他子类） 模式：Adapter（4.1），Decorator（4.4），Visitor（5.11） 设计模式在软件开发中的作用应用程序：内部复用性、可维护性和可扩充性是要优先考虑的。
内部复用性确保你不会做多余的设计和实现。设计模式通过减少依赖性来提高内部复用性。 当设计模式被用来对系统分层和限制对平台的依赖性时，它们还会使一个应用更具可维护性。 如果一个类不过多地依赖其他类，扩充这个孤立的类还是很容易的。 工具箱：工具箱是一组相关的、可复用的类的集合，这些类提供了通用的功能。
避免假设和依赖就变得很重要，否则会限制工具箱的灵活性，进而影响它的适用性和效率 框架：框架规定了你的应用的体系结构。它定义了整体结构，类和对象的划分，各部分的主要责任，类和对象怎么协作，以及控制流程。
框架更强调设计复用，尽管框架常包括具体的立即可用的子类。 当使用工具箱（或传统的子程序库）时需要写应用软件的主体并且调用你想复用的代码。 使用框架时，你应该复用应用的主体，写主体调用的代码。 如果说应用程序难以设计，那么工具箱就更难了，而框架则是最难的。
当框架演化时，应用不得不随之演化。这使得松散耦合更加重要，否则框架的一个细微变化都将引起强烈反应。设计的框架必须尽可能地灵活、可扩充，并避免对已有内容的实质性修改。   </content></entry><entry><title>3-创建型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html"><![CDATA[  创建型模式创建型设计模式抽象了实例化过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。
主要特征：
第一，它们都将关于该系统使用哪些具体的类的信息封装起来。 第二，它们隐藏了这些类的实例是如何被创建和放在一起的。 常用的对象创建型模式有：
抽象工厂 Abstract Factory：3.1-AbstractFactory「Kit」-抽象工厂-创建型模式生成器 Builder 工厂方法 Factory Method 原型 Prototype 单例模式 Singleton 背景游戏中的功能类以一个地牢探索游戏创建房间为例，讨论 5 种模式。涉及的主要类有：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 房间的方向，北南东西 enum Direction {N,S,E,W}; // 创建迷宫的类 class MazeGame{ public: Maze* CreateMaze(); } // 地图点的抽象类，有Room，Wall，Door3个子类 class MapSite{ public: virtual void Enter() = 0; // 进入该地点 } // 墙 class Wall:public MapSite{ public: virtual void Enter(); } // 门 class Door:public MapSite{ public: Door(Room*=0,Room*=0); Room* OtherSideFrom(Room*); virtual void Enter(); private: Room *_room1,*_room2; bool _isOpen; } // 房间 class Room:public MapSite{ public: Room(int roomNo); MapSite *GetSide(Direction) const; virtual void Enter(); private: MapSite *_sides[4]; // 东西南北的地图点 int _roomNumber; // 房间编号 } 各类创建方法比较1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 硬编码 Maze* MazeGame::CreateMaze(){ Maze* aMazenew Maze; Room* r1 = new Room(1); Room* r2 new Room(2); Door* theDoor = new Door(rl, r2); aMaze-&gt;AddRoom (r1); aMaze-&gt;AddRoom (r2); r1-&gt;SetSide (North, new Wall); rl—&gt;SetSide（East.theDoor）； rl-&gt;SetSide (South, new Wall); rl-&gt;SetSide (West, new Wall); r2-&gt;SetSide (North, new Wal1); r2-&gt;SetSide (East, new Wall): r2-&gt;SetSide(South, new Wall); r2-&gt;SetSide (West, theDoor) return aMaze; } 硬编码方式的主要缺点是不灵活，修改迷宫的布局意味着修改这个实例方法，这容易产生错误也不易于复用 Factory Method：CreateMaze 调用虚函数而不是构造器来创建它需要的房间、墙壁和门，那么你可以创建一个 MazeGame 的子类并重定义这些虚函数，从而改变被实例化的类。 Abstract Factory：传递一个对象给 CreateMaze 作为参数来创建房间、墙壁和门，那么你可以传递不同的参数来改变房间、墙壁和门的类 Builder：传递一个对象给 CreateMaze，这个对象可以在它所建造的迷宫中使用增加房间、墙壁和门的操作来全面创建一个新的迷宫，那么你可以使用继承来改变迷宫的一些部分或迷宫的建造方式。 Prototype：CreateMaze 由多种原型的房间、墙壁和门对象参数化，它复制并将这些对象增加到迷宫中，那么你可以用不同的对象替换这些原型对象以改变迷宫的构成。 Singleton：可以保证每个游戏中仅有一个迷宫而且所有的游戏对象都可以迅速访问它——不需要求助于全局变 量或函数。Singleton 也使得迷宫易于扩展或替换，且不需要变动已有的代码。 讨论对系统进行参数化主要有 2 种方法：
生成创建对象的类的子类，这对应于使用 Factory Method：缺点是，仅为了改变产品类，就可能需要创建一个新的子类 定义一个对象负责明确产品对象的类，并将它作为该系统的参数：对应 Abstract Factory（3.1）、Builder（3.2）和 Prototype（3.4）。这三个模式都涉及创建一个新的负责创建产品对象的“工厂对象” Abstract Factory 由这个工厂对象产生多个类的对象 Builder 使用一个相对复杂的协议，由这个工厂对象逐步创建一个复杂产品 Prototype 由该工厂对象通过拷贝原型对象来创建产品对象 通常，设计以使用 Factory Method 开始，并且当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。
Abstract Factory、Prototype 或 Builder 的设计通常比使用 Factory Method 的设计更灵活，但它们也更加复杂   ]]></content></entry><entry><title>3.1-AbstractFactory「Kit」-抽象工厂-创建型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.1-abstractfactorykit-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  又称 Kit
Abstract Factory 抽象工厂用途用途：提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。
示例示例： GUI 程序需要支持 Motif 和 PW 这 2 种视窗标准：
抽象工厂提供 CreateXXX 接口生产抽象组件 XXX，用户调用该函数获取 XXX 组件 抽象工厂的具象工厂子类实现 CreateXXX 接口，生产自己这种类型的具象组件 YYXXX（YYWindow，YYScrollBar,&amp;hellip;） 客户仅与抽象类定义的接口交互，而不使用特定的具体类的接口 结构AbstractFactory：声明一个创建抽象产品对象的接口 ConcreteFactory：实现创建具体产品对象的操作 AbstractProduct：为一类产品对象声明一个接口 ConcreteProduct：定义具体的产品对象，实现 AbstractProduct 接口 Client：只使用 Abstract 的接口 协作过程：
通常在运行时创建一个 ConcreteFactroy 类的实例。这一具体的工厂创建具有特定实现的产品对象。为创建不同的产品对象，客户应使用不同的具体工厂。 说明：简单实现时，AbstractFactory 和 ConcreteFactory 可以合二为一 AbstractFactory 将产品对象的创建延迟到它的 ConcreteFactory 子类。 适用条件系统独立于产品的创建、组合和表示 系统包含多个产品系列，用其中的一种进行表示 强调一个系列的产品设计，以便联合使用 提供产品类库，但是只显示接口而隐藏实现 优缺点优点： 分离实现：工厂封装了创建产品对象的责任和过程，将客户和具体实现分离。客户只操作抽象接口，避免硬编码具体的类名 易于切换产品系列 有利于产品风格的一致性：应用一次只能使用同一个系列中的对象，这有利于维护一致性 缺点： 难以支持新种类的产品：AbstractFactory 定义了可被其创建的产品集合，创建新产品意味着需要扩展 AbstractFactory 和其所有子类的接口。 实现的注意事项工厂使用单例模式：一个应用通常每个产品系列只需要一个 ConcreteFactory 实例 创建产品的方法： 常用方法：为每个产品定义一个工厂方法，具体的工厂为每个工厂重载该工厂方法以指定产品 简化具体工厂类：可以使用 Prototype 模式实现具体工厂。具体工厂使用产品系列中每一个产品的原型实例来初始化，且它通过复制它的原型来创建新的产品。基于原型的方法使得并非每个新的产品系列都需要一个新的具体工厂类。 可扩展的工厂： 通常增加一种新的产品要求改变 AbstractFactory 的接口以及所有与它相关的类。 一个更灵活但不太安全的设计是给创建对象的操作增加一个参数（例如类标识符，字符串，整数索引等）该参数指定了将被创建的对象的种类。使用这种方法 AbstractFactory 只需要一个“Make”操作和一个指示要创建对象的种类的参数。 客户需要使用执行向下类型转换（downcast，例如 cpp 中的 dynamic_cast）才能获得具体的子类型，而这会带来安全隐患   </content></entry><entry><title>3.2-Builder-生成器模式-创建型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.2-builder-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  Builder用途将复杂对象的构建和表示分离，使得同样的构建过程可以创建不同的表示。
示例考虑应用场景：将 RTF 文档转换为其他多种文本格式，对于任意结构的文档，可能的转换数目是无限的
RTFReader：分析文档，每次遇到一个标记时发送请求调用 TextConverter 转换该标记。
TextConverter 对象负责进行数据转换以及用特定格式表示该标记，其子类对不同转换和不同格式进行特殊处理。
解释：Builder 模式描述了所有这些关系。
每一个转换器类在该模式中被称为生成器（builder），而阅读器则称为导向器（director） Builder 模式将分析文本格式的算法（即 RTF 文档的语法分析程序）与描述怎样创建和表示一个转换后格式的算法分离开来。这使我们可以复用 RTFReader 的语法分析算法，根据 RTF 文档创建不同的文本表示——仅需使用不同的 TextConverter 的子类配置该 RTFReader 即可。 适用情形当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。 当构造过程必须允许被构造的对象有不同的表示时。 结构Builder：创建 Product 的抽象接口 ConcreteBuilder：（ASCIIConverter、TeXConverter、 TextWidgetConverter） 构造和装配产品的各个部件 定义和跟踪自己创建的表示 提供检索产品的接口（例如，GetASCIIText 和 GetTextWidget） Director：（RTFReader）构造使用 builder 接口的对象 Product（ASCIIText、TeXText、TextWidget） 被构建的复杂对象，具体生成器创建该产品的内部表示并定义装配过程 包含定义组件部件的类，以及将这些部件装配成最终产品的接口 协作过程如下：
客户创建 Director 对象，并用它所想要的 Builder 对象进行配置。 一旦生成了产品部件，导向器就会通知生成器。 生成器处理导向器的请求，并将部件添加到该产品中。 客户从生成器中获取最终产品。 优缺点可以改变一个产品的内部表示：因为产品是通过抽象接口构造的，你在改变该产品的内部表示时所要做的只是定义一个新的生成器。 将构造代码和表示代码分开：Builder 模式通过封装一个复杂对象的创建和表示方式提高了对象的模块性。构造代码只写一次，不同的 Director 可以反复复用构造代码在同一套部件集合上创建不同的表示 可以精细控制构造过程：它是在导向器的控制下一步一步构造产品的。仅当该产品完成时导向器才从生成器中取回它。 实现通常有一个抽象的 Builder 类为导向器可能要求创建的每一个构件定义一个操作（默认什么都不做）。 一个 ConcreteBuilder 类对它有兴趣创建的构件重定义这些操作。
注意事项：
关于装配和构造接口： Builder 类接口必须足够普遍，以便为各种类型的具体生成器构造产品。 有时需要访问已构造的部件：例如语法分析树自下而上构建，此时需要由生成器将子结点（已生成的产品）返回导向器，导向器将其回传给生成器构建父结点 Builder 中使用空方法而非纯虚函数：这使得子类只需要重定义他们感兴趣的操作 产品没有抽象基类：具体生成器生产的产品的差异通常很大，例如 ASCIIText 和 TextWidget 两者不太可能有公共接口 迷宫案例MazeBuilder（抽象 Builder）：提供 BuildRoom，BuildDoor、BuildMaze 方法，和最终返回 Maze 的 GetMaze 方法
StandardMazeBuilder（具象 Builder）：实现上述的具体方法 MazeGame（Director）：调用 MazeBuilder 中的方法，具体生成迷宫   </content></entry><entry><title>3.3-FactoryMethod-工厂方法-创建型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.3-factorymethod-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  又称虚构造器（virtual constructor）
用途定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method 使一个类的实例化延迟到其子类。
示例框架用抽象类定义和维护对象之间的关系。 Eg：框架定义了 App 抽象类，它包含一个 Document 抽象内容。但是 App 类无法确认应当实例化哪个 Document 的具象子类：
方法： 抽象类 App 中提供接口 CreateDocument。 具象 App 子类重载接口 CreateDocument，并创建自己要用到具象的 Document 结构Product：定义工厂方法要创建的对象的类别 ConcreteProduct： Creator：抽象工厂，定义用于返回 Product 的工厂方法（接口），该接口可以是抽象的，也可以提供一个默认实现返回缺省的 ConcreteProduct ConcreteCreator：具象工厂，重载工厂接口 说明：
Creator 依赖子类重载工厂方法以返回合适的 ConcreteProduct 适用性一个类不确定自己要创建的对象的类 一个类希望由子类指定自己创建的对象的类 优缺点工厂方法的潜在缺点：客户可能只是为了创建一个特定的 ConcreteProduct 对象，就必须创建 Creator 的新的子类
优点：
工厂方法不再将应用相关的类绑定到程序代码中。代码只处理 Product 接口 可以为子类提供钩子 Hook（提供合理的缺省实现） 可以连接平行的类层次：例如图形类和用户的操作是平行的类层次，而抽象父类 Figure 可以提供 CreateManipulator 方法连接 Manipulate 类层次，并为子类提供默认实现 实现Creator 可以是抽象类，也可以是提供了缺省实现的具象类 抽象类不提供默认实现，可以避免不得不实例化不可预见类的问题 具象类：这种情况比直接 new 个实例具有更好的灵活性 参数化工厂方法：这允许工厂方法创建多种类型的对象。工厂方法可以采用一个标识（指定要被创建的对象种类的参数）区分不同类型的对象（这些对象都必须是 Product 的子类型） 重定义一个参数化的工厂方法使你可以简单而有选择性地扩展或改变一个 Creator 生产的产品。注意最后需要调用父类的 Create 命名约定：使用命名约定是一个好习惯，它可以清楚地说明你正在使用工厂方法 Cpp 中的工厂方法：
cpp 中工厂方法通常是虚函数，且常常是纯虚函数。因而在 Creator 的构造器中不要调用工厂方法——在 ConcreteCreator 中该工厂方法还不可用。 正确的方法：懒初始化：构造器中只是简单地将_product 初始化为 0，具体产品的初始化方法放在 getProduct 中进行（若产品存在则返回产品，产品不存在则创建），示例代码如下 利用模板避免创建子类：工厂方法另一个潜在的问题是它们可能仅为了创建适当的 Product 对象而迫使你创建 Creator 子类。 在 C++中另一个解决方法是提供 Creator 的一个模板子类，它使用 Product 类作为模板参数： 相关模式抽象工厂 VS 工厂模式不同点： 抽象工厂是针对多个产品族而言的，即每个工厂可以创建多种不同类型的产品。例如，一个奔驰工厂可以创建奔驰轿车、奔驰 SUV、奔驰 MPV 等。
抽象工厂需要为每个产品的创建提供一个接口；或者需要提供一个创建多种产品的接口。 工厂方法是针对一个产品等级而言的，即每个工厂只负责创建一种类型的产品。例如，一个轿车工厂只能创建轿车，不能创建 SUV 或 MPV。 工厂方法只需要实现一个接口，该接口只包含了创建一个产品的方法。 共同点： 抽象工厂和工厂方法都是将对象的创建延迟到其子类实现
其他相关模式Abstract Factory（3.1）经常用工厂方法来实现。Abstract Factory 模式中动机一节的例子也对 Factory Method 进行了说明。 工厂方法通常在 Template Method（5.10）中被调用。在上面的文档例子中，NewDocument 就是一个模板方法。 Prototype（3.4）不需要创建 Creator 的子类。但是，它们通常要求一个针对 Product 类的 Initialize 操作。Creator 使用 Initialize 来初始化对象，而 Factory Method 不需要这样的操作。
  </content></entry><entry><title>3.4-Prototype-原型-创建型方法</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.4-prototype-%E5%8E%9F%E5%9E%8B-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%96%B9%E6%B3%95/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  用途用原型指定创建对象的种类，拷贝这些原型创建新的对象
示例例如采用工具类操作图形元素：
若为每个图形元素创建相应工具类，则过于冗杂 采用原型方法： 工具类拷贝一个图形元素的实例，添加到文档中 适用情形当一个系统应该独立于它的产品创建、构成和表示时。 当要实例化的类是在运行时指定时，例如，通过动态装载。 为了避免创建一个与产品类层次平行的工厂类层次时。 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 结构Prototype：提供 clone 自身的接口 ConcretePrototype：实现 clone 的操作 Client：用原型 clone 自身从而创建新的对象 优缺点Prototype 有许多与 Abstract Factory（3.1）和 Builder（3.2）一样的效果：
它对客户隐藏了具体的产品类，因此减少了客户知道的名字的数目。 此外，这些模式使客户无须改变自身代码即可使用与特定应用相关的类。 其他优点：
运行时增加和删除产品 改变值以指定新对象：高度动态的系统允许你通过对象组合定义新的行为——例如，通过为一个对象变量指定值——并且不定义新的类。 克隆一个原型类似于实例化一个类。Prototype 模式可以极大地减少系统所需要的类的数目。 改变结构以指定新对象许多应用由部件和子部件来创建对象。 例如电路设计编辑器就是由子电路来构造电路的：这样的应用通常允许你实例化复杂的、用户定义的结构，比方说，一次又一次地重复使用一个特定的子电路。 Prototype 模式只要组合电路对象将 Clone 实现为一个深拷贝（deep copy），具有不同结构的电路就可以是原型了。 减少子类的构造：Factory Method（3.3）经常产生一个与产品类层次平行的 Creator 类层次。Prototype 模式使得你克隆一个原型而不是请求一个工厂方法去产生一个新的对象，因此你根本不需要 Creator 类层次。 主要适用于像 C++这样不将类作为一级类对象的语言（通常是静态语言）。这种语言中，类本身不是一种对象，而是一种特殊的数据类型或结构。这意味着，这种语言中，类不能被当作参数传递给函数，也不能被当作返回值返回，也不能被动态创建或销毁。例如，C++中的类只能在编译时静态定义，而不能在运行时动态生成或修改。 相反，将类作为一级类对象的语言（通常是动态语言），则认为类本身也是一种对象，只不过是用来创建其他对象的对象。这意味着，这种语言中，类可以被当作参数传递给函数，也可以被当作返回值返回，也可以被动态创建或销毁。例如，Python 就是一种将类作为一级类对象的语言，因为 Python 中的类是由 type 这个元类创建的对象，而且可以在运行时动态生成或修改2。 用类动态配置应用一些运行时环境允许你动态地将类装载到应用中。 一个希望创建动态载入类的实例的应用不能静态引用类的构造器，而应该由运行环境在载入时自动创建每个类的实例，并用原型管理器来注册这个实例。这样应用就可以向原型管理器请求新装载的类的实例，这些类原本并没有和程序相连接。 缺陷：
每个 Prototype 子类必须实现 clone 操作，而这可能非常困难 实现在像 C++这样的静态语言中，类不是对象，并且运行时只能得到很少或者得不到任何类型信息，所以 Prototype 特别有用。 相反，在类似 Python 这样的语言中意义不大，语言自带等价于原型的东西（类对象、元类等）
具体实现有以下要点：
实现原型管理器：当一个系统中原型数目不固定时（也就是说，它们可以动态创建和销毁），要保持一个可用原型的注册表，以便用户存储和检索原型。 原型管理器根据关键字返回相匹配的原型（即，~是一种关联存储器） 实现对象克隆操作：这是最困难的环节（当对象结构包含循环引用时，这尤为棘手）: 深浅拷贝： 深拷贝：克隆一个对象是依次克隆它的实例变量 浅拷贝：由克隆对象和原对象共享这些变量（拷贝的对象和原来的对象之间是共享指针） 大多数语言都对克隆对象提供了一些支持（例如 C++提供了一个拷贝构造器），这通常是浅拷贝 克隆一个结构复杂的原型通常需要深拷贝，因为复制对象和原对象必须相互独立。 初始化克隆对象：使用初始化参数并据此设定克隆对象的内部状态 注意深拷贝 Clone 操作——一些副本在你重新初始化它们之前可能必须要删除掉 相关模式Prototype 和 Abstract Factory（3.1）模式在某些方面是相互竞争的。
但是它们也可以一起使用：Abstract Factory 可以存储一个被克隆的原型的集合，并且返回产品对象。 大量使用 Composite（4.3）和 Decorator（4.4）模式的设计通常也可从 Prototype 模式获益。   </content></entry><entry><title>3.5-Singleton-单例模式-对象创建模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.5-singleton-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  用途保证一个类仅有一个实例，并提供一个访问它的全局访问点。
示例让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求），并且它可以提供一个访问该实例的方法。
适用性唯一实例应该是通过子类化可扩展的，并且客户应该无须更改代码就能使用一个扩展的实例时。 类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。 结构Singleton：定义一个 Instance 操作，允许客户访问它的唯一实例。Instance 是 一个类操作（即 Java 中的一个类方法和 C++中的一个静态成员函数）。 客户只能通过 Singleton 的 Instance 操作访问一个 Singleton 的实例。
优缺点对唯一实例的受控访问：因为 Singleton 类封装它的唯一实例，所以它可以严格地控制客户怎样以及何时访问它。 缩小名字空间：Singleton 模式是对全局变量的一种改进，它避免了那些存储唯一实例的全局变量污染名字空间。 允许可变数目的实例：可以用相同的方法来控制应用所使用的实例的数目。 比类操作更灵活：C++等语言不允许一个类有多个实例。此外，C++中的静态成员函数不是虚函数，因此子类不能多态地重定义它们。 实现类型定义 方法实现：在 Instance 方法中懒初始化 注意构造器是 protected 的。试图直接实例化 Singleton 的客户将得到一个编译时的错误信息。这就保证了仅有一个实例可以被创建。
关于全局变量法实现单例的问题：在 C++中将单件定义为一个全局或静态的对象，然后依赖于自动初始化，这是不够的（应当使用静态成员函数）。这是因为：
不能保证静态对象只有一个实例会被声明 可能没有足够的信息在静态初始化时实例化每一个单件（例如初始化需要依赖后续计算的值） C++没有定义转换单元（translation unit）上全局对象的构造器的调用顺序 使用一个 Singleton 创建不同类型的单件
由 Singleton 派生子类，不同子类用于创建不同单件 对于 C++：在不同的文件中创建不同的 Singleton 的实现，然后链接时选择具体的实现。 使用单件注册表：可能的 Singleton 类的集合不是由 Instance 定义的。Singleton 类可以根据名字在一个众所周知的注册表（存储实例名→单件实例的映射关系）中注册它们的单件实例；收到请求时查询相应的单件（如果存在的话）并返回它。 Singleton 类不再负责创建单件。它的主要职责是使得供选择的单件对象在系统中可以被访问 所有可能的 Singleton 子类的实例都必须被创建，否则它们不会被注册 如何实现单件注册表：
Singleton 类提供注册、查询、创建实例的接口 Singleton 类可以在其构造器中注册自己。例如， MySingleton 子类可以像下面这样做（需要在包含 MySingleton 实现的文件中以静态实例的形式创建该对象，从而调用注册方法）：   </content></entry><entry><title>4-结构型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  结构型模式涉及如何组合类和对象以获得更大的结构。结构型类模式采用继承机制来组合接口或实现。
Adapter（4.1）模式：适配器使得一个接口（adaptee 的接口）与其他接口兼容，从而给出多个不同接口的统一抽象。 Composite（4.3）模式是结构型对象模式的一个实例。它描述了如何构造一个类层次式结构，这一结构由两种类型的对象（基元对象和组合对象）所对应的类构成。 组合对象可以组合基元对象和组合对象 Flyweight（4.6）模式为了共享对象定义了一个结构。 为何要求对象共享：效率和一致性。使用对象共享而不是进行对象复制，可以节省大量的空间资源。 Flyweight 的对象共享机制主要强调对象的空间效率 Proxy（4.7）模式中，proxy 对象作为其他对象的一个方便的替代或占位符。 它可以在局部空间中代表一个远程地址空间中的对象 可以表示一个要求被加载的较大的对象 0.1.1 Adapter、Facade 与 BridgeAdapter 与 Bridge共同点：
都给另一对象提供了一定程度的间接性，因而有利于系统的灵活性 都涉及从自身以外的一个接口向这个对象转发请求。 Adapter 与 Bridge不同点：
用途： Adapter 模式主要是为了解决两个已有接口之间不匹配的问题。它不考虑这些接口是怎样实现的，也不考虑它们各自可能会如何演化 Bridge 模式则对抽象接口与它的（可能是多个）实现部分进行桥接。虽然这一模式允许你修改实现它的类，但是它仍然为用户提供了一个稳定的接口。 阶段： Adapter 模式在类已经设计好后实施，其目的一般是避免代码重复。此处耦合不可预见。 Bridge 模式在设计类之前实施：一个抽象将有多个实现部分，并且抽象和实现两者是独立演化的 facade 定义一个新的接口，而 Adapter 则复用一个原有的接口（适配器使两个已有的接口协同工作而非定义新的接口）
0.1.2 Composite、DecoratorComposite（4.3）模式和 Decorator（4.4）
相同点：仅限于都是递归组合 不同点： Decorator 用于添加功能而不产生新的子类 Composite 用于构造类   </content></entry><entry><title>4.1-Adapter「wrapper」-适配器-结构型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.1-adapterwrapper-%E9%80%82%E9%85%8D%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html"><![CDATA[  又称包装器（wrapper）
用途将一个类的接口转换成客户希望的另外一个接口。
Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 Adapter 经常还要负责提供那些被匹配的类所没有提供的功能 示例已有类型 A 的接口和实现，考虑使之适配类型 B 的接口：
类版本：继承 B 的接口和 A 的实现 对象版本：类型 B 中存储一个类型 A 的实例，调用其接口实现类型 B 的自身接口 例如：有一个 TreeDisplay 窗口组件用于展示目录树，现在要展示继承层次树
结构类适配器：Adapter 同时继承 Target 和 Adaptee 对象适配器 参与者
Target（Shape）：定义 Client 使用的与特定领域相关的接口。 Client（DrawingEditor）：与符合 Target 接口的对象协同。 Adaptee（TextView）：定义一个已经存在的接口，这个接口需要适配。 Adapter（TextShape）：对 Adaptee 的接口与 Target 接口进行适配。 Client 调用 Adapter 的接口，然后 Adapter 调用 Adaptee 接口实现请求
适用情形你想使用一个已经存在的类，而它的接口不符合你的需求。 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。 （仅适用于对象 Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。 优缺点类适配器和对象适配器互有优缺点：
类适配器 优点：Adapter 可以重定义 Adaptee 的部分行为，因为 Adapter 是 Adaptee 的一个子类。 缺点：无法兼容该 Adaptee 的子类型 对象适配器 可以兼容 Adaptee 的子类型 重定义 Adaptee 的行为较为困难（需要构建 Adaptee 的新子类，并在 Adapter 中引用该类型） 实现使用 C++实现适配器类在使用 C++实现适配器类时，Adapter 类应该采用公共方式继承 Target 类，并且用私有方式继承 Adaptee 类。因此，Adapter 类应该是 Target 的子类型，但不是 Adaptee 的子类型。
C++中公共继承和私有继承的区别：
公共继承：是指派生类以 public 的方式继承基类，这样， 基类的 public 成员和 protected 成员在派生类中保持原有的访问属性，而基类的 private 成员在派生类中不可见。 公共继承可以实现基类到派生类的 is-a 关系，即派生类是基类的一种特殊类型，可以使用基类的指针或引用来操作派生类的对象 私有继承：是指派生类以 private 的方式继承基类，这样， 基类的 public 成员和 protected 成员在派生类中都变成 private 属性，而基类的 private 成员在派生类中不可见。 私有继承可以实现基类到派生类的 has-a 关系，即派生类包含了基类的一个对象作为自己的一部分，但不能使用基类的指针或引用来操作派生类的对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 目标接口 class Target { public: virtual ~Target() {} virtual void request() = 0; // 抽象方法：请求 }; // 被适配类 class Adaptee { public: void specificRequest() { std::cout &lt;&lt; &#34;Specific request&#34; &lt;&lt; std::endl; // 特殊的请求 } }; // 适配器类 class Adapter : public Target, private Adaptee { public: void request() override { specificRequest(); // 调用被适配类的特殊请求方法 } }; // 客户端 int main() { Target* target = new Adapter(); // 创建一个适配器对象 target-&gt;request(); // 调用目标接口的请求方法 delete target; // 释放资源 return 0; } 双向透明适配器双向适配器是一种可以实现两个不兼容接口之间的双向转换的适配器，它可以让两个接口的对象互相调用对方的方法，从而提供透明的操作。 双向适配器的实现方法是，在适配器类中同时持有两个接口的引用，然后实现两个接口的所有方法，每个方法中都调用对应的另一个接口的方法。
例如，假设有一个电源接口 Power 和一个电池接口 Battery ，它们分别有 charge 和 supply 方法，我们可以定义一个双向适配器类 PowerBatteryAdapter 来实现两个接口之间的转换，代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 电源接口 public interface Power { void charge(); // 充电方法 } // 电池接口 public interface Battery { void supply(); // 供电方法 } // 双向适配器类 public class PowerBatteryAdapter implements Power, Battery { private Power power; // 持有电源对象的引用 private Battery battery; // 持有电池对象的引用 public PowerBatteryAdapter(Power power, Battery battery) { this.power = power; this.battery = battery; } @Override public void charge() { battery.supply(); // 调用电池的供电方法 } @Override public void supply() { power.charge(); // 调用电源的充电方法 } } 这样，我们就可以通过双向适配器来实现电源和电池之间的互相转换
可插入的适配器可插入的适配器可以让客户端方便地调用可以变化的接口。 可插入的适配器的核心思想是，通过一个变量来保存方法，从而实现动态地变化方法。拥有这个变量的类的不同对象就可以拥有不同的方法。
实现方法：以 TreeDisplay 窗口组件自动地布置和显示层次式结构（包括目录树和继承树等）为例
首先（这也是所有这三种实现都要做的）是为 Adaptee 找到一个“窄”接口，即可用于适配的最小操作集。这有 3 种实现途径： 使用抽象操作：在 TreeDisplay 类中定义窄 Adaptee 接口相应的抽象操作，由子类来实现这些抽象操作并匹配具体的树结构的对象（例如，DirectoryTreeDisplay 子类将通过访问目录结构实现这些操作）	使用代理对象：TreeDisplay 将访问树结构的请求转发到代理对象（delegate：委托）。 参数化的适配器：根据不同的参数来调整其行为的适配器。参数化的适配器可以实现更灵活和通用的适配功能，比如根据不同的目标接口、不同的转换规则、不同的策略等来适配不同的对象。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 定义一个被适配对象的类 class Adaptee { public: void specificRequest() { cout &lt;&lt; &#34;This is a specific request from Adaptee&#34; &lt;&lt; endl; } }; // 定义一个目标接口的类 class Target { public: virtual void request() = 0; }; // 定义一个参数化的适配器模板类，T1被适配者，T2是Target template&lt;class T1, class T2&gt; class Adapter : public T2 { private: T1 adaptee; // 被适配对象 public: // 构造函数，接受一个被适配对象作为参数，并赋值给成员变量 Adapter(T1 a) : adaptee(a) {} // 重载虚函数，调用被适配对象的特有方法 void request() override { adaptee.specificRequest(); } }; int main() { // 创建一个被适配对象 Adaptee a; // 创建一个参数化的适配器对象，传入被适配对象作为参数 Adapter&lt;Adaptee, Target&gt; adapter(a); // 调用目标接口的方法 adapter.request(); // 输出 This is a specific request from Adaptee return 0; } 相关模式模式 Bridge（4.2）的结构与对象适配器类似，但两者的出发点不同：
Bridge 的目的是将接口部分和实现部分分离，从而可以对它们较为容易也相对独立地加以改变。 Adapter 则意味着改变一个已有对象的接口。 Decorator（4.4）模式增强了其他对象的功能而同时又不改变它的接口，因此 Decorator 对应用程序的透明性比适配器要好。
例如 Decorator 支持递归组合，而纯粹使用适配器是不可能实现这一点的。 模式 Proxy（4.7）在不改变它的接口的条件下，为另一个对象定义了一个代理
  ]]></content></entry><entry><title>4.2-Bridge「Handle」-桥接-结构型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.2-bridgehandle-%E6%A1%A5%E6%8E%A5-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html"><![CDATA[  又称 Handle/Body
0.1.1 用途将抽象部分与它的实现部分分离，使它们可以独立地变化。 继承 VS Bridge：0.1.2 示例场景：一个 GUI 工具箱中的可移植窗口需要支持 XWindows 和 PM 系统 实现方法：
继承：定义 Window 抽象类和它的两个子类 XWindow 与 PMWindow，由它们分别实现不同系统平台上的 Window 界面。 缺陷： 扩展 Window 抽象使之适用于不同种类的窗口或新的系统平台很不方便（需要为 Windows 的每个子类针对每个平台分别创建一个类） 继承机制使得客户代码与平台相关。 Bridge 模式：将接口抽象和实现放在彼此独立的类层次结构中： 对 Window 子类的所有操作都是用 WindowImp 接口中的抽象操作实现的 将 Window 与 WindowImp 之间的关系称为桥接，它在抽象类与它的实现之间起到了桥梁作用，使它们可以独立地变化。 0.1.3 适用性不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如，这种情况可能是因为，在程序运行时实现部分应可以被选择或者切换。 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时 Bridge 模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。 对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。 （C++）你想对客户完全隐藏抽象的实现部分。在 C++中，类的表示在类接口中是可见的。 若采用继承模式会有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。 Rumbaugh 称这种类层次结构为“嵌套的泛化”（nested generalization） [RBP+91]。 你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。 0.1.4 结构Abstraction：抽象接口（例如示例中的 Window），维护一个指向实现（Implementor）的指针 RefinedAbstraction：精化的接口（例如示例中的 IconWindow） Implementor：实现类的接口（示例中的 WindowImp） 该接口无需和 Abstraction 的接口一致。一般来讲： Implementor 接口仅提供基本操作 Abstraction 则定义了基于这些基本操作的较高层次的操作 ConcreteImplementor：实现 Implementor 的具体接口（示例中的 XWindowImp、PMWindowImp） Abstraction 将 client 的请求转发给它的 Implementor 对象
0.1.5 优缺点分离接口及其实现部分，抽象类的实现可以在运行时进行配置、变更 （用于确保一个类库不同版本之间的兼容性）有助于降低对实现部分编译时的依赖性，当改变一个实现类时，并不需要重新编译 Abstraction 类和它的客户程序。 接口与实现分离有助于分层，从而产生更好的结构化系统 提高可扩充性你可以独立地对 Abstraction 和 Implementor 层次结构进行扩充 实现细节对客户透明 （可以对客户隐藏实现细节） 例如在 C++中，Implementor 类的类接口可以在一个私有的头文件中定义，这个文件不提供给客户。这样你就对客户彻底隐藏了一个类的实现部分。 0.1.6 实现在仅有一个实现的时候，没有必要创建一个抽象的 Implementor 类 创建合适的 Implementor 类有多种方法： 指定特定的 ConcreteImplementor 类：如果 Abstraction 知道所有的 ConcreteImplementor 类，它就可以在它的构造器中对其中的一个类进行实例化 指定缺省实现，并根据需要切换实现：例如将容器起初初始化为数组，容量过大后切换为 hash 表 由代理对象决定：例如 AbstractFactory 模式中的选择窗口样式的工厂类 C++中无法使用多重继承实现真正的 Bridge 模式（会把接口和特定实现绑定）：public 继承接口，private 继承实现 共享 Implementor 对象：CPP 中常用 Handle/Body 的方法在对象之间共享实现（通过重载赋值运算符执行引用计数） 1 2 3 4 5 6 7 8 Handle&amp; Handle::operator=(const Handle&amp; other) { other._body-&gt;Ref(); _body-&gt;Unref(); if (_body-&gt;RefCount() == 0) { delete _body; } _body = other._body; }   ]]></content></entry><entry><title>4.3-Composite-组合-结构型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.3-composite-%E7%BB%84%E5%90%88-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  目的将对象组合成树形结构以表示“部分–整体”的层次结构。 Composite 使得用户对单个对象和组合对象的使用具有一致性。 示例例如 GUI 框架允许用户可以组合多个简单组件以递归形成一些较大的组件。这有 2 种实现方式：
使用图元类和容器类：使用这些类的代码必须区别对待图元对象与容器对象，而实际上大多数情况下用户认为它们是一样的。 使用 Composite 模式递归构建 Composite 模式的关键是一个抽象类，它既可以代表图元，又可以代表图元的容器。其内部提供图元和图元容器所需的所有接口
它的图元子类（树的叶结点，Line，Text 等）无需实现容器相关的操作 聚合类 Picture 定义了一个 Graphic 的集合，它的 Draw 递归调用子部件的 Draw 操作。由于 Picture 接口与 Graphic 接口是一致的，因此 Picture 对象可以递归地组合其他 Picture 对象。 适用性你想表示对象的部分–整体层次结构。 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 结构组合结构如下： 继承结构如下： 参与者
Component： 提供 Leaf 所需的操作，提供用于访问管理 Component 子组件所需的操作 通常需要，实现所有类共有接口的默认行为 如果需要，在 Component 类中提供访问父组件的接口，Leaf 和 Composite 按需实现这个接口。 父部件引用可以简化结构的上移和组件的删除 Composite（Picture） 定义有子部件的那些部件的行为。 存储子部件。 在 Component 接口中实现与子部件有关的操作。 Leaf：定义图元对象的行为 Client：通过 Component 接口操纵组合部件的对象 用户使用 Component 类接口与组合结构中的对象进行交互。
如果接收者是一个叶结点，则直接处理请求。 如果接收者是 Composite，它通常将请求发送给它的子部件，在转发请求之前和/或之后可能执行一些辅助操作。 优缺点优点：
简化客户代码：客户可以一致地使用组合结构和单个对象。通常用户不知道（也不关心）处理的是一个叶结点还是一个组合组件。 使得更容易增加新类型的组件：新定义的 Composite 或 Leaf 子类自动地与已有的结构和客户代码一起工作 缺点：
使你的设计变得更加一般化：容易增加新组件会导致很难限制组合中的组件。 有时你希望一个组合只能有某些特定的组件。使用 Composite 时，你不能依赖类型系统施加这些约束，而必须在运行时进行检查 实现父组件引用父组件引用需要确保一个不变式：假设组件 B 在组件 A 的子组件集合中，则 B 的父组件引用必须指向 A
实现方法：仅当在一个组合中增加或删除一个组件时，才改变这个组件的父部件
在 Composite 类的 Add 和 Remove 操作中实现这种方法，那么所有的子类都可以继承这一方法，并且将自动维护这一不变式。 共享组件好处：减少存储占用等 实现方法：一个组件指向多个父组件 缺点：当一个请求在结构中向上传递时，这种方法会导致多义性。如果子部件可以将一些状态（或是所有的状态）存储在外部，从而不需要向父部件发送请求，那么这种方法是可行的。 最大化 Component 接口Composite 模式的目标是让用户无感知地对等使用 Composite 和 Leaf
需求：因此抽象父类 Component 应当提供尽可能多的公共操作并提供缺省实现 矛盾：类层次结构的设计原则要求：父类操作集⊆子类操作集，而 Composite 的子组件管理对于 Leaf 没有意义，不应当在 Component 中提供缺省实现 解决方法： 在 Component 中提供访问子组件的缺省操作，这个缺省的操作不返回任何一个子结点。 将 Leaf 视为包含 0 个子组件的 Composite，使用缺省操作 Composite 重载访问子组件的操作 子组件管理问题：子组件管理的 Add 和 Remove 操作需要在 Component 还是 Composite 中声明？
在 Component 中声明： 优点：透明性好，可以一致地使用所有的组件 缺点：安全性差，这些操作对于 Leaf 同样可用，用户可能在 Leaf 上调用这些操作 如果该组件不允许有子部件，或者 Remove 的参数不是该组件的子结点，通常最好使用缺省方式（可能是产生一个异常）处理 Add 和 Remove 的失败。 在 Composite 中声明： 优点：安全性好，静态语言的编译器可以确保不会在 Leaf 中 Add 或 Remove 子组件 缺点：透明性差，需要区别对待 Composite 和 Leaf。 可能会丢失类型信息，不得不执行不安全的强制类型转换（Component→Composite） 避免强制类型转换：在 Component 类中声明一个操作 Composite* GetComposite()，缺省返回空指针。然后 Composite 重载并返回 this 指针 删除 Composite 时，注意同时删除其子结点
改善子组件遍历和查找性能Composite 类可以缓冲存储对它的子结点进行遍历或查找的相关信息。
例子中 Picture 类能高速缓冲存储其子部件的边界框，在绘图或选择期间，当子部件在当前窗口中不可见时，这个边界框使得 Picture 不需要再进行绘图或选择。
一个组件发生变化时，它的父部件原先缓冲存储的信息也变得无效（因此需要通知父组件刷新缓存）
相关模式部件–父部件连接用于 Responsibility of Chain（5.1）模式。 Decorator（4.4）模式经常与 Composite 模式一起使用。当装饰和组合一起使用时，它们通常有一个公共的父类。因此装饰必须支持具有 Add、Remove 和 GetChild 操作的Component 接口。 Flyweight（4.6）让你共享组件，但不再能引用其父部件。 Itertor（5.4）可用来遍历 Composite。 Visitor（5.11）将本来应该分布在 Composite 和 Leaf 类中的操作和行为局部化。   </content></entry><entry><title>4.4-Decorator「wrapper」-装饰器-结构型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.4-decoratorwrapper-%E8%A3%85%E9%A5%B0%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  目的动态地向对象添加额外功能，比创建子类更加灵活
示例GUI 工具箱允许你对任意一个用户界面组件添加一些特性（例如边框），或是一些行为（例如窗口滚动）。
一种较为灵活的方式是将组件嵌入另一个对象中，由这个对象添加边框。我们称这个嵌入的对象为装饰。
这个装饰与它所装饰的组件接口一致，因此它对使用该组件的客户透明（因此可以递归地嵌套） 它将客户请求转发给该组件，并且可能在转发前后执行一些额外的动作（例如画一个边框）。 适用性在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 处理那些可以撤销的职责。 当不能采用生成子类的方法进行扩充时，例如： 可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长 类定义被隐藏或类是 final 的 结构Component：对象接口 ConcreteComponent Decorator：维护指向 Component 的指针，定义和 Component 一致的接口 ConcreteDecorator：向组件添加职责（将操作代理给所持有的对象，并附加自身的操作） 优缺点比静态继承更灵活： 可以用添加和分离装饰器的方法，用装饰在运行时增加和删除职责。 可以很容易地重复添加一个特性 避免在层次结构高层的类有太多的特征 Decorator 相比 Component 模式而言，是完全透明的包装，使用装饰时不应当依赖对象标识 缺点：有许多小对象：采用 Decorator 模式进行系统设计往往会产生许多看上去类似的小对象，这些对象仅仅在它们相互连接的方式上有所不同，而不是它们的类或是它们的属性值有所不同。尽管对于那些了解这些系统的人来说，很容易对它们进行定制，但是很难学习这些系统，排错也很困难。
实现接口一致性：装饰器必须和被装饰的对象接口一致 省略抽象的装饰器：仅需要添加一个职责时，没有必要定义抽象 Decorator 类 保持 Component 类的简单性：为保证一致性，组件和装饰器必须有共同的 Component 父类，因此需要避免这个类过大。这个父类应集中于定义接口而不是存储数据，对数据表示的定义应延迟到子类中 相关模式Adapter（4.1）：Decorator 模式不同于 Adapter 模式，因为装饰仅改变对象的职责而不改变它的接口；而适配器将给对象一个全新的接口。 Composite（4.3）：可以将装饰视为一个退化的、仅有一个组件的组合。然而，装饰仅给对象添加一些额外的职责——它的目的不在于对象聚集。 装饰器 VS 策略模式改变对象的行为主要有两种方式：
Decorator 模式改变外壳 Strategy 模式改变内核 当 Component 类原本就很庞大时，使用 Decorator 模式代价太高， Strategy 模式相对好一些
  </content></entry><entry><title>4.5-Facade-外观-结构型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.5-facade-%E5%A4%96%E8%A7%82-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  用途定义一个高层接口，为子系统的一组接口提供一个一致的界面，使得子系统更加易用 Facade/fəˈsɑd/ 还可以降低子系统间的依赖关系 示例有一个编译子系统，包含了若干个类来实现这一编译器，如 Scanner、Parse 等。
多数普通用户不关心语法分析等细节，只是希望实现一些代码。 因此子系统提供一个 Compiler 对象提供统一的高层接口，隐藏了内部实现 对于了解内部细节、有特殊需求的高级用户，可以绕过外观类 Complier 使用低层类实现功能 外观类不会隐藏内部实现 适用性当你要为一个复杂子系统提供一个简单接口时。 Facade 可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够 而那些需要更多的可定制性的用户可以越过 Facade 层。 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入 Facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。 当你需要构建一个层次结构的子系统时，使用 Facade 模式定义子系统中每层的入口点。 如果子系统之间是相互依赖的，可以让它们仅通过 Facade 进行通信，从而简化了它们之间的依赖关系。 结构Facade：知道系统的内部结构，并将客户请求代理给适当的子系统对象 Subsystemclasses： 实现子系统的功能，处理 Facade 分派的任务 没有 Facade 的任何信息 使用 Facade 的客户程序不需要直接访问子系统对象，而通过发送请求给 Facade 的方式与子系统通信。Facade 将这些消息转发给适当的子系统对象。
优缺点优点：
对客户屏蔽子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便。 它实现了子系统与客户之间的松耦合关系（子系统内部的功能组件往往是紧耦合的） Facade 模式有助于建立层次结构系统 Facade 模式可以消除复杂的循环依赖关系 Facade 模式同样也有利于降低编译依赖性，使得编译一个子系统一般不需要编译所有其他的子系统。 如果应用需要，它并不限制它们使用子系统类。因此你可以在系统易用性和通用性之间加以选择。 实现进一步降低客户-子系统耦合度的方法： Facade 定义为抽象类而其具体子类对应不同的子系统实现可以进一步降低客户和子系统的耦合度 还可以用不同的子系统对象配置 Facade 对象 公共子系统类与私有子系统类：子系统和一个类都可用于功能的封装，相应地可以考虑提供公有和私有接口 子系统的公共接口包含所有的客户程序可以访问的类（包括 Facade），私有接口仅用于对子系统进行扩充 相关模式Abstract Factory（3.1）模式可以与 Facade 模式一起使用以提供一个接口，这一接口可用来以一种子系统独立的方式创建子系统对象。 Abstract Factory 也可以代替 Facade 模式隐藏那些与平台相关的类。
Mediator（5.5）模式与 Facade 模式的相似之处是，它抽象了一些已有的类的功能。然而，Mediator 的目的是对同事之间的任意通信进行抽象，通常集中不属于任何单个对象的功能。Mediator 的同事对象知道中介者并与它通信，而不是直接与其他同类对象通信。相对而言，Facade 模式仅对子系统对象的接口进行抽象，从而使它们更容易使用；它并不定义新功能，子系统也不知道 Facade 的存在。
通常来讲，仅需要一个 Facade 对象，因此 Facade 对象通常属于 Singleton（3.5）模式。
facade 定义一个新的接口，而 Adapter 则复用一个原有的接口（适配器使两个已有的接口协同工作而非定义新的接口）
  </content></entry><entry><title>4.7-Proxy-代理-结构型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.7-proxy-%E4%BB%A3%E7%90%86-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  目的为其他对象提供一种代理以控制该对象的访问。 类似网络中的反向代理
示例需求：
为了改善打开执行速度，文档编辑器应当按需创建开销很大的对象（例如大型图像） 需要隐藏根据需要创建图像这一事实，从而不会使得编辑器的实现复杂化 方法：
使用图像 Proxy 替代真正的图像，Proxy 可以代替一个图像对象，并且在需要（文档编辑器调用图像代理的 Draw 操作）时负责实例化这个图像对象 图像 Proxy 存储图像路径和分辨率，以及对真正的 Image 实例的指引。因此不需要真正实例化这个图像就可以响应格式化程序对图像尺寸的请求 适用性在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用 Proxy 模式。例如：
远程代理（Remote Proxy）为一个对象在不同的地址空间提供局部代表 虚代理（Virtual Proxy）根据需要创建开销很大的对象。 保护代理 （Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。 智能指针（Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。它的典型用途包括： 对指向实际对象的引用计数，可用于内存自动回收 当第一次引用一个持久对象时，将它装入内存 读写锁：在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它 copy-on-write：用代理延迟复杂大对象的拷贝过程，保证只有当这个对象被修改的时候才对它进行拷贝 在实现 Copy-on-write 时必须对实体进行引用计数。 拷贝代理仅会增加引用计数。只有当用户请求一个修改该实体的操作时，代理才会真正地拷贝它。 当引用的数目为零时，这个实体将被删除。 结构Proxy： 基本功能 保存一个引用使得代理可以访问实体。若 RealSubject 和 Subject 的接口相同，Proxy 会引用 Subject。 提供一个与 Subject 的接口相同的接口，这样代理就可以用来替代实体。 控制对实体的存取，并可能负责创建和删除它。 其他功能： Remote Proxy 负责对请求及其参数进行编码，并向不同地址空间中的实体发送已编码的请求。 Virtual Proxy 可以缓存实体的附加信息，以便延迟对它的访问。例如，动机一节中提到的 ImageProxy 缓存了图像实体的尺寸。 Protection Proxy 检查调用者是否具有实现一个请求所必需的访问权限。 Subject（Graphic）：定义 RealSubject 和 Proxy 的共用接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy。 RealSubject（Image）：定义 Proxy 所代表的实体。 代理根据其种类，在适当的时候向 RealSubject 转发请求
实现重载运算符C++支持重载运算符 -&amp;gt; 和 *。
重载运算符，使你能够通过 ImagePtr 对象调用 Image 操作 1 2 3 4 5 6 7 Image* ImagePtr: :operator-&amp;gt; () { return LoadImage(); } Image&amp;amp; ImagePtr::operator*(){ return *LoadImage(); } 虚代理的例子中，图像应该在一个特定的时刻被装载——在 Draw 操作被调用时——而不是在只要引用这个图像就装载它。 重载访问操作符不能做出这种区分。在这种情况下我们只能人工实现每一个代理操作，向实体转发请求。
Proxy 并不总是需要知道实体的类型若 Proxy 类能够完全通过一个抽象接口处理它的实体，则无须为每一个 RealSubject 类都生成一个 Proxy 类，Proxy 可以统一处理所有的 RealSubject 类。 Proxy 要实例化 RealSubject（例如在虚代理中），那么它们必须知道具体的类 相关模式Adapter（4.1）：适配器为它所适配的对象提供了一个不同的接口。 相反，代理提供了与它的实体相同的接口（或实体接口的子集） Decorator（4.4）：尽管装饰的实现部分与代理相似，但装饰的目的不一样。 装饰为对象添加一个或多个功能 而代理则控制对对象的访问   </content></entry><entry><title>5-行为型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  行为型模式涉及算法和对象间职责的分配。行为型模式不仅描述对象或类的模式，还描述它们之间的通信模式。
类行为型模式使用继承机制在类间分派行为 对象行为型模式描述了一组对等的对象怎样相互协作 大多数模式有两种对象：封装该方面特征的新对象，使用这些新对象的已有对象。
不使用这些模式的话，通常这些新对象的功能就会变成已有对象的难以分割的一部分。 通信的封装/协作Observer 通过引入 Observer 和 Subject 对象来分布通信 Mediator 对象则封装了其他对象间的通信 解耦合当合作的对象直接互相引用时，它们变得互相依赖。命令、观察者、中介者和职责链等模式都涉及如何对发送者和接收者解耦，但它们又各有不同的权衡考虑。
命令模式使用一个 Command 对象来定义发送者和接收者之间的绑定关系
Command 对象提供了一个提交请求的简单接口（即 Execute 操作）。 将发送者和接收者之间的连接定义在一个单独的对象中使得该发送者可以与不同的接收者一起工作。 观察者模式通过定义一个接口来通知目标中发生的改变，从而将发送者（目标）与接收者（观察者）解耦
当对象间有数据依赖时，最好用观察者模式来对它们进行解耦。 中介者模式让对象通过一个 Mediator 对象间接地互相引用，从而对它们解耦
它将通信行为集中到一个类中而不是将其分布在各个子类中 为增加灵活性 Mediator 可能不得不实现它自己的分发策略（例如用一定方式对请求编码并打包参数），但这通常会导致类型安全问题 职责链模式通过沿一个潜在接收者链传递请求而将发送者与接收者解耦   </content></entry><entry><title>5.10-TemplateMethod-模板方法</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.10-templatemethod-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  目的定义一个操作的算法骨架，而将一些步骤延迟到子类中。通过子类来实现这些步骤，使得不改变算法结构的情况下，可重新定义算法中的某些特定步骤
适用性一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。 首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。 然后，用一个调用新的操作的模板方法来替换不同的代码。 控制子类扩展。模板方法只在特定点调用 hook 操作，这样就只允许在这些点进行扩展。 结构AbstractClass： 定义抽象的原语操作（primitive operation），具体的子类将重定义它们以实现一个算法的各步骤 实现一个模板方法，定义一个算法的骨架。该模板方法不仅调用原语操作，也调用定义在 AbstractClass 或其他对象中的操作。 ConcreteClass：实现原语操作以完成算法中与特定子类相关的步骤。 效果模板方法是一种代码复用的基本技术。它们在类库中尤为重要，提取了类库中的公共行为。 模板方法导致一种反向的控制结构，父类调用一个子类的操作。
模板方法调用下列类型的操作：
原语操作（即抽象操作）：子类必须重载以提供具体实现。 钩子操作（hook operation），它提供了缺省的行为，子类可以在必要时通过重载进行扩展。钩子操作在缺省情况下通常是空操作。 其他操作：不应重定义这些操作 很重要的一点是模板方法应该区分哪些操作是原语操作（必须重载），哪些是钩子操作（可以重载）
实现访问控制： 在 C++中，一个模板方法调用的原语操作可以被定义为 protected 的纯虚函数，保证它们只被模板方法调用，同时必须重载。 模板方法自身不需要被重定义，因此可以将模板方法定义为一个非虚成员函数。 尽量减少原语操作 命名约定：可以给应被重定义的操作的名字加上一个前缀以识别它们 相关模式Strategy（5.9）：模板方法使用继承来改变算法的一部分， Strategy 使用委托来改变整个算法。 Factory Method（3.3）常被模板方法调用。
  </content></entry><entry><title>5.11-Visitor-访问者</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.11-visitor-%E8%AE%BF%E9%97%AE%E8%80%85/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html"><![CDATA[   目的表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
示例考虑一个编译器，它将源程序表示为一个抽象语法树，对于语法树结点需要进行不同的处理：类型检查，代码优化等 将操作和结点类耦合带来的问题：将所有这些操作分散到各种结点类中会导致整个系统难以理解、难以维护和修改；此外，增加新的操作通常需要重新编译所有这些类 解决方法：将每一个类中相关的操作包装在一个独立的对象（称为一个 Visitor）中，并在遍历抽象语法树时将此对象传递给当前访问的元素 所有抽象语法树的访问者有一个抽象的父类 NodeVisitor。NodeVisitor 必须为每一个结点类定义一个操作 使用 Visitor 模式，必须定义两个类层次： 一个对应于接受操作的元素（Node 层次） 另一个对应于定义对元素的操作的访问者（NodeVisitor 层次）。给访问者类层次增加一个新的子类即可创建一个新的操作。 适用性一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。 需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。 结构Visitor：接口。为该对象结构中 ConcreteElement 的每一个类声明一个 Visit 操作，该操作的名字和特征标识了发送 Visit 请求给该访问者的类。
访问者就可以通过该元素的特定接口直接访问它。 ConcreteVisitor：实现每个由 Visitor 声明的操作。每种具体的 Visitor 实现一种特定操作
Element，ConcreteElement：定义一个 Accept 操作，它以一个访问者为参数
ObjectStructure（例如 List，Map）：能枚举它的元素，可以提供一个高层的接口以允许该 Visitor 访问它的元素
一个使用 Visitor 模式的客户必须创建一个 ConcreteVisitor 对象，然后遍历该对象结构，并用该访问者访问每一个元素。
当一个元素被访问时，它调用对应于它的类的 Visitor 操作。
效果访问者模式使得易于增加新的操作：仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。相反，如果每个功能都分散在多个类之上的话，定义新的操作时必须修改每一个类。
访问者集中相关的操作而分离无关的操作：相关的行为不是分布在定义该对象结构的各个类上，而是集中在一个访问者中；无关行为却被分别放在各自的访问者子类中
增加新的 ConcreteElement 类很困难：每添加一个新的 ConcreteElement 都要在 Vistor 中添加一个新的抽象操作，并在每一个 ConcretVisitor 类中实现相应的操作。
和迭代器的异同：
迭代器（参见 Iterator（5.4））可以通过调用结点对象的特定操作来遍历整个对象结构，这就意味着该迭代器能够访问的所有元素都有一个共同的父类 Item。 访问者没有这种限制。它可以访问不具有相同父类的对象。 1 2 3 4 5 class Visitor { public ： void VisitMytype(Mytype*); void VisitYourtype(yourType*); } 累积状态: 当访问者访问对象结构中的每一个元素时，后者可能会累积状态。如果没有访问者，这一状态将作为额外的参数传递给进行遍历的操作
破坏封装：该模式常常迫使你提供访问元素内部状态的公共操作，这可能会破坏它的封装性。
实现Visitor 的关键双分派：得到执行的操作不仅取决于 Visitor 的类型还取决于它访问的 Element 的类型。
将操作安放在一个 Visitor 中，并使用 Accept 在运行时进行绑定。 扩展 Element 接口就等于定义一个新的 Visitor 子类而不是多个新的 Element 子类。 代码实现C++中，Visitor 类可以这样定义:
1 2 3 4 5 6 7 8 class Visitor { public: virtual void VisitE1ementA(ElementA *); virtual void VisitE1ementB(ElementB *); // ... protected: Visitor(); } 每个 ConcreteElement 类实现一个 Accept 操作，这个操作调用访问者中相应于本 ConcreteElement 类的 Visit 操作。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Element { public: virtual ~Element() = 0; virtual void Accept(Visitor &amp;) = 0; protected: Element(); }; class ElementA : public Element { public: ElementA(); virtual void Accept(Visitor &amp;v); }; class ElementB : public Element { public: ElementB(); virtual void Accept(Visitor &amp;v) { v.VisitElementB(this); } }; CompositeElement 则这样实现 Accept
1 2 3 4 5 6 7 8 9 10 11 12 13 class CompositeElement : public Element { public: virtual void Accept(Visitor &amp;); private: List&lt;Element *&gt; *_children; }; void CompositeElement::Accept(Visitor &amp;v) { ListIterator&lt;Element *&gt; i(_children); for (i.First(); !i.IsDone(); i.Next()) i.Current_Item()-&gt;Accept(v); v.VisitCompositeElement(this); }   ]]></content></entry><entry><title>5.4-Iterator「cursor」-迭代器-行为型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.4-iteratorcursor-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  目的提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示
示例一个聚合对象，如列表（list），需要：
提供一种方法来让别人可以访问它的元素，而又不需要暴露它的内部结构 可能要以不同的方式遍历 不希望列表的接口中充斥着各种不同遍历的操作 KEY：将对列表的访问和遍历从列表对象中分离出来并放入一个迭代器（iterator）对象中，由迭代器对象跟踪当前元素，维护遍历序列
将遍历机制与列表对象分离使我们可以对同一个容器定义不同的迭代器来实现不同的遍历策略。例如先序迭代和后序迭代 多态迭代：
为何需要多态：上述方法中，迭代器和列表是耦合在一起的，而且客户对象必须知道遍历的是一个列表而不是其他聚合结构 方法：使用继承和多态机制，并由容器提供 CreateIterator 的接口，创建自己兼容的某种迭代器 这是 Factory Method，产生两个类层次，一个是列表的，一个是迭代器的。 CreateIterator“联系”这两个类层次 适用性访问一个聚合对象的内容而无须暴露它的内部表示。 支持对聚合对象的多种遍历。 为遍历不同的聚合结构提供一个统一的接口（即支持多态迭代）。 结构Iterator：定义访问和遍历元素的接口 ConcreteIterator： 实现迭代器接口 对该聚合遍历时跟踪当前位置，并能够计算出待遍历的后继对象 Aggregate（聚合）：定义创建相应迭代器对象的接口。 ConcreteAggregate：实现创建相应迭代器的接口，该操作返回 ConcreteIterator 的一个适当的实例 优缺点迭代器模式有三个重要的作用：
支持以不同的方式遍历一个聚合 简化了聚合的接口：有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了 在同一个聚合上可以同时有多个遍历：每个迭代器保持它自己的遍历状态，因此你可以同时进行多个遍历 实现谁控制迭代控制迭代即控制迭代的推进过程，根据迭代过程是迭代器还是使用该迭代器的客户控制，迭代器可分为内部/外部迭代器 2 类：
外部迭代器：客户必须主动推进遍历的步伐，显式地向迭代器请求下一个元素 内部迭代器：由迭代器控制迭代的推进，客户只需向其提交一个待执行的操作，而迭代器将对聚合中的每一个元素实施该操作。 谁定义遍历算法迭代器和聚合均可定义遍历算法
聚合定义遍历算法：聚合定义遍历算法，迭代器只存储当前迭代的上下文
在遍历过程中用迭代器来存储当前迭代的状态。我们称这种迭代器为游标（cursor），因为它仅用来指示当前位置。 客户会以这个游标为参数调用该聚合的 Next 操作，而 Next 操作将改变这个指示器的状态 迭代器定义遍历算法：
优点： 易于在相同的聚合上使用不同的迭代算法 易于在不同的聚合上复用相同的算法 缺点：遍历算法可能需要访问聚合的私有变量。如果这样，将遍历算法放入迭代器中会破坏聚合的封装性 遍历时修改在遍历一个聚合的同时更改这个聚合可能是危险的。如果在遍历聚合的时候增加或删除聚合元素，可能会导致两次访问同一个元素或者遗漏掉某个元素。
一个健壮的迭代器 robust iterator 保证==插入和删除操作不会干扰遍历，且不需要拷贝该聚合==
这大多数需要向聚合注册迭代器。当插入或删除元素时，该聚合需要： 调整迭代器的内部状态 或在内部维护额外的信息以保证正确的遍历。 可选接口迭代器的最小接口由 First、Next、IsDone 和 CurrentItem 操作组成
对有序的聚合：Previous 操作将迭代器定位到前一个元素 对于可以随机访问的聚合：SkipTo 操作将迭代器定位到符合指定条件的元素对象上
多态的迭代器多态迭代器是有以下两种缺点
其要求用一个 Factory Method 动态地分配迭代器对象。因此仅当必须多态时才使用它，否则使用在栈中分配内存的具体的迭代器 客户必须负责删除它（这容易导致错误，因为你容易忘记释放一个使用堆分配的迭代器对象） 解决方法；我们可使用一个栈分配的 Proxy 作为实际迭代器的中间代理。该代理在其析构器中删除迭代器。这样当该代理的生命周期结束时，实际迭代器将同它一起被释放 这是著名的 C++“资源分配即初始化”技术的应用实例 迭代器和聚合迭代器可被看作创建它的聚合的一个扩展，两者紧密耦合。在 C++中可以如此实现：
将迭代器作为聚合的友元，从而避免在聚合类中定义迭代操作 使定义新的遍历变得很难，因为它将要求改变该聚合的接口增加另一个友元 解决方法：==友元+继承==。迭代器类可包含一些 protected 操作来访问聚合类的重要的非公共可见的成员。迭代器子类（且只有迭代器子类）可使用这些 protected 操作来得到对该聚合的特权访问。 用于组合对象的迭代器Composite（4.3）模式中的递归聚合结构上：
外部迭代器可能难以实现，因为在该结构中不同对象处于嵌套聚合的多个不同层次，因此一个外部迭代器为跟踪当前的对象必须存储一条纵贯该 Composite 的路径 内部迭代器会更容易一些：它仅需要递归地调用自己 如果组合中的结点有一个接口可以从一个结点移到它的兄弟结点、父结点和子结点，则可选用游标迭代
空迭代器空迭代器用于处理边界条件，其 isDone 恒为真
例如，可以简化树形结构的聚合的遍历
在遍历过程中的每一个结点，都可向当前的元素请求遍历其各个子结点的迭代器 叶结点元素返回一个 NullIterator   </content></entry><entry><title>5.5-Mediator-中介者-行为型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.5-mediator-%E4%B8%AD%E4%BB%8B%E8%80%85-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  目的用一个中介对象封装对象交互，使各对象不需要显式地相互引用
从而可以解耦合 可以对立改变之间的交互 示例面向对象中，对象的行为分布到各个对象中。这种分布可能会导致对象间有许多连接。在最坏的情况下，每一个对象都知道其他所有对象。
考虑 GUI 中各个窗口组件的依赖关系：例如当一个特定的输入域为空时，某个按钮不能使用；ListBox 选择一项可能会改变一个输入域的内容
这导致每个组件必须单独定制以反应组件间的依赖关系 解决方法：可以通过将集体行为封装在一个单独的中介者（mediator）对象中，如下图所设 类层次结构： 对象交互： 例如选择 ListBox 改变 EntryField 的内容 适用性一组对象以定义良好但复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。 一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。 想定制一个分布在多个类中的行为，而又不想生成太多的子类。 结构Mediator 中介者：定义和同事 Colleague 通信的接口 ConcreteMediator：了解并维护它的各个同事，处理它们之间的交互 Colleagueclass： 每个同事均了解其中介对象（例如持有一份 Mediator 实例的引用） 每个同事通过中介的接口与其他同事通信 同事向一个中介者对象发送和接收请求。中介者在各同事间适当地转发请求以实现协作行为
优缺点将各 Colleague 解耦 简化了对象协议：用 Mediator 和各 Colleague 间的一对多交互来代替多对多交互，更易于理解、维护和扩展。 对对象如何协作进行了抽象：将中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象各自本身的行为转移到它们之间的交互上来。 使控制集中化：中介者模式将交互的复杂性变为中介者的复杂性，这可能导致中介者本身复杂而难以维护 实现简单情形下无需定义抽象中介类：当各 Colleague 仅与一个 Mediator 一起工作时，没有必要定义一个抽象的 Mediator 类 Colleague-Mediator 通信：当一个感兴趣的事件发生时， Colleague 必须与其 Mediator 通信，这有两种实现方法： 使用 Observer（5.7） 模式，将 Mediator 实现为一个 Observer，各 Colleague 作为 Subject 一旦 Subject 状态改变就发送通知给 Mediator Mediator 将该事件向所有其他 Colleague 转发 在 Mediator 中定义一个特殊的通知接口，各 Colleague 在通信时直接调用该接口 相关模式Facade（4.5）与中介者的不同之处在于：
Facade 是对一个对象子系统进行抽象，从而提供了一个更为方便的接口。它的协议是单向的，即 Facade 对象对这个子系统类提出请求，但反之则不行。 Mediator 提供了各 Colleague 对象不支持或不能支持的协作行为，而且协议是多向的。 Colleague 可使用 Observer（5.7）模式与 Mediator 通信。
  </content></entry><entry><title>5.6-Memento「Token」-备忘录-行为型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.6-mementotoken-%E5%A4%87%E5%BF%98%E5%BD%95-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  目的在不破坏封装性的前提下捕获对象内部状态，在对象外保存该状态以备恢复
示例一个图形编辑器，它支持图形对象间的连线。用户可用一条直线连接两个矩形，而当用户移动任意一个矩形时，这两个矩形仍能保持连接 考虑需要撤销移动命令的情形：
备忘录存储内部状态：某个对象（称为原发器 originator ）保存自身某个瞬间的内部状态为备忘录对象。 对象可以导出内部状态为备忘录：当需要设置原发器的检查点时，取消操作机制会向原发器请求一个备忘录。 也可以依据备忘录恢复内部状态：需要恢复时，编辑器向原发器提供备忘录供其恢复内部状态 譬如计算图形对象连线的 ConstraintSolver 类，可以作为原发器：考虑取消移动的过程：
作为移动操作的一个副作用，编辑器向 ConstraintSolver 请求一个备忘录；ConstraintSolver 创建并返回一个备忘录 此后当用户取消移动操作时，编辑器将上次请求的备忘录送回给 ConstraintSolver ConstraintSolver 改变它的内部结构以精确地将它的等式和变量返回到它们各自先前的状态 结构Memento 备忘录：备忘录存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态 防止原发器以外的其他对象访问备忘录。备忘录实际上有两个接口， 管理者（caretaker）只能看到备忘录的窄接口——它只能将备忘录传递给其他对象。 原发器能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。 理想的情况是只允许生成本备忘录的那个原发器访问本备忘录的内部状态。 Originator 原发器：原发器创建一个备忘录，用以记录当前时刻它的内部状态；并使用备忘录恢复内部状态 Caretaker 管理者：负责保存好备忘录，但不能访问或修改备忘录的内容 管理者向原发器请求一个备忘录，保留一段时间后，在需要回退状态时将其送回给原发器
优缺点保护封装性 简化了原发器：Originator 无需考虑如何保存客户请求过的各个内部状态版本，版本管理由 caretaker 完成。 复制状态的开销：若生成备忘录时必须拷贝并存储大量的信息，或者客户非常频繁地创建备忘录和恢复原发器状态，可能会导致非常大的开销 可能需要使用增量修改 维护状态的开销：管理者负责删除它所维护的备忘录。然而，管理者不知道备忘录中有多少个状态。因此当存储备忘录时，一个本来很小的管理者可能会产生大量的存储开销 宽窄接口：在一些语言中可能难以保证只有原发器可访问备忘录的状态。 实现宽窄接口备忘录有两个接口：一个为原发器所使用的宽接口，一个为其他对象所使用的窄接口。
C++中，可将 Originator 作为 Memento 的一个友元，并使 Memento 宽接口为私有的，窄接口为公共的
增量改变如果备忘录的创建及其返回（给它们的原发器）的顺序是可预测的，备忘录可以仅存储原发器内部状态的增量改变。
例如，一个包含可撤销的命令的历史列表可使用备忘录：
存在一个历史列表，定义了一个特定的顺序，按照这个顺序命令可以被撤销和重做 备忘录可以只存储一个命令所产生的增量改变而不是它所影响的每一个对象的完整状态 相关模式Command（5.2）：命令可使用备忘录来为可撤销的操作维护状态。 Iterator（5.4）：如前所述，备忘录可用于迭代。
  </content></entry><entry><title>5.8-State「Object for state」-状态-状态对象-行为型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.8-stateobject-for-state-%E7%8A%B6%E6%80%81-%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  目的允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类
示例考虑一个表示网络连接的类 TCPConnection。 一个 TCPConnection 对象的状态处于若干不同状态之一：连接已建立（Established）、正在监听（Listening）、连接已关闭（Closed）。 当一个 TCPConnection 对象收到其他对象的请求时，它根据自身的当前状态做出不同的反应。 State 模式：
Key：引入了一个称为 TCPState 的抽象类来表示网络的连接状态： TCPState 类为各表示不同的操作状态的子类声明了一个公共接口。 TCPState 的子类实现与特定状态相关的行为 TCPConnection 类维护一个表示 TCP 连接当前状态的状态对象（TCPState 子类的实例） 将所有与状态相关的请求委托给该对象 一旦连接状态改变，TCPConnection 对象就会改变它所使用的状态对象 适用性一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。 State 模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化 结构Context：定义面向客户的接口 维护 ConcreteState 实例，表征当前状态 State：定义接口，封装与 Context 的特定状态相关的行为 ConcreteStateX：每一子类实现一个与 Context 的一个状态相关的行为 关联
Context 将与状态相关的请求委托给当前的 ConcreteState 对象处理。 Context 可将自身作为一个参数传递给处理该请求的状态对象。这使得状态对象在必要时可访问 Context。 Context 是客户使用的主要接口。客户可用状态对象来配置一个 Context，一旦一个 Context 配置完毕，它的客户不再需要直接与状态对象打交道。 Context 或 ConcreteState 子类都可决定哪个状态是另外一个的后继者，以及是在何种条件下进行状态转换。 效果将不同状态的行为分割开来：
不用 State 模式：使用数据值定义内部状态并且让 Context 操作来显式地检查这些数据。但这样将会使整个 Context 的实现中遍布看起来很相似的条件语句或 case 语句 使用 State 模式： 避免了庞大的条件语句 每一个状态转换和动作封装到一个类中，就把着眼点从执行状态提高到整个对象的状态。这将使代码结构化并使其意图更加清晰。 确保内部状态变量的一致性：从 Context 的角度看，状态转换是原子的——只需重新绑定一个 ConcreteState 实例，而无需为一组变量分别赋值。（仅以内部数据值来定义当前状态时，其状态仅表现为对一些变量的赋值）
State 对象可被共享：当状态以这种方式被共享时，它们必然是没有内部状态而只有行为的轻量级对象
  </content></entry><entry><title>5.9-Strategy「Policy」-策略模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.9-strategypolicy-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html"><![CDATA[  目的封装算法，使之可以独立于客户变化
示例文本分行有多种算法
若将程序类包含多种算法的代码，则使程序庞杂难维护 并非任何时候都需要所有的算法 若将算法嵌入客户程序内部，则变更算法将十分困难 Composition 维护对 Compositor 对象的一个引用。一旦 Composition 重新格式化它的文本，它就将这个职责转发给它的 Compositor 对象 Compositor 的子类实现具体的分行算法 适用性许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。 需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的 Strategy 类中以代替这些条件语句。 结构Strategy：算法的公共接口，Context 调用该接口 ConcreteStrategy：实现具体的策略 Context：用一个 ConcreteStrategy 对象来配置，维护一个 Strategy 实例，提供接口让 Strategy 访问其数据 Strategy 和 Context 相互作用以实现选定的算法。
客户仅与 Context 交互，通常创建并传递一个 Concrete-Strategy 对象给该 Context Context 将客户的请求转发给它的 Strategy。 当算法被调用时， Context 可以将该算法所需要的所有数据都传递给该 Strategy。 或者 Context 可以将自身作为一个参数传递给 Strategy 操作，以便 Strategy 在适当时候回调。 效果降低 Context 的复杂度：将算法和 Context 解耦合，易于切换算法 有利于复用算法 允许客户根据具体的时间/空间需要选择具体算法，但相应地，这意味着需要客户了解不同的 Strategy 之间的差异 消除了大量的条件判断：Context 内嵌多种算法/行为时，通常需要大量条件语句来选择合适的行为 缺陷 冗余参数：不同的 ConcreteStrategy 需要不同的参数集，因此抽象父类定义的接口必须提供这些参数集的并集。 这就意味着有时 Context 会创建和初始化一些永远不会用到的参数 如果存在这样的问题，那么将需要在 Strategy 和 Context 之间进行更紧密的耦合。 对象的数目：Strategy 增加了一个应用中的对象的数目。有时你可以将 Strategy 实现为可供各 Context 共享的无状态的对象来减少这一开销 实现关于 Strategy 和 Context 的接口这些接口必须让 ConcreteStrategy 能够有效地访问它所需要的 Context 中的任何数据，实现上有两种方法：
一种办法是让 Context 将数据放在参数中传递给 Strategy 操作 ——将数据发送给 Strategy 优点是：Context 和 Strategy 解耦合 缺点是：冗余参数，不同的 ConcreteStrategy 需要不同的参数集，因此抽象父类定义的接口必须提供这些参数集的并集。 另一种办法是让 Context 将自身作为一个参数传递给 Strategy ，或 Strategy 存储对它的 Context 的一个引用 优点是：避免了冗余参数，减少数据传递， 缺点是：使得 Strategy 和 Context 紧密耦合 Strategy 模板仅当下面条件满足时才可以使用：
可以在编译时选择 Strategy； 不需要在运行时改变 1 2 3 4 5 6 7 8 9 10 11 12 13 template &lt;class AStrategy&gt; class Context { void Operation() { theStrategy.DoAlgorithm(); } //... private: AStrategy theStrategy; }; class MyStrategy { public: void DoAlgorithm(); }; Context&lt;MyStrategy&gt; aContext; 默认行为Context 可以提供默认行为，仅当用户不满意默认行为时需要传入 Strategy
  ]]></content></entry><entry><title>5.2-Command「Action,Transaction」-命令模式-动作模式-事务模式-行为型模式</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.2-commandactiontransaction-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E4%BD%9C%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  目的将请求封装为对象，从而可用不同的请求：
对客户行为参数化 对请求排队或记录日志 支持可撤销的操作 示例有时必须向某对象提交请求，但并不知道关于被请求的操作或请求的接收者的任何信息。
例如，用户界面工具箱包括按钮和菜单这样的对象，它们执行请求响应用户输入。但工具箱不能显式地在按钮或菜单中实现该请求，因为只有使用工具箱的应用知道该由哪个对象做哪个操作。
命令模式通过将请求本身变成一个可存储对象来使工具箱对象可向未指定的应用对象提出请求。
关键是一个抽象的 Command 类，它定义了一个执行操作的接口。 Command 子类将接收者作为它的一个实例变量，并实现 Execute 操作 例如，PasteCommand 支持从剪贴板向一个文档（document）粘贴正文。 PasteCommand 的接收者是一个文档对象，该对象是实例化时提供的。Execute 操作将调用该 Document 的 Paste 操作。 MacroCommand：有时一个操作需要多个子操作完成，因此可定义 MacroCommand 执行一个命令序列
MacroCommand 没有明确的接收者，而序列中的命令各自定义其接收者。 优势：灵活。因为提交一个请求的对象仅需要知道如何提交它，而不需要知道该请求将会被如何执行。
一个应用如果想让一个菜单与一个按钮代表同一项功能，只需让它们共享相应具体 Command 子类的同一个实例即可 可以动态地替换 Command 对象，这可用于实现上下文有关的菜单 可通过将几个命令组成更大的命令的形式来支持命令脚本 适用性抽象出待执行的动作以参数化某对象（Command 模式是回调机制的一个面向对象的替代品） 在不同的时刻指定、排列和执行请求。一个 Command 对象可以有一个与初始请求无关的生存期。 支持取消操作：Command 的 Excute 操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。 支持修改日志：当系统崩溃后，可从磁盘中重新读入记录下来的命令并用 Execute 操作重新执行它们。（Command 接口中需添加装载操作和存储操作） 用构建在原语操作上的高层操作构造一个系统：在支持事务（transaction）的信息系统中，一个事务封装了对数据的一组变动。 Command 模式提供了对事务进行建模的方法。 结构Command：操作的接口 ConcreteCommand：将一个接收者对象绑定于一个动作，调用接收者相应的操作，以实现 Execute Invoker（示例中的MenuItem）：要求该命令执行这个请求 Receiver（示例中的 Document）：知道如何实施与执行一个请求相关的操作 工作流程：
Client 创建一个 ConcreteCommand 对象并指定它的 Receiver 对象。 某 Invoker 对象存储该 ConcreteCommand 对象 该 Invoker 通过调用 Command 对象的 Execute 操作来提交一个请求 若该命令是可撤销的，ConcreteCommand 就在执行 Excute 操作之前存储当前状态以用于取消该命令。 ConcreteCommand 对象调用它的 Receiver 的一些操作以执行该请求。 优缺点将调用操作的对象与知道如何实现该操作的对象解耦。 可将多个命令装配成一个组合命令（一般说来，组合命令是 Composite 模式的一个实例） 增加新的 Command 很容易，因为这无须改变已有的类 实现Command 的能力大小： 一个极端是它仅确定一个接收者和执行该请求的动作。 另一个极端是它自己实现所有功能，根本不需要额外的接收者对象：当需要定义与已有的类无关的命令，或没有合适的接收者，或一个命令隐式地知道它的接收者时使用 在这两个极端间的情况是命令对象有足够的信息可以动态地找到它们的接收者。 支持撤销（undo）和重做（redo）： Command 需要提供 Undo 操作 ConcreteCommand 类可能需要存储额外的状态信息，包括： 接收者对象，它真正执行处理该请求的各操作。 接收者执行的操作的参数。 如果处理请求的操作会改变接收者对象中的某些值，那么这些值也必须先存储起来。 接收者还必须提供一些操作，以使该命令可将接收者恢复到它先前的状态。 命令列表：若要支持多级的撤销和重做，就需要有一个已被执行命令的历史列表 向后遍历该列表并逆向执行（reverse-executing）命令是撤销它们的结果 向前遍历并执行命令是重执行它们。 拷贝命令：有时可能不得不将一个可撤销的命令在它可以被放入历史列表之前先拷贝下来：如果命令的状态在各次调用之间会发生变化，那就必须进行拷贝以区分相同命令的不同调用，反之则无需拷贝，存储引用即可。 例如，一个删除选定对象的删除命令（DeleteCommand）在它每次被执行时，必须存储不同的对象集合。因此该删除命令对象在执行后必须被拷贝，并且将该拷贝放入历史列表中 避免撤销操作过程中的错误积累：由于命令的重复执行、取消执行和重执行的过程中可能会积累错误，以致一个应用的状态最终偏离初始值。这就有必要在 Command 中存入更多的信息，以保证这些对象可被精确地复原成它们的初始状态。 使用 C++模板：对不能被撤销和不需要参数的命令，可使用 C++模板来实现，这样可以避免为每一种动作和接收者都创建一个 Command 子类 相关模式Composite（4.3）可用来实现宏命令。 Memento（5.6）可用来保持某个状态，命令用这一状态来取消它的效果。 在被放入历史列表前必须被拷贝的命令起到一种原型（参见 Prototype（3.4））的作用。   </content></entry><entry><title>5.7-Observer「publish-subscribe,dependent」-观察者-发布订阅-依赖</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.7-observerpublish-subscribedependent-%E8%A7%82%E5%AF%9F%E8%80%85-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85-%E4%BE%9D%E8%B5%96/</url><categories><category>设计模式</category></categories><tags><tag><no value=/></tags><content type="html">  用途定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新
示例将一个系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的一致性
视图 View 依赖数据 Data 一个目标 Subject/publish 可以有任意数目的依赖它的观察者 Observer/subscribe。一旦目标的状态发生改变，所有的观察者都得到通知。 收到通知后，每个观察者都将查询目标以使其状态与目标的状态同步。
适用性一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中，以使它们可以各自独立地改变和复用。 对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。 一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，你不希望这些对象是紧密耦合的。 结构Subject（目标） 目标知道它的观察者。可以有任意多个观察者观察同一个目标。 状态改变时，通知自身的观察者 提供注册和删除观察者对象的接口。 ConcreteSubject（具体目标）： 为观察者提供获取/设置状态的接口 Observer（观察者）：为那些在目标发生改变时需要获得通知的对象定义一个更新接口。 ConcreteObserver： 维护一个指向 ConcreteSubject 对象的引用 存储状态，这些状态与 ConcreteSubject 的状态保持一致 实现 Observer 的更新接口，以使自身状态与目标的状态保持一致。 交互时序
当 ConcreteSubject 发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者。 在得到一个具体目标的改变通知后，ConcreteObserver 对象可向目标对象查询信息。ConcreteObserver 使用这些信息使它的状态与目标对象的状态一致。 注意：
观察者 setState 后不会立即更新自身状态，而是等到被 notify 后再更新 Notify 不总是由目标对象调用，它也可被一个观察者或其他对象调用。 效果Publisher 和 Subscriber 彼此独立，允许增加新的观察者而无需对现有的 Publisher/Subscriber 做任何修改
低耦合：一个目标所知道的仅仅是它有一系列观察者，每个都符合抽象的 Observer 类的简单接口，而不知道其具体类型 一个处于较低层次的目标对象可与一个处于较高层次的观察者通信并通知它，反之则不行： 如果目标和观察者混在一块，那么得到的对象要么横贯两个层次（违反了层次性），要么必须放在这两层的某一层中（这可能会损害层次抽象）。 支持广播通信 意外的更新： 在目标上一个看似无害的的操作可能会引起一系列对观察者以及依赖于这些观察者的对象的更新 如果依赖准则的定义或维护不当，常常会引起错误的更新，这种错误通常很难捕捉。 实现创建目标到其观察者之间的映射：
方法 1：显式地在目标中保存对它自身持有的观察者的引用 方法 2：用一个关联查找机制（例如一个 hash 表）来维护目标到观察者的映射 观察多个目标：例如，一个表格对象可能依赖于多个数据源
此时，必须扩展 Update 接口以使观察者知道是哪个目标送来的通知（目标对象可以简单地将自己作为 Update 操作的一个参数，让观察者知道应去检查哪个目标。） 谁触发更新：客户和发布者均可以调用发布者的 Notify 来触发更新：
由目标对象的 setState 操作在自身状态被改变后自动调用 Notify 优点是客户不需要记住要在目标对象上调用 Notify 缺点是多个连续的操作会产生多次连续的更新 让客户负责在适当的时候调用 Notify 客户可以在一系列的状态改变完成后一次性地触发更新 缺点是给客户增加了触发更新的责任。由于客户可能会忘记调用 Notify，这种方式较易出错 避免对已删除发布者的空引用：当一个目标被删除时，让它通知它的观察者将对该目标的引用复位
确保发出通知时，自身状态完成更新：Publisher 的子类重载操作时容易出现这种问题：
你可以用抽象的 Subject 类中的模板方法（Template Method（5.10））发送通知来避免这种错误。定义那些子类可以重定义的原语操作，并将 Notify 作为模板方法中的最后一个操作，这样当子类重定义了 Subject 的操作时，还可以保证该对象的状态是自身一致的。 日志应当记录是哪个 Publisher 触发了该操作 观察者模式的实现经常需要让目标广播关于其改变的其他一些信息：
Push 模式：目标向观察者发送关于改变的详细信息，而不管它们需要与否。 强调的是目标不知道它的观察者 推模型可能使得观察者相对难以复用，因为目标对观察者的假定可能并不总是正确的 Pull 模式：目标除最小通知外什么也不送出，而在此之后由观察者显式地向目标询问细节 假定目标知道一些观察者需要的信息 效率可能更差 订阅特定事件：可以扩展目标的注册接口，让各观察者注册为仅对特定事件感兴趣，以提高更新的效率
支持这种做法的一种途径是，使用目标对象的方面 （aspect）的概念： 1 2 void Subject::Attach(Observer *,Aspect &amp;amp;interest); void Observer::Update(Subject *,Aspect &amp;amp;interest); 封装复杂的更新语义: 当目标和观察者间的依赖关系特别复杂时，可能需要一个维护这些关系的对象。我们称这样的对象为更改管理器 ChangeManager。 ChangeManager 主要负责三方面工作： - 它将一个目标映射到它的观察者并提供一个接口来维护这个映射。这就不需要由目标来维护对其观察者的引用，反之亦然。 - 它定义一个特定的更新策略。 - 根据一个目标的请求，它更新所有依赖于这个目标的观察者。
例如，如果一个操作涉及对几个相互依赖的目标进行改动，就必须保证仅在所有的目标都已更改完毕后，才一次性地通知它们的观察者，而不是每个目标都通知观察者。
结合目标类和观察者类：不支持多重继承的语言通常不单独定义 Subject 和 Observer 类，而是将它们的接口结合到一个类中。这就允许你定义一个既是目标又是观察者的对象，而不需要多重继承
  </content></entry><entry><title>LeetCode刷题记录-动态规划</title><url>/post/work/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E9%A2%98%E7%9B%AE/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url><categories><category>算法与数据结构</category></categories><tags><tag><no value=/></tags><content type="html"><![CDATA[  动态规划问题这类问题的求解思路是：
先尝试有 Cache 的暴力搜索，列出递推式 将上述搜索转化为使用 dp 数组的方法 70. 爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
$$ \begin{cases} f(n)=f(n-2)+f(n-1)\ f(&amp;lt;=0)=0,f(1)=1,f(2)=2 \end{cases} $$
746. 使用最小花费爬楼梯给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。 输入：cost = [10,15,20] 输出：15 解释：你将从下标为 1 的台阶开始。
支付 15 ，向上爬两个台阶，到达楼梯顶部。 总花费为 15 。 62. 不同路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？
设 $dp[i][j]$ 表示由 (0,0) 走到(i,j)的路径数目 $$ \begin{cases} dp[i][j]=0,i&amp;lt;=0||j&amp;lt;=0\ dp[i][j]=dp[i][j-1]+dp[i-1][j] \end{cases} $$
343. 整数拆分给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &amp;gt;= 2 ），并使这些整数的乘积最大化。 返回 你可以获得的最大乘积 。
$dp[i]$ 表示拆解i可得的最大乘积 递推时，数 a 可拆解为 b+c 的形式，而 b，c 可以进一步拆分（其最大乘积为 $dp[b]$ ），也可以不拆分 $$ \begin{cases} dp[2]=1\ dp[i] =max(max(i-1,dp[i-1])1,,\dots,,max(2,dp[2])(i-2)) \end{cases} $$ 96. 不同的二叉搜索树#mark/leetcode 未做出来
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题 …  ]]></content></entry></search>