<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CSMTC Blog</title><link>/</link><description>Recent content on CSMTC Blog</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Wed, 12 Mar 2025 02:54:36 +0000</lastBuildDate><atom:link href="/rss.xml" rel="self" type="application/rss+xml"/><item><title>5.1-ChainOfResponsibility-职责链-行为型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.1-ChainOfResponsibility-%E8%81%8C%E8%B4%A3%E9%93%BE-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 09 Sep 2024 20:03:09 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.1-ChainOfResponsibility-%E8%81%8C%E8%B4%A3%E9%93%BE-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h3 id="目的">目的
&lt;a class="header-anchor" href="#%e7%9b%ae%e7%9a%84">&lt;/a>
&lt;/h3>&lt;p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。
对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。&lt;/p>
&lt;h3 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h3>&lt;p>GUI 中的组件 Tips：用户界面对象中会有一个对象来处理帮助请求，至于是哪一个对象则取决于上下文以及可用的帮助具体到何种程度。&lt;/p>
&lt;ul>
&lt;li>问题：提交帮助请求的对象（如按钮）并不明确知道谁是最终提供帮助的对象，需要有一种办法将提交帮助请求的对象与可能提供帮助信息的对象解耦（decouple）&lt;/li>
&lt;li>&lt;strong>职责链&lt;/strong>：将可选的处理对象排成一条链，链中对象收到请求的对象要么亲自处理它，要么转发给链中的下一个候选者。
&lt;ul>
&lt;li>要求：每个在链上的对象都有一致的&lt;em>处理请求&lt;/em>和&lt;em>访问链上后继者&lt;/em>的接口
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.1-ChainOfResponsibility-%E8%81%8C%E8%B4%A3%E9%93%BE-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-04-55-745.png" alt="" />
按钮、对话框和应用类都使用 HelpHandler 操作来处理帮助请求。 HelpHandler 的 HandleHelp 操作默认是将请求转发给后继。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="适用性">适用性
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>有多个对象可以处理一个请求，哪个对象处理该请求运行时自动确定。&lt;/li>
&lt;li>你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。&lt;/li>
&lt;li>可处理一个请求的对象集合应被动态指定。&lt;/li>
&lt;/ul>
&lt;h3 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.1-ChainOfResponsibility-%E8%81%8C%E8%B4%A3%E9%93%BE-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-05-58-915.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>Handler：定义处理请求的接口
&lt;ul>
&lt;li>可选：实现后继链（successor）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ConcreteHandler：处理请求，访问后继对象
&lt;ul>
&lt;li>若能处理就处理，否则就将请求转发给后继&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Client：向职责链上的 ConcreteHandler 提交请求
当客户提交一个请求时，请求沿链传递直至有一个 ConcreteHandler 对象负责处理它。&lt;/li>
&lt;/ul>
&lt;p>请求传递过程可能如下
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.1-ChainOfResponsibility-%E8%81%8C%E8%B4%A3%E9%93%BE-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-06-26-399.png" alt="" />&lt;/p>
&lt;h3 id="优缺点">优缺点
&lt;a class="header-anchor" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>降低耦合度：该模式使得一个对象无须知道是其他哪一个对象处理其请求。
&lt;ul>
&lt;li>接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>增强了给对象指派职责的灵活性：可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的那些职责。&lt;/li>
&lt;li>不保证处理：既然一个请求没有明确的接收者，那么就不能保证它一定会被处理（可能一直到链尾都没有对象处理请求）&lt;/li>
&lt;/ul>
&lt;h3 id="实现">实现
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0">&lt;/a>
&lt;/h3>&lt;h4 id="实现后继者链的方法">实现后继者链的方法
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0%e5%90%8e%e7%bb%a7%e8%80%85%e9%93%be%e7%9a%84%e6%96%b9%e6%b3%95">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>使用已有的链接&lt;/strong>：例如，在一个部分–整体层次结构中，父构件引用可定义一个部件的后继者。窗口组件（widget）结构可能早已有这样的链接。&lt;/li>
&lt;li>&lt;strong>由 Handler 实现&lt;/strong>：如果没有已有的引用可定义一个链，则必须构建新的链。这种情况下 Handler 不仅定义该请求的接口，通常也维护后继者
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.1-ChainOfResponsibility-%E8%81%8C%E8%B4%A3%E9%93%BE-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-22-13-233.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h4 id="表示请求">表示请求
&lt;a class="header-anchor" href="#%e8%a1%a8%e7%a4%ba%e8%af%b7%e6%b1%82">&lt;/a>
&lt;/h4>&lt;ol>
&lt;li>请求是一个硬编码的（hard-coded）操作调用（如上述 HelpHandler）&lt;/li>
&lt;li>使用一个处理函数，这个函数以一个请求码（如一个整型常数或一个字符串）为参数
&lt;ol>
&lt;li>无法用类型安全的方法来传递请求参数，因此它们必须被手工打包和解包。显然，相对于直接调用一个操作来说它不太安全。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>解决上述参数传递问题&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>使用独立的请求对象来封装请求参数&lt;/li>
&lt;li>Request 可定义一个访问器（accessor）函数以返回该类的标识符（对于支持的语言，可使用运行时的类型信息）&lt;/li>
&lt;li>子类可通过重定义 HandleRequest 扩展该分派函数。子类只处理它感兴趣的请求，其他的请求被转发给父类。
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.1-ChainOfResponsibility-%E8%81%8C%E8%B4%A3%E9%93%BE-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-26-57-404.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h3 id="相关模式">相关模式
&lt;a class="header-anchor" href="#%e7%9b%b8%e5%85%b3%e6%a8%a1%e5%bc%8f">&lt;/a>
&lt;/h3>&lt;p>职责链常与 Composite（4.3）一起使用。这种情况下，一个构件的父构件可作为它的后继。&lt;/p></description></item><item><title>LeetCode刷题记录-贪心</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E9%A2%98%E7%9B%AE/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E8%B4%AA%E5%BF%83/</link><pubDate>Thu, 25 Jul 2024 17:13:03 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E9%A2%98%E7%9B%AE/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E8%B4%AA%E5%BF%83/</guid><description>&lt;h3 id="55-跳跃游戏">
&lt;a href="https://leetcode.cn/problems/jump-game/description/" title="55. 跳跃游戏" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 55. 跳跃游戏
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>
&lt;a class="header-anchor" href="#55-%e8%b7%b3%e8%b7%83%e6%b8%b8%e6%88%8f">&lt;/a>
&lt;/h3>&lt;p>给你一个非负整数数组 &lt;code>nums&lt;/code> ，你最初位于数组的 &lt;strong>第一个下标&lt;/strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标，如果可以，返回 &lt;code>true&lt;/code> ；否则，返回 &lt;code>false&lt;/code> 。&lt;/p>
&lt;p>核心策略：看覆盖范围，覆盖范围内⼀定是可以跳过来的，不⽤管是怎么跳的。问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点。&lt;/p>
&lt;h3 id="45-跳跃游戏-ii">
&lt;a href="https://leetcode.cn/problems/jump-game-ii/description" title="45. 跳跃游戏 II" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 45. 跳跃游戏 II
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>
&lt;a class="header-anchor" href="#45-%e8%b7%b3%e8%b7%83%e6%b8%b8%e6%88%8f-ii">&lt;/a>
&lt;/h3>&lt;p>给定一个长度为 &lt;code>n&lt;/code> 的 &lt;strong>0 索引&lt;/strong>整数数组 &lt;code>nums&lt;/code>。初始位置为 &lt;code>nums[0]&lt;/code>。&lt;/p>
&lt;p>每个元素 &lt;code>nums[i]&lt;/code> 表示从索引 &lt;code>i&lt;/code> 向前跳转的最大长度。换句话说，如果你在 &lt;code>nums[i]&lt;/code> 处，你可以跳转到任意 &lt;code>nums[i + j]&lt;/code> 处:&lt;/p>
&lt;ul>
&lt;li>&lt;code>0 &amp;lt;= j &amp;lt;= nums[i]&lt;/code> &lt;/li>
&lt;li>&lt;code>i + j &amp;lt; n&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>返回到达 &lt;code>nums[n - 1]&lt;/code> 的最小跳跃次数。生成的测试用例保证可以到达 &lt;code>nums[n - 1]&lt;/code> 。&lt;/p>
&lt;p>核心策略：同样看覆盖范围，当前下标达到了上次跳跃的最大位置，且未达到终点，则需要跳跃一次。&lt;/p>

&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt" id="hl-0-1">&lt;a class="lnlinks" href="#hl-0-1"> 1&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-2">&lt;a class="lnlinks" href="#hl-0-2"> 2&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-3">&lt;a class="lnlinks" href="#hl-0-3"> 3&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-4">&lt;a class="lnlinks" href="#hl-0-4"> 4&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-5">&lt;a class="lnlinks" href="#hl-0-5"> 5&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-6">&lt;a class="lnlinks" href="#hl-0-6"> 6&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-7">&lt;a class="lnlinks" href="#hl-0-7"> 7&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-8">&lt;a class="lnlinks" href="#hl-0-8"> 8&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-9">&lt;a class="lnlinks" href="#hl-0-9"> 9&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-10">&lt;a class="lnlinks" href="#hl-0-10">10&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-11">&lt;a class="lnlinks" href="#hl-0-11">11&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-12">&lt;a class="lnlinks" href="#hl-0-12">12&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-13">&lt;a class="lnlinks" href="#hl-0-13">13&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-14">&lt;a class="lnlinks" href="#hl-0-14">14&lt;/a>
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">max_pos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">last_max_pos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">cnt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">target&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 跳跃的情况：当前下标达到了上次跳跃的最大位置，且未达到终点，则需要跳跃一次
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">max_pos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">max_pos&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">last_max_pos&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">++&lt;/span>&lt;span class="n">cnt&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">last_max_pos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">max_pos&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">last_max_pos&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>

&lt;h3 id="134-加油站">
&lt;a href="https://leetcode.cn/problems/gas-station/" title="134. 加油站" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 134. 加油站
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>
&lt;a class="header-anchor" href="#134-%e5%8a%a0%e6%b2%b9%e7%ab%99">&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt" id="hl-1-1">&lt;a class="lnlinks" href="#hl-1-1">1&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-1-2">&lt;a class="lnlinks" href="#hl-1-2">2&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-1-3">&lt;a class="lnlinks" href="#hl-1-3">3&lt;/a>
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">情况⼀：如果 gas 的总和⼩于 cost 总和，那么⽆论从哪⾥出发，⼀定是跑不了⼀圈的
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">情况⼆：rest[i] = gas[i]-cost[i]为⼀天剩下的油，i 从 0 开始计算累加到最后⼀站，如果累加没有出现负数，说明从 0 出发，油就没有断过，那么 0 就是起点。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">情况三：如果累加的最⼩值是负数，汽⻋就要从⾮0 节点出发，从后向前，看哪个节点能把这个负数填平，能把这个负数填平的节点就是出发节点。&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>

&lt;h3 id="376-摆动序列">
&lt;a href="https://leetcode.cn/problems/wiggle-subsequence/" title="376. 摆动序列" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 376. 摆动序列
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>
&lt;a class="header-anchor" href="#376-%e6%91%86%e5%8a%a8%e5%ba%8f%e5%88%97">&lt;/a>
&lt;/h3>&lt;p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。&lt;/p></description></item><item><title>「HARD」4.6-Flyweight-享元-结构型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/HARD4.6-Flyweight-%E4%BA%AB%E5%85%83-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/HARD4.6-Flyweight-%E4%BA%AB%E5%85%83-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h3 id="用途">用途
&lt;a class="header-anchor" href="#%e7%94%a8%e9%80%94">&lt;/a>
&lt;/h3>&lt;p>运用共享技术支持大量细粒度的对象&lt;strong>节约空间&lt;/strong>&lt;/p>
&lt;h3 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h3>&lt;p>面向对象中创建一个对象的开销是相对较大的，有时这是难以承受的。例如文本编辑器若将每个字符均采用一个相应的对象描述将产生巨大的内存负担&lt;/p>
&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/%E3%80%8CHARD%E3%80%8D4.6-Flyweight-%E4%BA%AB%E5%85%83-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-03_12-30-49-151.png" alt="" />
Flyweight 模式描述了如何共享对象，使得可以细粒度地使用它们而不需要高昂的代价&lt;/p>
&lt;ul>
&lt;li>说明：flyweight 是一个共享对象，它可以同时在多个&lt;strong>场景/上下文&lt;/strong>（context）中使用，并且在每个场景中 flyweight 都可以作为一个独立的对象
&lt;ul>
&lt;li>关于内部与外部状态：
&lt;ul>
&lt;li>flyweight 存储独立于上下文的信息，在每个场景中使用&lt;/li>
&lt;li>有关上下文的外部状态由用户在合适的时候提供&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Flyweight 模式对那些通常由于数量太大而难以用对象来表示的概念或实体进行建模
&lt;ul>
&lt;li>例如文本编辑器中：
&lt;ul>
&lt;li>逻辑上&lt;em>每个&lt;/em>字符对应一个对象&lt;/li>
&lt;li>物理上&lt;em>每种&lt;/em>字符共享同一个 Flyweight 对象（存储在 Flyweight 对象池），只存储字符编码，不存储相应的图元位置和字体等信息&lt;/li>
&lt;li>行对象绘制字符对象时传递位置、字体等信息
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/%E3%80%8CHARD%E3%80%8D4.6-Flyweight-%E4%BA%AB%E5%85%83-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-03_12-42-29-654.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="适用性">适用性
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h3>&lt;p>条件全部成立时使用：&lt;/p>
&lt;ul>
&lt;li>一个应用程序使用了大量的对象，完全由于使用大量的对象造成很大的存储开销。&lt;/li>
&lt;li>对象的大多数状态都可变为外部状态。&lt;/li>
&lt;li>如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。&lt;/li>
&lt;li>应用程序不依赖于对象标识（共享对象 a equal b 会返回真值）。&lt;/li>
&lt;/ul>
&lt;h3 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/%E3%80%8CHARD%E3%80%8D4.6-Flyweight-%E4%BA%AB%E5%85%83-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-03_12-45-43-193.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>FlyweightFactory：创建、管理、共享 Flyweight 对象。（采用懒加载创建）&lt;/li>
&lt;li>Flyweight（示例中的 Glyph）：描述接口，通过这个接口 flyweight 可以接受并作用于外部状态。&lt;/li>
&lt;li>ConcreteFlyweight（示例中的 Character）：（&lt;em>该对象必须是可共享的&lt;/em>）实现 Flyweight 接口，并为内部状态（如果有的话）分配存储空间。&lt;/li>
&lt;li>UnsharedConcreteFlyweight（示例中的 Row、Column）：并非所有的 Flyweight 子类都需要被共享&lt;/li>
&lt;li>Client
&lt;ul>
&lt;li>引用 Flyweight&lt;/li>
&lt;li>计算/存储 Flyweight 的外部状态&lt;/li>
&lt;li>用户不应直接对 ConcreteFlyweight 类进行实例化，而&lt;em>只能从 FlyweightFactory 对象得到 ConcreteFlyweight 对象&lt;/em>，这可以保证对它们适当地进行共享。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="优缺点">优缺点
&lt;a class="header-anchor" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>增大时间开销：传输、查找和/或计算外部状态都会产生运行时开销&lt;/li>
&lt;li>减少空间开销：
&lt;ul>
&lt;li>共享的 flyweight 越多，存储节约也就越多。&lt;/li>
&lt;li>节约量随着共享状态的增多而增大。&lt;/li>
&lt;li>当对象使用大量的内部及外部状态，并且外部状态是计算出来的而非存储的时候，节约量将达到最大。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Flyweight 模式经常和 Composite（4.3）模式结合起来表示一个层次式结构，这一层次式结构是一个共享叶结点的图。&lt;/p></description></item><item><title>「HARD」5.3-Interpreter-解释器-行为型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/HARD5.3-Interpreter-%E8%A7%A3%E9%87%8A%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/HARD5.3-Interpreter-%E8%A7%A3%E9%87%8A%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h3 id="目的">目的
&lt;a class="header-anchor" href="#%e7%9b%ae%e7%9a%84">&lt;/a>
&lt;/h3>&lt;p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。&lt;/p>
&lt;h3 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h3>&lt;p>考虑解析简单的正则表达式，包含如下文法：&lt;/p>
&lt;ul>
&lt;li>expression ::= literal | alternation | sequence | repretition | &amp;rsquo; (&amp;rsquo; expression &amp;lsquo;)&amp;rsquo;&lt;/li>
&lt;li>alternation ::= expression &amp;lsquo;|&amp;rsquo; expression&lt;/li>
&lt;li>sequence ::= expression &amp;lsquo;&amp;amp;&amp;rsquo; expression&lt;/li>
&lt;li>repetition ::= expression &amp;lsquo;*&amp;rsquo;&lt;/li>
&lt;li>literal ::= &amp;lsquo;a&amp;rsquo; | &amp;lsquo;b&amp;rsquo; | &amp;lsquo;c&amp;rsquo;&amp;hellip; ( &amp;lsquo;a&amp;rsquo; | &amp;lsquo;b&amp;rsquo; | &amp;lsquo;c&amp;rsquo;&amp;hellip;)*&lt;/li>
&lt;/ul>
&lt;p>使用类去描述上述文法：
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/%E3%80%8CHARD%E3%80%8D5.3-Interpreter-%E8%A7%A3%E9%87%8A%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-09_15-09-53-908.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>每个用这个文法定义的正则表达式都被表示为一个由这些类的实例构成的抽象语法树 AST&lt;/li>
&lt;li>如果我们为 RegularExpression 的每一子类都定义解释（Interpret） 操作，那么就得到了这些正则表达式的一个解释器。&lt;/li>
&lt;/ul>
&lt;h3 id="适用性">适用性
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h3>&lt;p>当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。&lt;/p>
&lt;p>最好具备以下特性：&lt;/p>
&lt;ul>
&lt;li>文法简单。对于复杂的文法，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无须构建抽象语法树即可解释表达式，这样可以节省空间而且还可能节省时间。&lt;/li>
&lt;li>不太在意效率。最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下，转换器也可用解释器模式实现，该模式仍是有用的。&lt;/li>
&lt;/ul>
&lt;h3 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/%E3%80%8CHARD%E3%80%8D5.3-Interpreter-%E8%A7%A3%E9%87%8A%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-09_15-17-01-856.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>AbstractExpression：定义抽象的解释操作&lt;/li>
&lt;li>TerminalExpression：（终结符表达式，如 LiteralExpression）
&lt;ul>
&lt;li>定义终结符的解释操作&lt;/li>
&lt;li>&lt;strong>终结符&lt;/strong>：指的是文法中的运算单元，也就是不可再分的最小元素。&lt;/li>
&lt;li>文法中的每一个终结符都有一个具体终结表达式与之相对应。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>NonterminalExpression（非终结符表达式，如 AlternationExpression、Repetition-Expression、SequenceExpressions）：
&lt;ul>
&lt;li>文法中的每一条规则 R::=R1 R2…Rn 都需要一个 NonterminalExpression 类&lt;/li>
&lt;li>为从 R1 到 Rn 的每个符号都维护一个 AbstractExpression 类型的实例变量。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Context（上下文）：解释器之外的全局信息&lt;/li>
&lt;li>Client（客户）：构建（或被给定）表示该文法定义的语言中一个特定的句子的抽象语法树。
&lt;ul>
&lt;li>最后调用解释操作&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>工作流程&lt;/strong>：Client 构建（或被给定）一个句子，它是 NonterminalExpression 和 TerminalExpression 的实例的一个抽象语法树。然后初始化上下文并调用解释操作。&lt;/p></description></item><item><title>1-设计模式概论</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%AE%BA/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%AE%BA/</guid><description>&lt;h2 id="定义和组成要素">定义和组成要素
&lt;a class="header-anchor" href="#%e5%ae%9a%e4%b9%89%e5%92%8c%e7%bb%84%e6%88%90%e8%a6%81%e7%b4%a0">&lt;/a>
&lt;/h2>&lt;p>&lt;strong>什么是模式&lt;/strong>：每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。&lt;/p>
&lt;p>&lt;strong>模式的组成要素&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>模式名&lt;/li>
&lt;li>问题：何时使用该模式&lt;/li>
&lt;li>解决方案：描述设计的组成成分、相互关系和协作方式&lt;/li>
&lt;li>影响：描述模式应当权衡的问题，对系统的灵活性、扩充性或可移植性的影响。如时空复杂度、语言和实现&lt;/li>
&lt;/ul>
&lt;p>由 MVC, Model-View-Controller 理解“模式”：&lt;/p>
&lt;ul>
&lt;li>什么是 MVC：
&lt;ul>
&lt;li>模型：应用对象&lt;/li>
&lt;li>视图：对象在屏幕上的显示&lt;/li>
&lt;li>控制器：定义用户界面对用户输入的响应方式&lt;/li>
&lt;li>MVC 通过建立订阅-通知协议来分离视图和模型。一旦模型的数据发生变化，模型将通知有关的视图，每个视图相应地得到刷新自己的机会。允许为一个模型提供不同的多个视图表现形式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>推广 1：模型和视图分离→订阅对象和发布对象分离
&lt;ul>
&lt;li>将对象分离，使得一个对象的改变能够影响另一些对象，而这个对象并不需要知道那些被影响的对象的细节。这个更一般的设计被描述成 Observer&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>推广 2：MVC 允许视图嵌套，将组合 View 与单个 View 平等对待→将对象组视为一般对象
&lt;ul>
&lt;li>将一些对象划为一组，并将该组对象当作一个对象来使用。这个设计被描述为 Composite&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>设计模式的组成要素&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>模式名、别名和分类&lt;/li>
&lt;li>意图：解决什么问题&lt;/li>
&lt;li>动机：说明一个设计问题以及如何用模式中的类、对象来解决该问题的特定情景&lt;/li>
&lt;li>适用性&lt;/li>
&lt;li>结构：类图和交互图（描述对象之间的请求序列和协作关系）&lt;/li>
&lt;li>参与者：涉及的类和/或对象以及它们各自的职责。&lt;/li>
&lt;li>协作：模式的参与者怎样协作以实现它们的职责。&lt;/li>
&lt;li>影响&lt;/li>
&lt;li>实现：实现时的注意事项&lt;/li>
&lt;li>实际应用案例&lt;/li>
&lt;li>相关模式&lt;/li>
&lt;/ul>
&lt;h2 id="设计模式目录">设计模式目录
&lt;a class="header-anchor" href="#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e7%9b%ae%e5%bd%95">&lt;/a>
&lt;/h2>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%AE%BA/image-2023-09-20_19-23-19-922.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>
&lt;p>创建型模式与对象的创建有关；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>结构型模式处理类或对象的组合；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>行为型模式对类或对象怎样交互和怎样分配职责进行描述。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>类模式：处理类和子类的关系&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对象模式：处理对象间的关系&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>设计模式中可变的部分&lt;/strong>：
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%AE%BA/image-2023-09-20_20-49-05-817.png" alt="" />&lt;/p>
&lt;ol>
&lt;li>Abstract Factory（3.1）：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。&lt;/li>
&lt;li>Adapter（4.1）：将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/li>
&lt;li>Bridge（4.2）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。&lt;/li>
&lt;li>Builder（3.2）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/li>
&lt;li>Chain of Responsibility（5.1）：解除请求的发送者和接收者之间的耦合，使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。Command（5.2）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。&lt;/li>
&lt;li>Composite（4.3）：将对象组合成树形结构以表示“部分–整体”的层次结构。Composite 使得客户对单个对象和组合对象的使用具有一致性。&lt;/li>
&lt;li>Decorator（4.4）：动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator 模式比生成子类方式更为灵活。&lt;/li>
&lt;li>Facade（4.5）：为子系统中的一组接口提供一个一致的界面， Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。&lt;/li>
&lt;li>Factory Method（3.3）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method 使一个类的实例化延迟到其子类。&lt;/li>
&lt;li>Flyweight（4.6）：运用共享技术有效地支持大量细粒度的对象。&lt;/li>
&lt;li>Interpreter（5.3）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。Iterator（5.4）：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。&lt;/li>
&lt;li>Mediator（5.5）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。&lt;/li>
&lt;li>Memento（5.6）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。&lt;/li>
&lt;li>Observer（5.7）：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。&lt;/li>
&lt;li>Prototype（3.4）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。&lt;/li>
&lt;li>Proxy（4.7）：为其他对象提供一个代理以控制对这个对象的访问。&lt;/li>
&lt;li>Singleton（3.5）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。State（5.8）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。&lt;/li>
&lt;li>Strategy（5.9）：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。&lt;/li>
&lt;li>Template Method（5.10）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/li>
&lt;li>Visitor（5.11）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。&lt;/li>
&lt;/ol>
&lt;h2 id="面向对象设计的步骤">面向对象设计的步骤
&lt;a class="header-anchor" href="#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e8%ae%be%e8%ae%a1%e7%9a%84%e6%ad%a5%e9%aa%a4">&lt;/a>
&lt;/h2>&lt;h3 id="设计原则">设计原则
&lt;a class="header-anchor" href="#%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99">&lt;/a>
&lt;/h3>&lt;p>&lt;strong>对接口编程，而不是对实现编程&lt;/strong>。这可以极大地减少子系统实现之间的相互依赖关系：&lt;/p></description></item><item><title>3-创建型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h1 id="创建型模式">创建型模式
&lt;a class="header-anchor" href="#%e5%88%9b%e5%bb%ba%e5%9e%8b%e6%a8%a1%e5%bc%8f">&lt;/a>
&lt;/h1>&lt;p>创建型设计模式抽象了实例化过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。&lt;/p>
&lt;p>&lt;strong>主要特征&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>第一，它们都将关于该系统使用哪些具体的类的信息封装起来。&lt;/li>
&lt;li>第二，它们隐藏了这些类的实例是如何被创建和放在一起的。&lt;/li>
&lt;/ul>
&lt;p>常用的对象创建型模式有：&lt;/p>
&lt;ul>
&lt;li>抽象工厂 Abstract Factory：
&lt;a href="./3.1-AbstractFactory%E3%80%8CKit%E3%80%8D-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.md#" title="3.1-AbstractFactory「Kit」-抽象工厂-创建型模式" >
 3.1-AbstractFactory「Kit」-抽象工厂-创建型模式
 
&lt;/a>&lt;/li>
&lt;li>生成器 Builder&lt;/li>
&lt;li>工厂方法 Factory Method&lt;/li>
&lt;li>原型 Prototype&lt;/li>
&lt;li>单例模式 Singleton&lt;/li>
&lt;/ul>
&lt;h2 id="背景">背景
&lt;a class="header-anchor" href="#%e8%83%8c%e6%99%af">&lt;/a>
&lt;/h2>&lt;h3 id="游戏中的功能类">游戏中的功能类
&lt;a class="header-anchor" href="#%e6%b8%b8%e6%88%8f%e4%b8%ad%e7%9a%84%e5%8a%9f%e8%83%bd%e7%b1%bb">&lt;/a>
&lt;/h3>&lt;p>以一个地牢探索游戏创建房间为例，讨论 5 种模式。涉及的主要类有：&lt;/p>

&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt" id="hl-0-1">&lt;a class="lnlinks" href="#hl-0-1"> 1&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-2">&lt;a class="lnlinks" href="#hl-0-2"> 2&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-3">&lt;a class="lnlinks" href="#hl-0-3"> 3&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-4">&lt;a class="lnlinks" href="#hl-0-4"> 4&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-5">&lt;a class="lnlinks" href="#hl-0-5"> 5&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-6">&lt;a class="lnlinks" href="#hl-0-6"> 6&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-7">&lt;a class="lnlinks" href="#hl-0-7"> 7&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-8">&lt;a class="lnlinks" href="#hl-0-8"> 8&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-9">&lt;a class="lnlinks" href="#hl-0-9"> 9&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-10">&lt;a class="lnlinks" href="#hl-0-10">10&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-11">&lt;a class="lnlinks" href="#hl-0-11">11&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-12">&lt;a class="lnlinks" href="#hl-0-12">12&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-13">&lt;a class="lnlinks" href="#hl-0-13">13&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-14">&lt;a class="lnlinks" href="#hl-0-14">14&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-15">&lt;a class="lnlinks" href="#hl-0-15">15&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-16">&lt;a class="lnlinks" href="#hl-0-16">16&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-17">&lt;a class="lnlinks" href="#hl-0-17">17&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-18">&lt;a class="lnlinks" href="#hl-0-18">18&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-19">&lt;a class="lnlinks" href="#hl-0-19">19&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-20">&lt;a class="lnlinks" href="#hl-0-20">20&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-21">&lt;a class="lnlinks" href="#hl-0-21">21&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-22">&lt;a class="lnlinks" href="#hl-0-22">22&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-23">&lt;a class="lnlinks" href="#hl-0-23">23&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-24">&lt;a class="lnlinks" href="#hl-0-24">24&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-25">&lt;a class="lnlinks" href="#hl-0-25">25&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-26">&lt;a class="lnlinks" href="#hl-0-26">26&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-27">&lt;a class="lnlinks" href="#hl-0-27">27&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-28">&lt;a class="lnlinks" href="#hl-0-28">28&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-29">&lt;a class="lnlinks" href="#hl-0-29">29&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-30">&lt;a class="lnlinks" href="#hl-0-30">30&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-31">&lt;a class="lnlinks" href="#hl-0-31">31&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-32">&lt;a class="lnlinks" href="#hl-0-32">32&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-33">&lt;a class="lnlinks" href="#hl-0-33">33&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-34">&lt;a class="lnlinks" href="#hl-0-34">34&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-35">&lt;a class="lnlinks" href="#hl-0-35">35&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-36">&lt;a class="lnlinks" href="#hl-0-36">36&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-37">&lt;a class="lnlinks" href="#hl-0-37">37&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-38">&lt;a class="lnlinks" href="#hl-0-38">38&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-0-39">&lt;a class="lnlinks" href="#hl-0-39">39&lt;/a>
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 房间的方向，北南东西
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">enum&lt;/span> &lt;span class="nc">Direction&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">E&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">W&lt;/span>&lt;span class="p">};&lt;/span> 
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 创建迷宫的类
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">MazeGame&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="n">Maze&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">CreateMaze&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 地图点的抽象类，有Room，Wall，Door3个子类
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">MapSite&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="k">virtual&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">Enter&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 进入该地点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 墙
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">Wall&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="k">public&lt;/span> &lt;span class="n">MapSite&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="k">virtual&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">Enter&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 门
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">Door&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="k">public&lt;/span> &lt;span class="n">MapSite&lt;/span>&lt;span class="p">{&lt;/span> 
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="n">Door&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Room&lt;/span>&lt;span class="o">*=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">Room&lt;/span>&lt;span class="o">*=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="n">Room&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">OtherSideFrom&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Room&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="k">virtual&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">Enter&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="n">Room&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">_room1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">_room2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="kt">bool&lt;/span> &lt;span class="n">_isOpen&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 房间
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">Room&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="k">public&lt;/span> &lt;span class="n">MapSite&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="n">Room&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">roomNo&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="n">MapSite&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nf">GetSide&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Direction&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">const&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="k">virtual&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">Enter&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="n">MapSite&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">_sides&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">// 东西南北的地图点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>	&lt;span class="kt">int&lt;/span> &lt;span class="n">_roomNumber&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 房间编号
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>

&lt;h3 id="各类创建方法比较">各类创建方法比较
&lt;a class="header-anchor" href="#%e5%90%84%e7%b1%bb%e5%88%9b%e5%bb%ba%e6%96%b9%e6%b3%95%e6%af%94%e8%be%83">&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt" id="hl-1-1">&lt;a class="lnlinks" href="#hl-1-1"> 1&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-1-2">&lt;a class="lnlinks" href="#hl-1-2"> 2&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-1-3">&lt;a class="lnlinks" href="#hl-1-3"> 3&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-1-4">&lt;a class="lnlinks" href="#hl-1-4"> 4&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-1-5">&lt;a class="lnlinks" href="#hl-1-5"> 5&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-1-6">&lt;a class="lnlinks" href="#hl-1-6"> 6&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-1-7">&lt;a class="lnlinks" href="#hl-1-7"> 7&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-1-8">&lt;a class="lnlinks" href="#hl-1-8"> 8&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-1-9">&lt;a class="lnlinks" href="#hl-1-9"> 9&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-1-10">&lt;a class="lnlinks" href="#hl-1-10">10&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-1-11">&lt;a class="lnlinks" href="#hl-1-11">11&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-1-12">&lt;a class="lnlinks" href="#hl-1-12">12&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-1-13">&lt;a class="lnlinks" href="#hl-1-13">13&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-1-14">&lt;a class="lnlinks" href="#hl-1-14">14&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-1-15">&lt;a class="lnlinks" href="#hl-1-15">15&lt;/a>
&lt;/span>&lt;span class="lnt" id="hl-1-16">&lt;a class="lnlinks" href="#hl-1-16">16&lt;/a>
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 硬编码
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">Maze&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">MazeGame&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">CreateMaze&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="n">Maze&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">aMazenew&lt;/span> &lt;span class="n">Maze&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="n">Room&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">r1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Room&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span> 
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="n">Room&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">r2&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nf">Room&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="n">Door&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">theDoor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Door&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rl&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">r2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="n">aMaze&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">AddRoom&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">r1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="n">aMaze&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">AddRoom&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">r2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="n">r1&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">SetSide&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">North&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Wall&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="n">rl&lt;/span>&lt;span class="err">—&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="n">SetSide&lt;/span>&lt;span class="err">（&lt;/span>&lt;span class="n">East&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">theDoor&lt;/span>&lt;span class="err">）；&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="n">rl&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">SetSide&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">South&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Wall&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="n">rl&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">SetSide&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">West&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Wall&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="n">r2&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">SetSide&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">North&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Wal1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="n">r2&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">SetSide&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">East&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Wall&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> 
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="n">r2&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">SetSide&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">South&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Wall&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="n">r2&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">SetSide&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">West&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">theDoor&lt;/span>&lt;span class="p">)&lt;/span> 
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">	&lt;span class="k">return&lt;/span> &lt;span class="n">aMaze&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>

&lt;ul>
&lt;li>硬编码方式的主要缺点是不灵活，修改迷宫的布局意味着修改这个实例方法，这容易产生错误也不易于复用&lt;/li>
&lt;li>&lt;strong>Factory Method&lt;/strong>：CreateMaze 调用虚函数而不是构造器来创建它需要的房间、墙壁和门，那么你可以创建一个 MazeGame 的子类并重定义这些虚函数，从而改变被实例化的类。&lt;/li>
&lt;li>&lt;strong>Abstract Factory&lt;/strong>：传递一个对象给 CreateMaze 作为参数来创建房间、墙壁和门，那么你可以传递不同的参数来改变房间、墙壁和门的类&lt;/li>
&lt;li>&lt;strong>Builder&lt;/strong>：传递一个对象给 CreateMaze，这个对象可以在它所建造的迷宫中使用增加房间、墙壁和门的操作来全面创建一个新的迷宫，那么你可以使用继承来改变迷宫的一些部分或迷宫的建造方式。&lt;/li>
&lt;li>&lt;strong>Prototype&lt;/strong>：CreateMaze 由多种原型的房间、墙壁和门对象参数化，它复制并将这些对象增加到迷宫中，那么你可以用不同的对象替换这些原型对象以改变迷宫的构成。&lt;/li>
&lt;li>&lt;strong>Singleton&lt;/strong>：可以保证每个游戏中仅有一个迷宫而且所有的游戏对象都可以迅速访问它——不需要求助于全局变
量或函数。Singleton 也使得迷宫易于扩展或替换，且不需要变动已有的代码。&lt;/li>
&lt;/ul>
&lt;h2 id="讨论">讨论
&lt;a class="header-anchor" href="#%e8%ae%a8%e8%ae%ba">&lt;/a>
&lt;/h2>&lt;p>对系统进行参数化主要有 2 种方法：&lt;/p></description></item><item><title>3.1-AbstractFactory「Kit」-抽象工厂-创建型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.1-AbstractFactoryKit-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.1-AbstractFactoryKit-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;p>又称 &lt;strong>Kit&lt;/strong>&lt;/p>
&lt;h2 id="abstract-factory-抽象工厂">Abstract Factory 抽象工厂
&lt;a class="header-anchor" href="#abstract-factory-%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82">&lt;/a>
&lt;/h2>&lt;h4 id="用途">用途
&lt;a class="header-anchor" href="#%e7%94%a8%e9%80%94">&lt;/a>
&lt;/h4>&lt;p>用途：提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。&lt;/p>
&lt;h4 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h4>&lt;p>示例： GUI 程序需要支持 Motif 和 PW 这 2 种视窗标准：&lt;/p>
&lt;ul>
&lt;li>抽象工厂提供 CreateXXX 接口生产抽象组件 XXX，用户调用该函数获取 XXX 组件&lt;/li>
&lt;li>抽象工厂的具象工厂子类实现 CreateXXX 接口，生产自己这种类型的具象组件 YYXXX（YYWindow，YYScrollBar,&amp;hellip;）&lt;/li>
&lt;li>&lt;strong>客户仅与抽象类定义的接口交互，而不使用特定的具体类的接口&lt;/strong>
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/3.1-AbstractFactory%E3%80%8CKit%E3%80%8D-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-24_13-01-22-769.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h4 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h4>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/3.1-AbstractFactory%E3%80%8CKit%E3%80%8D-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-24_15-12-44-904.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>AbstractFactory：声明一个创建抽象产品对象的接口&lt;/li>
&lt;li>ConcreteFactory：实现创建具体产品对象的操作&lt;/li>
&lt;li>AbstractProduct：为一类产品对象声明一个接口&lt;/li>
&lt;li>ConcreteProduct：定义具体的产品对象，实现 AbstractProduct 接口&lt;/li>
&lt;li>Client：只使用 Abstract 的接口&lt;/li>
&lt;/ul>
&lt;p>协作过程：&lt;/p>
&lt;ul>
&lt;li>通常在运行时创建一个 ConcreteFactroy 类的实例。这一具体的工厂创建具有特定实现的产品对象。为创建不同的产品对象，客户应使用不同的具体工厂。
&lt;ul>
&lt;li>说明：简单实现时，AbstractFactory 和 ConcreteFactory 可以合二为一&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>AbstractFactory 将产品对象的创建延迟到它的 ConcreteFactory 子类。&lt;/li>
&lt;/ul>
&lt;h4 id="适用条件">适用条件
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%9d%a1%e4%bb%b6">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>系统独立于产品的创建、组合和表示&lt;/li>
&lt;li>系统包含多个产品系列，用其中的一种进行表示&lt;/li>
&lt;li>强调一个系列的产品设计，以便联合使用&lt;/li>
&lt;li>提供产品类库，但是只显示接口而隐藏实现&lt;/li>
&lt;/ul>
&lt;h4 id="优缺点">优缺点
&lt;a class="header-anchor" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>优点：
&lt;ul>
&lt;li>分离实现：工厂封装了创建产品对象的责任和过程，将客户和具体实现分离。客户只操作抽象接口，避免硬编码具体的类名&lt;/li>
&lt;li>易于切换产品系列&lt;/li>
&lt;li>有利于产品风格的一致性：应用一次只能使用同一个系列中的对象，这有利于维护一致性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点：
&lt;ul>
&lt;li>难以支持新种类的产品：AbstractFactory 定义了可被其创建的产品集合，创建新产品意味着需要扩展 AbstractFactory 和其&lt;em>所有&lt;/em>子类的接口。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="实现的注意事项">实现的注意事项
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0%e7%9a%84%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>工厂使用单例模式&lt;/strong>：一个应用通常每个产品系列只需要一个 ConcreteFactory 实例&lt;/li>
&lt;li>&lt;strong>创建产品的方法&lt;/strong>：
&lt;ul>
&lt;li>常用方法：为每个产品定义一个工厂方法，具体的工厂为每个工厂重载该工厂方法以指定产品&lt;/li>
&lt;li>简化具体工厂类：可以使用 Prototype 模式实现具体工厂。具体工厂使用产品系列中每一个产品的原型实例来初始化，且它通过复制它的原型来创建新的产品。基于原型的方法&lt;em>使得并非每个新的产品系列都需要一个新的具体工厂类。&lt;/em>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>可扩展的工厂&lt;/strong>：
&lt;ul>
&lt;li>通常增加一种新的产品要求改变 AbstractFactory 的接口以及所有与它相关的类。&lt;/li>
&lt;li>一个更灵活但不太安全的设计是给创建对象的操作增加一个参数（例如类标识符，字符串，整数索引等）该参数指定了将被创建的对象的种类。使用这种方法 AbstractFactory 只需要一个“Make”操作和一个指示要创建对象的种类的参数。&lt;/li>
&lt;li>客户需要使用执行&lt;strong>向下类型转换&lt;/strong>（downcast，例如 cpp 中的 dynamic_cast）才能获得具体的子类型，而这会带来安全隐患&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>3.2-Builder-生成器模式-创建型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.2-Builder-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.2-Builder-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h1 id="builder">Builder
&lt;a class="header-anchor" href="#builder">&lt;/a>
&lt;/h1>&lt;h4 id="用途">用途
&lt;a class="header-anchor" href="#%e7%94%a8%e9%80%94">&lt;/a>
&lt;/h4>&lt;p>将复杂对象的构建和表示分离，使得同样的构建过程可以创建不同的表示。&lt;/p>
&lt;h4 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h4>&lt;p>考虑应用场景：将 RTF 文档转换为其他多种文本格式，对于任意结构的文档，可能的转换数目是无限的&lt;/p>
&lt;ul>
&lt;li>
&lt;p>RTFReader：分析文档，每次遇到一个标记时发送请求调用 TextConverter 转换该标记。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>TextConverter 对象负责进行数据转换以及用特定格式表示该标记，其子类对不同转换和不同格式进行特殊处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>解释：Builder 模式描述了所有这些关系。&lt;/p>
&lt;ul>
&lt;li>每一个转换器类在该模式中被称为生成器（builder），而阅读器则称为导向器（director）&lt;/li>
&lt;li>Builder 模式将分析文本格式的算法（即 RTF 文档的语法分析程序）与描述怎样创建和表示一个转换后格式的算法分离开来。这使我们可以复用 RTFReader 的语法分析算法，根据 RTF 文档创建不同的文本表示——仅需使用不同的 TextConverter 的子类配置该 RTFReader 即可。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/3.2-Builder-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-24_15-03-46-060.png" alt="" />&lt;/p>
&lt;h4 id="适用情形">适用情形
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%83%85%e5%bd%a2">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。&lt;/li>
&lt;li>当构造过程必须允许被构造的对象有不同的表示时。&lt;/li>
&lt;/ul>
&lt;h4 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h4>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/3.2-Builder-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-24_15-12-06-045.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>Builder：创建 Product 的抽象接口&lt;/li>
&lt;li>ConcreteBuilder：（ASCIIConverter、TeXConverter、 TextWidgetConverter）
&lt;ul>
&lt;li>构造和装配产品的各个部件&lt;/li>
&lt;li>定义和跟踪自己创建的表示&lt;/li>
&lt;li>提供检索产品的接口（例如，GetASCIIText 和 GetTextWidget）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Director：（RTFReader）构造使用 builder 接口的对象&lt;/li>
&lt;li>Product（ASCIIText、TeXText、TextWidget）
&lt;ul>
&lt;li>被构建的复杂对象，具体生成器创建该产品的内部表示并定义装配过程&lt;/li>
&lt;li>包含定义组件部件的类，以及将这些部件装配成最终产品的接口&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>协作过程如下&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>客户创建 Director 对象，并用它所想要的 Builder 对象进行配置。&lt;/li>
&lt;li>一旦生成了产品部件，导向器就会通知生成器。&lt;/li>
&lt;li>生成器处理导向器的请求，并将部件添加到该产品中。&lt;/li>
&lt;li>客户从生成器中获取最终产品。
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/3.2-Builder-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-24_15-22-11-430.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h4 id="优缺点">优缺点
&lt;a class="header-anchor" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>可以改变一个产品的内部表示：因为产品是通过抽象接口构造的，你在改变该产品的内部表示时所要做的只是定义一个新的生成器。&lt;/li>
&lt;li>将构造代码和表示代码分开：Builder 模式通过封装一个复杂对象的创建和表示方式提高了对象的模块性。构造代码只写一次，不同的 Director 可以反复复用构造代码在同一套部件集合上创建不同的表示&lt;/li>
&lt;li>可以精细控制构造过程：它是在导向器的控制下一步一步构造产品的。仅当该产品完成时导向器才从生成器中取回它。&lt;/li>
&lt;/ul>
&lt;h4 id="实现">实现
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0">&lt;/a>
&lt;/h4>&lt;p>通常有一个抽象的 Builder 类为导向器可能要求创建的&lt;em>每一个构件&lt;/em>定义一个操作（默认什么都不做）。
一个 ConcreteBuilder 类对它有兴趣创建的构件重定义这些操作。&lt;/p></description></item><item><title>3.3-FactoryMethod-工厂方法-创建型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.3-FactoryMethod-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.3-FactoryMethod-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;p>又称&lt;strong>虚构造器（virtual constructor）&lt;/strong>&lt;/p>
&lt;h4 id="用途">用途
&lt;a class="header-anchor" href="#%e7%94%a8%e9%80%94">&lt;/a>
&lt;/h4>&lt;p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method 使一个类的实例化延迟到其子类。&lt;/p>
&lt;h4 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h4>&lt;p>框架用抽象类定义和维护对象之间的关系。
Eg：框架定义了 App 抽象类，它包含一个 Document 抽象内容。但是 App 类无法确认应当实例化哪个 Document 的具象子类：&lt;/p>
&lt;ul>
&lt;li>方法：
&lt;ul>
&lt;li>抽象类 App 中提供接口 CreateDocument。&lt;/li>
&lt;li>具象 App 子类重载接口 CreateDocument，并创建自己要用到具象的 Document
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/3.3-FactoryMethod-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-26_10-24-30-852.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h4>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/3.3-FactoryMethod-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-26_10-35-30-090.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>Product：定义工厂方法要创建的对象的类别&lt;/li>
&lt;li>ConcreteProduct：&lt;/li>
&lt;li>Creator：抽象工厂，定义用于返回 Product 的工厂方法（接口），该接口可以是抽象的，也可以提供一个默认实现返回缺省的 ConcreteProduct&lt;/li>
&lt;li>ConcreteCreator：具象工厂，重载工厂接口&lt;/li>
&lt;/ul>
&lt;p>说明：&lt;/p>
&lt;ul>
&lt;li>Creator 依赖子类重载工厂方法以返回合适的 ConcreteProduct&lt;/li>
&lt;/ul>
&lt;h4 id="适用性">适用性
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>一个类不确定自己要创建的对象的类&lt;/li>
&lt;li>一个类希望由子类指定自己创建的对象的类&lt;/li>
&lt;/ul>
&lt;h4 id="优缺点">优缺点
&lt;a class="header-anchor" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">&lt;/a>
&lt;/h4>&lt;p>工厂方法的潜在缺点：客户可能只是为了创建一个特定的 ConcreteProduct 对象，就必须创建 Creator 的新的子类&lt;/p>
&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>工厂方法不再将应用相关的类绑定到程序代码中。代码只处理 Product 接口&lt;/li>
&lt;li>可以为子类提供钩子 Hook（提供合理的缺省实现）&lt;/li>
&lt;li>可以连接平行的类层次：例如图形类和用户的操作是平行的类层次，而抽象父类 Figure 可以提供 CreateManipulator 方法连接 Manipulate 类层次，并为子类提供默认实现
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/3.3-FactoryMethod-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-26_10-48-51-858.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h4 id="实现">实现
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>Creator 可以是抽象类，也可以是提供了缺省实现的具象类
&lt;ul>
&lt;li>抽象类不提供默认实现，可以避免不得不实例化不可预见类的问题&lt;/li>
&lt;li>具象类：这种情况比直接 new 个实例具有更好的灵活性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>参数化工厂方法：这允许工厂方法创建多种类型的对象。工厂方法可以采用一个标识（指定要被创建的对象种类的参数）区分不同类型的对象（这些对象都必须是 Product 的子类型）
&lt;ul>
&lt;li>重定义一个参数化的工厂方法使你可以简单而有选择性地扩展或改变一个 Creator 生产的产品。注意最后需要调用父类的 Create&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>命名约定&lt;/strong>：使用命名约定是一个好习惯，它可以清楚地说明你正在使用工厂方法
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/3.3-FactoryMethod-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-26_10-58-47-704.png" alt="600" />&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Cpp 中的工厂方法&lt;/strong>：&lt;/p></description></item><item><title>3.4-Prototype-原型-创建型方法</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.4-Prototype-%E5%8E%9F%E5%9E%8B-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%96%B9%E6%B3%95/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.4-Prototype-%E5%8E%9F%E5%9E%8B-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%96%B9%E6%B3%95/</guid><description>&lt;h4 id="用途">用途
&lt;a class="header-anchor" href="#%e7%94%a8%e9%80%94">&lt;/a>
&lt;/h4>&lt;p>用原型指定创建对象的种类，拷贝这些原型创建新的对象&lt;/p>
&lt;h4 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h4>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/3.4-Prototype-%E5%8E%9F%E5%9E%8B-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%96%B9%E6%B3%95/image-2023-09-26_12-32-40-532.png" alt="" />&lt;/p>
&lt;p>例如采用工具类操作图形元素：&lt;/p>
&lt;ul>
&lt;li>若为每个图形元素创建相应工具类，则过于冗杂&lt;/li>
&lt;li>采用原型方法：
&lt;ul>
&lt;li>工具类拷贝一个图形元素的实例，添加到文档中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="适用情形">适用情形
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%83%85%e5%bd%a2">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>当一个系统应该独立于它的产品创建、构成和表示时。&lt;/li>
&lt;li>当要实例化的类是在运行时指定时，例如，通过动态装载。&lt;/li>
&lt;li>为了避免创建一个与产品类层次平行的工厂类层次时。&lt;/li>
&lt;li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。&lt;/li>
&lt;/ul>
&lt;h4 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>Prototype：提供 clone 自身的接口
&lt;ul>
&lt;li>ConcretePrototype：实现 clone 的操作&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Client：用原型 clone 自身从而创建新的对象&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/3.4-Prototype-%E5%8E%9F%E5%9E%8B-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%96%B9%E6%B3%95/image-2023-09-26_12-51-54-343.png" alt="" />&lt;/p>
&lt;h4 id="优缺点">优缺点
&lt;a class="header-anchor" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">&lt;/a>
&lt;/h4>&lt;p>Prototype 有许多与 Abstract Factory（3.1）和 Builder（3.2）一样的效果：&lt;/p>
&lt;ul>
&lt;li>它对客户隐藏了具体的产品类，因此减少了客户知道的名字的数目。&lt;/li>
&lt;li>此外，这些模式使客户无须改变自身代码即可使用与特定应用相关的类。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>其他优点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>运行时增加和删除产品&lt;/li>
&lt;li>改变值以指定新对象：高度动态的系统允许你通过对象组合定义新的行为——例如，通过为一个对象变量指定值——并且不定义新的类。
克隆一个原型类似于实例化一个类。Prototype 模式可以极大地减少系统所需要的类的数目。&lt;/li>
&lt;li>改变结构以指定新对象许多应用由部件和子部件来创建对象。
&lt;ul>
&lt;li>例如电路设计编辑器就是由子电路来构造电路的：这样的应用通常允许你实例化复杂的、用户定义的结构，比方说，一次又一次地重复使用一个特定的子电路。&lt;/li>
&lt;li>Prototype 模式只要组合电路对象将 Clone 实现为一个深拷贝（deep copy），具有不同结构的电路就可以是原型了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>减少子类的构造：Factory Method（3.3）经常产生一个与产品类层次平行的 Creator 类层次。Prototype 模式使得你克隆一个原型而不是请求一个工厂方法去产生一个新的对象，因此你根本不需要 Creator 类层次。
&lt;ul>
&lt;li>主要适用于像 C++这样不将类作为一级类对象的语言（通常是&lt;strong>静态语言&lt;/strong>）。这种语言中，类本身不是一种对象，而是一种特殊的数据类型或结构。这意味着，这种语言中，类不能被当作参数传递给函数，也不能被当作返回值返回，也不能被动态创建或销毁。例如，C++中的类只能在编译时静态定义，而不能在运行时动态生成或修改。&lt;/li>
&lt;li>相反，将&lt;strong>类作为一级类对象&lt;/strong>的语言（通常是&lt;strong>动态语言&lt;/strong>），则&lt;em>认为类本身也是一种对象&lt;/em>，只不过是用来创建其他对象的对象。这意味着，这种语言中，类可以被当作参数传递给函数，也可以被当作返回值返回，也可以被动态创建或销毁。例如，Python 就是一种将类作为一级类对象的语言，因为 Python 中的类是由 type 这个元类创建的对象，而且可以在运行时动态生成或修改2。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>用类动态配置应用一些运行时环境允许你动态地将类装载到应用中。
&lt;ul>
&lt;li>一个希望创建动态载入类的实例的应用不能静态引用类的构造器，而应该由运行环境在载入时自动创建每个类的实例，并用原型管理器来注册这个实例。这样应用就可以向原型管理器请求新装载的类的实例，这些类原本并没有和程序相连接。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺陷&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>每个 Prototype 子类必须实现 clone 操作，而这可能非常困难&lt;/li>
&lt;/ul>
&lt;h4 id="实现">实现
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0">&lt;/a>
&lt;/h4>&lt;p>在像 C++这样的静态语言中，类不是对象，并且运行时只能得到很少或者得不到任何类型信息，所以 Prototype 特别有用。
相反，在类似 Python 这样的语言中意义不大，语言自带等价于原型的东西（类对象、元类等）&lt;/p></description></item><item><title>3.5-Singleton-单例模式-对象创建模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.5-Singleton-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.5-Singleton-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h4 id="用途">用途
&lt;a class="header-anchor" href="#%e7%94%a8%e9%80%94">&lt;/a>
&lt;/h4>&lt;p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/p>
&lt;h4 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h4>&lt;p>让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求），并且它可以提供一个访问该实例的方法。&lt;/p>
&lt;h4 id="适用性">适用性
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>唯一实例应该是通过子类化可扩展的，并且客户应该无须更改代码就能使用一个扩展的实例时。&lt;/li>
&lt;li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。&lt;/li>
&lt;/ul>
&lt;h4 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h4>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/3.5-Singleton-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/image-2023-09-26_16-43-30-386.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>Singleton：定义一个 Instance 操作，允许客户访问它的唯一实例。Instance 是
一个类操作（即 Java 中的一个类方法和 C++中的一个静态成员函数）。&lt;/li>
&lt;/ul>
&lt;p>客户只能通过 Singleton 的 Instance 操作访问一个 Singleton 的实例。&lt;/p>
&lt;h4 id="优缺点">优缺点
&lt;a class="header-anchor" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>对唯一实例的受控访问：因为 Singleton 类封装它的唯一实例，所以它可以严格地控制客户怎样以及何时访问它。&lt;/li>
&lt;li>缩小名字空间：Singleton 模式是对全局变量的一种改进，它避免了那些存储唯一实例的全局变量污染名字空间。&lt;/li>
&lt;li>允许可变数目的实例：可以用相同的方法来控制应用所使用的实例的数目。&lt;/li>
&lt;li>比类操作更灵活：C++等语言不允许一个类有多个实例。此外，C++中的静态成员函数不是虚函数，因此子类不能多态地重定义它们。&lt;/li>
&lt;/ul>
&lt;h4 id="实现">实现
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0">&lt;/a>
&lt;/h4>&lt;p>类型定义
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/3.5-Singleton-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/image-2023-09-26_16-50-46-325.png" alt="" />
方法实现：在 Instance 方法中懒初始化
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/3.5-Singleton-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/image-2023-09-26_16-50-57-559.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>
&lt;p>注意构造器是 protected 的。试图直接实例化 Singleton 的客户将得到一个编译时的错误信息。这就保证了仅有一个实例可以被创建。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>关于全局变量法实现单例的问题：在 C++中将单件定义为一个全局或静态的对象，然后依赖于自动初始化，这是不够的（应当使用静态成员函数）。这是因为：&lt;/p>
&lt;ul>
&lt;li>不能保证静态对象只有一个实例会被声明&lt;/li>
&lt;li>可能没有足够的信息在静态初始化时实例化每一个单件（例如初始化需要依赖后续计算的值）&lt;/li>
&lt;li>C++没有定义转换单元（translation unit）上全局对象的构造器的调用顺序&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>使用一个 Singleton 创建不同类型的单件&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>由 Singleton 派生子类，不同子类用于创建不同单件&lt;/li>
&lt;li>对于 C++：在不同的文件中创建不同的 Singleton 的实现，然后链接时选择具体的实现。&lt;/li>
&lt;li>使用&lt;strong>单件注册表&lt;/strong>：可能的 Singleton 类的集合不是由 Instance 定义的。Singleton 类可以根据名字在一个众所周知的注册表（存储实例名→单件实例的映射关系）中注册它们的单件实例；收到请求时查询相应的单件（如果存在的话）并返回它。
&lt;ul>
&lt;li>Singleton 类不再负责创建单件。它的主要职责是使得供选择的单件对象在系统中可以被访问&lt;/li>
&lt;li>所有可能的 Singleton 子类的实例都必须被创建，否则它们不会被注册
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/3.5-Singleton-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/image-2023-09-26_17-15-24-020.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>如何实现单件注册表：&lt;/p></description></item><item><title>4-结构型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;p>结构型模式涉及如何组合类和对象以获得更大的结构。结构型类模式采用继承机制来组合接口或实现。&lt;/p>
&lt;ul>
&lt;li>Adapter（4.1）模式：适配器使得一个接口（adaptee 的接口）与其他接口兼容，从而给出多个不同接口的统一抽象。&lt;/li>
&lt;li>Composite（4.3）模式是结构型对象模式的一个实例。它描述了如何构造一个类层次式结构，这一结构由两种类型的对象（基元对象和组合对象）所对应的类构成。
&lt;ul>
&lt;li>组合对象可以组合基元对象和组合对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Flyweight（4.6）模式为了共享对象定义了一个结构。
&lt;ul>
&lt;li>为何要求对象共享：效率和一致性。使用对象共享而不是进行对象复制，可以节省大量的空间资源。&lt;/li>
&lt;li>Flyweight 的对象共享机制主要强调对象的空间效率&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Proxy（4.7）模式中，proxy 对象作为其他对象的一个方便的替代或占位符。
&lt;ul>
&lt;li>它可以在局部空间中代表一个远程地址空间中的对象&lt;/li>
&lt;li>可以表示一个要求被加载的较大的对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="011-adapterfacade-与-bridge">0.1.1 Adapter、Facade 与 Bridge
&lt;a class="header-anchor" href="#011-adapterfacade-%e4%b8%8e-bridge">&lt;/a>
&lt;/h3>&lt;p>Adapter 与 Bridge共同点：&lt;/p>
&lt;ul>
&lt;li>都给另一对象提供了一定程度的间接性，因而有利于系统的灵活性&lt;/li>
&lt;li>都涉及从自身以外的一个接口向这个对象转发请求。&lt;/li>
&lt;/ul>
&lt;p>Adapter 与 Bridge不同点：&lt;/p>
&lt;ul>
&lt;li>用途：
&lt;ul>
&lt;li>Adapter 模式主要是为了解决两个已有接口之间不匹配的问题。它不考虑这些接口是怎样实现的，也不考虑它们各自可能会如何演化&lt;/li>
&lt;li>Bridge 模式则对抽象接口与它的（可能是多个）实现部分进行桥接。虽然这一模式允许你修改实现它的类，但是它仍然为用户提供了一个稳定的接口。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>阶段：
&lt;ul>
&lt;li>Adapter 模式在类已经设计好后实施，其目的一般是避免代码重复。此处耦合不可预见。&lt;/li>
&lt;li>Bridge 模式在设计类之前实施：一个抽象将有多个实现部分，并且抽象和实现两者是独立演化的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>facade 定义一个新的接口，而 Adapter 则复用一个原有的接口（适配器使两个已有的接口协同工作而非定义新的接口）&lt;/p>
&lt;h3 id="012-compositedecorator">0.1.2 Composite、Decorator
&lt;a class="header-anchor" href="#012-compositedecorator">&lt;/a>
&lt;/h3>&lt;p>Composite（4.3）模式和 Decorator（4.4）&lt;/p>
&lt;ul>
&lt;li>相同点：仅限于都是递归组合&lt;/li>
&lt;li>不同点：
&lt;ul>
&lt;li>Decorator 用于添加功能而不产生新的子类&lt;/li>
&lt;li>Composite 用于构造类&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>4.1-Adapter「wrapper」-适配器-结构型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.1-Adapterwrapper-%E9%80%82%E9%85%8D%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.1-Adapterwrapper-%E9%80%82%E9%85%8D%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;p>又称包装器（wrapper）&lt;/p>
&lt;h4 id="用途">用途
&lt;a class="header-anchor" href="#%e7%94%a8%e9%80%94">&lt;/a>
&lt;/h4>&lt;p>将一个类的接口转换成客户希望的另外一个接口。&lt;/p>
&lt;ul>
&lt;li>Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/li>
&lt;li>Adapter 经常还要负责提供那些被匹配的类所没有提供的功能&lt;/li>
&lt;/ul>
&lt;h4 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h4>&lt;p>已有类型 A 的接口和实现，考虑使之适配类型 B 的接口：&lt;/p>
&lt;ul>
&lt;li>类版本：继承 B 的接口和 A 的实现&lt;/li>
&lt;li>对象版本：类型 B 中存储一个类型 A 的实例，调用其接口实现类型 B 的自身接口&lt;/li>
&lt;/ul>
&lt;p>例如：有一个 TreeDisplay 窗口组件用于展示目录树，现在要展示继承层次树&lt;/p>
&lt;h4 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h4>&lt;p>类适配器：Adapter 同时继承 Target 和 Adaptee
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/4.1-Adapter%E3%80%8Cwrapper%E3%80%8D-%E9%80%82%E9%85%8D%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-28_15-07-30-553.png" alt="" />
对象适配器
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/4.1-Adapter%E3%80%8Cwrapper%E3%80%8D-%E9%80%82%E9%85%8D%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-28_15-08-24-490.png" alt="" />&lt;/p>
&lt;p>&lt;strong>参与者&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Target（Shape）：定义 Client 使用的与特定领域相关的接口。&lt;/li>
&lt;li>Client（DrawingEditor）：与符合 Target 接口的对象协同。&lt;/li>
&lt;li>Adaptee（TextView）：定义一个已经存在的接口，这个接口需要适配。&lt;/li>
&lt;li>Adapter（TextShape）：对 Adaptee 的接口与 Target 接口进行适配。&lt;/li>
&lt;/ul>
&lt;p>Client 调用 Adapter 的接口，然后 Adapter 调用 Adaptee 接口实现请求&lt;/p>
&lt;h4 id="适用情形">适用情形
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%83%85%e5%bd%a2">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>你想使用一个已经存在的类，而它的接口不符合你的需求。&lt;/li>
&lt;li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。&lt;/li>
&lt;li>（仅适用于对象 Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。&lt;/li>
&lt;/ul>
&lt;h4 id="优缺点">优缺点
&lt;a class="header-anchor" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">&lt;/a>
&lt;/h4>&lt;p>类适配器和对象适配器互有优缺点：&lt;/p>
&lt;ul>
&lt;li>类适配器
&lt;ul>
&lt;li>优点：Adapter 可以重定义 Adaptee 的部分行为，因为 Adapter 是 Adaptee 的一个子类。&lt;/li>
&lt;li>缺点：无法兼容该 Adaptee 的子类型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对象适配器
&lt;ul>
&lt;li>可以兼容 Adaptee 的子类型&lt;/li>
&lt;li>重定义 Adaptee 的行为较为困难（需要构建 Adaptee 的新子类，并在 Adapter 中引用该类型）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="实现">实现
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0">&lt;/a>
&lt;/h3>&lt;h4 id="使用-c实现适配器类">使用 C++实现适配器类
&lt;a class="header-anchor" href="#%e4%bd%bf%e7%94%a8-c%e5%ae%9e%e7%8e%b0%e9%80%82%e9%85%8d%e5%99%a8%e7%b1%bb">&lt;/a>
&lt;/h4>&lt;p>在使用 C++实现适配器类时，Adapter 类应该采用公共方式继承 Target 类，并且用私有方式继承 Adaptee 类。因此，Adapter 类应该是 Target 的子类型，但不是 Adaptee 的子类型。&lt;/p></description></item><item><title>4.2-Bridge「Handle」-桥接-结构型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.2-BridgeHandle-%E6%A1%A5%E6%8E%A5-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.2-BridgeHandle-%E6%A1%A5%E6%8E%A5-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;p>又称 Handle/Body&lt;/p>
&lt;h3 id="011-用途">0.1.1 用途
&lt;a class="header-anchor" href="#011-%e7%94%a8%e9%80%94">&lt;/a>
&lt;/h3>&lt;h2 id="继承-vs-bridge">将抽象部分与它的实现部分分离，使它们可以独立地变化。
继承 VS Bridge：
&lt;a class="header-anchor" href="#%e7%bb%a7%e6%89%bf-vs-bridge">&lt;/a>
&lt;/h2>&lt;h3 id="012-示例">0.1.2 示例
&lt;a class="header-anchor" href="#012-%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h3>&lt;p>场景：一个 GUI 工具箱中的可移植窗口需要支持 XWindows 和 PM 系统
实现方法：&lt;/p>
&lt;ul>
&lt;li>继承：定义 Window 抽象类和它的两个子类 XWindow 与 PMWindow，由它们分别实现不同系统平台上的 Window 界面。
&lt;ul>
&lt;li>缺陷：
&lt;ul>
&lt;li>扩展 Window 抽象使之适用于不同种类的窗口或新的系统平台很不方便（需要为 Windows 的每个子类针对每个平台分别创建一个类）&lt;/li>
&lt;li>继承机制使得客户代码与平台相关。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Bridge 模式：将接口抽象和实现放在彼此独立的类层次结构中：
&lt;ul>
&lt;li>对 Window 子类的所有操作都是用 WindowImp 接口中的抽象操作实现的&lt;/li>
&lt;li>将 Window 与 WindowImp 之间的关系称为&lt;strong>桥接&lt;/strong>，它在抽象类与它的实现之间起到了桥梁作用，使它们可以独立地变化。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/4.2-Bridge%E3%80%8CHandle%E3%80%8D-%E6%A1%A5%E6%8E%A5-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-28_17-37-36-790.png" alt="" />&lt;/p>
&lt;h3 id="013-适用性">0.1.3 适用性
&lt;a class="header-anchor" href="#013-%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如，这种情况可能是因为，在程序运行时实现部分应可以被选择或者切换。&lt;/li>
&lt;li>类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时 Bridge 模式使你可以&lt;em>对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充&lt;/em>。&lt;/li>
&lt;li>对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。&lt;/li>
&lt;li>（C++）你想对客户完全隐藏抽象的实现部分。在 C++中，类的表示在类接口中是可见的。&lt;/li>
&lt;li>若采用继承模式会有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。
&lt;ul>
&lt;li>Rumbaugh 称这种类层次结构为“嵌套的泛化”（nested generalization） [RBP+91]。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。&lt;/li>
&lt;/ul>
&lt;h3 id="014-结构">0.1.4 结构
&lt;a class="header-anchor" href="#014-%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/4.2-Bridge%E3%80%8CHandle%E3%80%8D-%E6%A1%A5%E6%8E%A5-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-28_18-21-07-218.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>Abstraction：抽象接口（例如示例中的 Window），维护一个指向实现（Implementor）的指针&lt;/li>
&lt;li>RefinedAbstraction：精化的接口（例如示例中的 IconWindow）&lt;/li>
&lt;li>Implementor：实现类的接口（示例中的 WindowImp）
&lt;ul>
&lt;li>该接口无需和 Abstraction 的接口一致。一般来讲：
&lt;ul>
&lt;li>&lt;em>Implementor 接口仅提供基本操作&lt;/em>&lt;/li>
&lt;li>&lt;em>Abstraction 则定义了基于这些基本操作的较高层次的操作&lt;/em>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ConcreteImplementor：实现 Implementor 的具体接口（示例中的 XWindowImp、PMWindowImp）&lt;/li>
&lt;/ul>
&lt;p>Abstraction 将 client 的请求转发给它的 Implementor 对象&lt;/p></description></item><item><title>4.3-Composite-组合-结构型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.3-Composite-%E7%BB%84%E5%90%88-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.3-Composite-%E7%BB%84%E5%90%88-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h3 id="目的">目的
&lt;a class="header-anchor" href="#%e7%9b%ae%e7%9a%84">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>将对象组合成&lt;em>树形结构&lt;/em>以表示“部分–整体”的层次结构。&lt;/li>
&lt;li>Composite 使得用户&lt;em>对单个对象和组合对象的使用具有一致性&lt;/em>。&lt;/li>
&lt;/ul>
&lt;h3 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h3>&lt;p>例如 GUI 框架允许用户可以组合多个简单组件以递归形成一些较大的组件。这有 2 种实现方式：&lt;/p>
&lt;ul>
&lt;li>使用图元类和容器类：使用这些类的代码必须区别对待图元对象与容器对象，而实际上大多数情况下用户认为它们是一样的。&lt;/li>
&lt;li>使用 Composite 模式递归构建&lt;/li>
&lt;/ul>
&lt;p>Composite 模式的关键是一个抽象类，它既可以代表图元，又可以代表图元的容器。其内部提供图元和图元容器所需的所有接口&lt;/p>
&lt;ul>
&lt;li>它的图元子类（树的叶结点，Line，Text 等）无需实现容器相关的操作&lt;/li>
&lt;li>聚合类 Picture 定义了一个 Graphic 的集合，它的 Draw 递归调用子部件的 Draw 操作。由于 Picture 接口与 Graphic 接口是一致的，因此 Picture 对象可以递归地组合其他 Picture 对象。
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/4.3-Composite-%E7%BB%84%E5%90%88-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-30_09-37-45-676.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h3 id="适用性">适用性
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>你想表示对象的部分–整体层次结构。&lt;/li>
&lt;li>你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。&lt;/li>
&lt;/ul>
&lt;h3 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>组合结构如下：
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/4.3-Composite-%E7%BB%84%E5%90%88-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-30_09-40-59-855.png" alt="" />
继承结构如下：
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/4.3-Composite-%E7%BB%84%E5%90%88-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-30_09-40-54-198.png" alt="" />&lt;/p>
&lt;p>&lt;strong>参与者&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Component：
&lt;ul>
&lt;li>提供 Leaf 所需的操作，提供用于访问管理 Component 子组件所需的操作&lt;/li>
&lt;li>通常需要，实现所有类共有接口的默认行为&lt;/li>
&lt;li>如果需要，在 Component 类中提供访问父组件的接口，Leaf 和 Composite 按需实现这个接口。
&lt;ul>
&lt;li>父部件引用可以简化结构的上移和组件的删除&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Composite（Picture）
&lt;ul>
&lt;li>定义有子部件的那些部件的行为。&lt;/li>
&lt;li>存储子部件。&lt;/li>
&lt;li>在 Component 接口中实现与子部件有关的操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Leaf：定义图元对象的行为&lt;/li>
&lt;li>Client：通过 Component 接口操纵组合部件的对象&lt;/li>
&lt;/ul>
&lt;p>用户使用 Component 类接口与组合结构中的对象进行交互。&lt;/p></description></item><item><title>4.4-Decorator「wrapper」-装饰器-结构型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.4-Decoratorwrapper-%E8%A3%85%E9%A5%B0%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.4-Decoratorwrapper-%E8%A3%85%E9%A5%B0%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h3 id="目的">目的
&lt;a class="header-anchor" href="#%e7%9b%ae%e7%9a%84">&lt;/a>
&lt;/h3>&lt;p>动态地向对象添加额外功能，比创建子类更加灵活&lt;/p>
&lt;h3 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h3>&lt;p>GUI 工具箱允许你对任意一个用户界面组件添加一些特性（例如边框），或是一些行为（例如窗口滚动）。&lt;/p>
&lt;p>一种较为灵活的方式是将组件嵌入另一个对象中，由这个对象添加边框。我们称这个嵌入的对象为&lt;strong>装饰&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>这个装饰与它所装饰的组件接口一致，因此它对使用该组件的客户透明（因此可以递归地嵌套）&lt;/li>
&lt;li>它将客户请求转发给该组件，并且可能在转发前后执行一些额外的动作（例如画一个边框）。
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/4.4-Decorator%E3%80%8Cwrapper%E3%80%8D-%E8%A3%85%E9%A5%B0%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-30_14-10-58-351.png" alt="600" />&lt;/li>
&lt;/ul>
&lt;h3 id="适用性">适用性
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。&lt;/li>
&lt;li>处理那些可以撤销的职责。&lt;/li>
&lt;li>当不能采用生成子类的方法进行扩充时，例如：
&lt;ul>
&lt;li>可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长&lt;/li>
&lt;li>类定义被隐藏或类是 final 的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/4.4-Decorator%E3%80%8Cwrapper%E3%80%8D-%E8%A3%85%E9%A5%B0%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-30_14-13-50-387.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>Component：对象接口&lt;/li>
&lt;li>ConcreteComponent&lt;/li>
&lt;li>Decorator：维护指向 Component 的指针，定义和 Component 一致的接口&lt;/li>
&lt;li>ConcreteDecorator：向组件添加职责（将操作代理给所持有的对象，并附加自身的操作）
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/4.4-Decorator%E3%80%8Cwrapper%E3%80%8D-%E8%A3%85%E9%A5%B0%E5%99%A8-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-09-30_14-32-31-015.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h3 id="优缺点">优缺点
&lt;a class="header-anchor" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>比静态继承更灵活：
&lt;ul>
&lt;li>可以用添加和分离装饰器的方法，用装饰在&lt;strong>运行时增加和删除职责&lt;/strong>。&lt;/li>
&lt;li>可以很容易地&lt;strong>重复添加一个特性&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>避免在层次结构高层的类有太多的特征&lt;/li>
&lt;li>Decorator 相比 Component 模式而言，是完全透明的包装，使用装饰时不应当依赖对象标识&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;strong>有许多小对象&lt;/strong>：采用 Decorator 模式进行系统设计往往会产生许多看上去类似的小对象，这些对象仅仅在它们相互连接的方式上有所不同，而不是它们的类或是它们的属性值有所不同。尽管对于那些了解这些系统的人来说，很容易对它们进行定制，但是&lt;em>很难学习这些系统，排错也很困难&lt;/em>。&lt;/p>
&lt;h3 id="实现">实现
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>接口一致性：装饰器必须和被装饰的对象接口一致&lt;/li>
&lt;li>省略抽象的装饰器：仅需要添加一个职责时，没有必要定义抽象 Decorator 类&lt;/li>
&lt;li>保持 Component 类的简单性：为保证一致性，组件和装饰器必须有共同的 Component 父类，因此需要避免这个类过大。&lt;em>这个父类应集中于定义接口而不是存储数据，对数据表示的定义应延迟到子类中&lt;/em>&lt;/li>
&lt;/ul>
&lt;h3 id="相关模式">相关模式
&lt;a class="header-anchor" href="#%e7%9b%b8%e5%85%b3%e6%a8%a1%e5%bc%8f">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>Adapter（4.1）：Decorator 模式不同于 Adapter 模式，因为装饰仅改变对象的职责而不改变它的接口；而适配器将给对象一个全新的接口。&lt;/li>
&lt;li>Composite（4.3）：可以将装饰视为一个退化的、仅有一个组件的组合。然而，装饰仅给对象添加一些额外的职责——它的目的不在于对象聚集。&lt;/li>
&lt;/ul>
&lt;h4 id="装饰器-vs-策略模式">装饰器 VS 策略模式
&lt;a class="header-anchor" href="#%e8%a3%85%e9%a5%b0%e5%99%a8-vs-%e7%ad%96%e7%95%a5%e6%a8%a1%e5%bc%8f">&lt;/a>
&lt;/h4>&lt;p>改变对象的行为主要有两种方式：&lt;/p>
&lt;ul>
&lt;li>Decorator 模式改变外壳&lt;/li>
&lt;li>Strategy 模式改变内核&lt;/li>
&lt;/ul>
&lt;p>当 Component 类原本就很庞大时，使用 Decorator 模式代价太高， Strategy 模式相对好一些&lt;/p></description></item><item><title>4.5-Facade-外观-结构型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.5-Facade-%E5%A4%96%E8%A7%82-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.5-Facade-%E5%A4%96%E8%A7%82-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h3 id="用途">用途
&lt;a class="header-anchor" href="#%e7%94%a8%e9%80%94">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>定义一个高层接口，为子系统的一组接口提供一个一致的界面，使得子系统更加易用&lt;/li>
&lt;li>Facade/fəˈsɑd/ 还可以降低子系统间的依赖关系
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/4.5-Facade-%E5%A4%96%E8%A7%82-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-03_06-38-33-854.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h3 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h3>&lt;p>有一个编译子系统，包含了若干个类来实现这一编译器，如 Scanner、Parse 等。&lt;/p>
&lt;ul>
&lt;li>多数普通用户不关心语法分析等细节，只是希望实现一些代码。
&lt;ul>
&lt;li>因此子系统提供一个 Compiler 对象提供统一的高层接口，隐藏了内部实现&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对于了解内部细节、有特殊需求的高级用户，可以绕过外观类 Complier 使用低层类实现功能
&lt;ul>
&lt;li>外观类不会隐藏内部实现
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/4.5-Facade-%E5%A4%96%E8%A7%82-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-03_06-39-35-694.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="适用性">适用性
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>当你要为一个复杂子系统提供一个简单接口时。
&lt;ul>
&lt;li>Facade 可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够&lt;/li>
&lt;li>而那些需要更多的可定制性的用户可以越过 Facade 层。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>客户程序与抽象类的实现部分之间存在着很大的依赖性。引入 Facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。&lt;/li>
&lt;li>当你需要构建一个层次结构的子系统时，使用 Facade 模式定义子系统中每层的入口点。&lt;/li>
&lt;li>如果子系统之间是相互依赖的，可以让它们仅通过 Facade 进行通信，从而简化了它们之间的依赖关系。&lt;/li>
&lt;/ul>
&lt;h3 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/4.5-Facade-%E5%A4%96%E8%A7%82-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-03_06-59-02-665.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>Facade：知道系统的内部结构，并将客户请求代理给适当的子系统对象&lt;/li>
&lt;li>Subsystemclasses：
&lt;ul>
&lt;li>实现子系统的功能，处理 Facade 分派的任务&lt;/li>
&lt;li>&lt;em>没有 Facade 的任何信息&lt;/em>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>使用 Facade 的客户程序不需要直接访问子系统对象，而通过发送请求给 Facade 的方式与子系统通信。Facade 将这些消息转发给适当的子系统对象。&lt;/p>
&lt;h3 id="优缺点">优缺点
&lt;a class="header-anchor" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">&lt;/a>
&lt;/h3>&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>对客户屏蔽子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便。&lt;/li>
&lt;li>它实现了子系统与客户之间的松耦合关系（子系统内部的功能组件往往是紧耦合的）
&lt;ul>
&lt;li>Facade 模式有助于建立层次结构系统&lt;/li>
&lt;li>Facade 模式可以消除复杂的循环依赖关系&lt;/li>
&lt;li>Facade 模式同样也有利于降低编译依赖性，使得编译一个子系统一般不需要编译所有其他的子系统。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果应用需要，它并不限制它们使用子系统类。因此你可以在系统易用性和通用性之间加以选择。&lt;/li>
&lt;/ul>
&lt;h3 id="实现">实现
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>进一步降低客户-子系统耦合度的方法：
&lt;ul>
&lt;li>Facade 定义为抽象类而其具体子类对应不同的子系统实现可以进一步降低客户和子系统的耦合度&lt;/li>
&lt;li>还可以用不同的子系统对象配置 Facade 对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>公共子系统类与私有子系统类：子系统和一个类都可用于功能的封装，相应地可以考虑提供公有和私有接口
&lt;ul>
&lt;li>子系统的公共接口包含所有的客户程序可以访问的类（包括 Facade），私有接口仅用于对子系统进行扩充&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="相关模式">相关模式
&lt;a class="header-anchor" href="#%e7%9b%b8%e5%85%b3%e6%a8%a1%e5%bc%8f">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>Abstract Factory（3.1）模式可以与 Facade 模式一起使用以提供一个接口，这一接口可用来以一种子系统独立的方式创建子系统对象。 Abstract Factory 也可以代替 Facade 模式隐藏那些与平台相关的类。&lt;/p></description></item><item><title>4.7-Proxy-代理-结构型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.7-Proxy-%E4%BB%A3%E7%90%86-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.7-Proxy-%E4%BB%A3%E7%90%86-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h3 id="目的">目的
&lt;a class="header-anchor" href="#%e7%9b%ae%e7%9a%84">&lt;/a>
&lt;/h3>&lt;p>为其他对象提供一种代理以控制该对象的访问。
类似网络中的反向代理&lt;/p>
&lt;h3 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h3>&lt;p>需求：&lt;/p>
&lt;ul>
&lt;li>为了改善打开执行速度，文档编辑器应当按需创建开销很大的对象（例如大型图像）&lt;/li>
&lt;li>需要隐藏根据需要创建图像这一事实，从而不会使得编辑器的实现复杂化&lt;/li>
&lt;/ul>
&lt;p>方法：&lt;/p>
&lt;ul>
&lt;li>使用图像 Proxy 替代真正的图像，Proxy 可以代替一个图像对象，并且在需要（文档编辑器调用图像代理的 Draw 操作）时负责实例化这个图像对象&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/4.7-Proxy-%E4%BB%A3%E7%90%86-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-03_13-19-51-038.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>图像 Proxy 存储图像路径和分辨率，以及对真正的 Image 实例的指引。因此不需要真正实例化这个图像就可以响应格式化程序对图像尺寸的请求&lt;/li>
&lt;/ul>
&lt;h3 id="适用性">适用性
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h3>&lt;p>在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用 Proxy 模式。例如：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>远程代理&lt;/strong>（Remote Proxy）为一个对象在不同的地址空间提供局部代表&lt;/li>
&lt;li>&lt;strong>虚代理&lt;/strong>（Virtual Proxy）根据需要创建开销很大的对象。&lt;/li>
&lt;li>&lt;strong>保护代理&lt;/strong> （Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。&lt;/li>
&lt;li>&lt;strong>智能指针&lt;/strong>（Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。它的典型用途包括：
&lt;ul>
&lt;li>对指向实际对象的&lt;strong>引用计数&lt;/strong>，可用于内存自动回收&lt;/li>
&lt;li>当第一次引用一个持久对象时，将它装入内存&lt;/li>
&lt;li>&lt;strong>读写锁&lt;/strong>：在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>copy-on-write&lt;/strong>：用代理延迟复杂大对象的拷贝过程，保证只有当这个对象被修改的时候才对它进行拷贝
&lt;ul>
&lt;li>在实现 Copy-on-write 时必须对实体进行引用计数。
&lt;ul>
&lt;li>拷贝代理仅会增加引用计数。只有当用户请求一个修改该实体的操作时，代理才会真正地拷贝它。&lt;/li>
&lt;li>当引用的数目为零时，这个实体将被删除。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/4.7-Proxy-%E4%BB%A3%E7%90%86-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-03_13-25-32-488.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>Proxy：
&lt;ul>
&lt;li>基本功能
&lt;ul>
&lt;li>保存一个引用使得代理可以访问实体。若 RealSubject 和 Subject 的接口相同，Proxy 会引用 Subject。&lt;/li>
&lt;li>提供一个与 Subject 的接口相同的接口，这样代理就可以用来替代实体。&lt;/li>
&lt;li>控制对实体的存取，并可能负责创建和删除它。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>其他功能：
&lt;ul>
&lt;li>Remote Proxy 负责对请求及其参数进行编码，并向不同地址空间中的实体发送已编码的请求。&lt;/li>
&lt;li>Virtual Proxy 可以缓存实体的附加信息，以便延迟对它的访问。例如，动机一节中提到的 ImageProxy 缓存了图像实体的尺寸。&lt;/li>
&lt;li>Protection Proxy 检查调用者是否具有实现一个请求所必需的访问权限。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Subject（Graphic）：定义 RealSubject 和 Proxy 的共用接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy。&lt;/li>
&lt;li>RealSubject（Image）：定义 Proxy 所代表的实体。&lt;/li>
&lt;/ul>
&lt;p>代理根据其种类，在适当的时候向 RealSubject 转发请求&lt;/p></description></item><item><title>5-行为型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;p>行为型模式涉及&lt;strong>算法和对象间职责的分配&lt;/strong>。行为型模式不仅描述对象或类的模式，还描述它们之间的&lt;strong>通信模式&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>类行为型模式使用继承机制在类间分派行为&lt;/li>
&lt;li>对象行为型模式描述了一组对等的对象怎样相互协作&lt;/li>
&lt;/ul>
&lt;p>大多数模式有两种对象：封装该方面特征的新对象，使用这些新对象的已有对象。&lt;/p>
&lt;ul>
&lt;li>不使用这些模式的话，通常这些新对象的功能就会变成已有对象的难以分割的一部分。&lt;/li>
&lt;/ul>
&lt;h3 id="通信的封装协作">通信的封装/协作
&lt;a class="header-anchor" href="#%e9%80%9a%e4%bf%a1%e7%9a%84%e5%b0%81%e8%a3%85%e5%8d%8f%e4%bd%9c">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>Observer 通过引入 Observer 和 Subject 对象来分布通信&lt;/li>
&lt;li>Mediator 对象则封装了其他对象间的通信&lt;/li>
&lt;/ul>
&lt;h3 id="解耦合">解耦合
&lt;a class="header-anchor" href="#%e8%a7%a3%e8%80%a6%e5%90%88">&lt;/a>
&lt;/h3>&lt;p>当合作的对象直接互相引用时，它们变得互相依赖。命令、观察者、中介者和职责链等模式都涉及如何对发送者和接收者解耦，但它们又各有不同的权衡考虑。&lt;/p>
&lt;p>命令模式使用一个 Command 对象来定义发送者和接收者之间的绑定关系&lt;/p>
&lt;ul>
&lt;li>Command 对象提供了一个提交请求的简单接口（即 Execute 操作）。&lt;/li>
&lt;li>将发送者和接收者之间的连接定义在一个单独的对象中使得该发送者可以与不同的接收者一起工作。
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-20_12-17-25-128.png" alt="" />&lt;/li>
&lt;/ul>
&lt;p>观察者模式通过定义一个接口来通知目标中发生的改变，从而将发送者（目标）与接收者（观察者）解耦&lt;/p>
&lt;ul>
&lt;li>当对象间有数据依赖时，最好用观察者模式来对它们进行解耦。
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-20_12-53-44-164.png" alt="" />&lt;/li>
&lt;/ul>
&lt;p>中介者模式让对象通过一个 Mediator 对象间接地互相引用，从而对它们解耦&lt;/p>
&lt;ul>
&lt;li>它将通信行为集中到一个类中而不是将其分布在各个子类中&lt;/li>
&lt;li>为增加灵活性 Mediator 可能不得不实现它自己的分发策略（例如用一定方式对请求编码并打包参数），但这通常会导致类型安全问题
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-20_12-54-29-879.png" alt="" />&lt;/li>
&lt;/ul>
&lt;p>职责链模式通过沿一个潜在接收者链传递请求而将发送者与接收者解耦
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-20_12-56-10-591.png" alt="" />&lt;/p></description></item><item><title>5.10-TemplateMethod-模板方法</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.10-TemplateMethod-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.10-TemplateMethod-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</guid><description>&lt;h3 id="目的">目的
&lt;a class="header-anchor" href="#%e7%9b%ae%e7%9a%84">&lt;/a>
&lt;/h3>&lt;p>定义一个操作的算法骨架，而将一些步骤延迟到子类中。通过子类来实现这些步骤，使得不改变算法结构的情况下，可重新定义算法中的某些特定步骤&lt;/p>
&lt;h3 id="适用性">适用性
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。&lt;/li>
&lt;li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。
&lt;ul>
&lt;li>首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。&lt;/li>
&lt;li>然后，用一个调用新的操作的模板方法来替换不同的代码。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>控制子类扩展。模板方法只在特定点调用 hook 操作，这样就只允许在这些点进行扩展。&lt;/li>
&lt;/ul>
&lt;h3 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.10-TemplateMethod-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/image-2023-10-19_17-05-39-615.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>AbstractClass：
&lt;ul>
&lt;li>定义抽象的原语操作（primitive operation），具体的子类将重定义它们以实现一个算法的各步骤&lt;/li>
&lt;li>实现一个模板方法，定义一个算法的骨架。该模板方法不仅调用原语操作，也调用定义在 AbstractClass 或其他对象中的操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ConcreteClass：实现原语操作以完成算法中与特定子类相关的步骤。&lt;/li>
&lt;/ul>
&lt;h3 id="效果">效果
&lt;a class="header-anchor" href="#%e6%95%88%e6%9e%9c">&lt;/a>
&lt;/h3>&lt;p>模板方法是一种代码复用的基本技术。它们在类库中尤为重要，提取了类库中的公共行为。
模板方法导致一种反向的控制结构，父类调用一个子类的操作。&lt;/p>
&lt;p>模板方法调用下列类型的操作：&lt;/p>
&lt;ul>
&lt;li>原语操作（即抽象操作）：子类必须重载以提供具体实现。&lt;/li>
&lt;li>钩子操作（hook operation），它提供了缺省的行为，子类可以在必要时通过重载进行扩展。钩子操作在缺省情况下通常是空操作。&lt;/li>
&lt;li>其他操作：不应重定义这些操作&lt;/li>
&lt;/ul>
&lt;p>很重要的一点是模板方法应该区分哪些操作是原语操作（必须重载），哪些是钩子操作（可以重载）&lt;/p>
&lt;h3 id="实现">实现
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>访问控制：
&lt;ul>
&lt;li>在 C++中，一个模板方法调用的原语操作可以被定义为 protected 的纯虚函数，保证它们只被模板方法调用，同时必须重载。&lt;/li>
&lt;li>模板方法自身不需要被重定义，因此可以将模板方法定义为一个非虚成员函数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>尽量减少原语操作&lt;/li>
&lt;li>命名约定：可以给应被重定义的操作的名字加上一个前缀以识别它们&lt;/li>
&lt;/ul>
&lt;h3 id="相关模式">相关模式
&lt;a class="header-anchor" href="#%e7%9b%b8%e5%85%b3%e6%a8%a1%e5%bc%8f">&lt;/a>
&lt;/h3>&lt;p>Strategy（5.9）：模板方法使用继承来改变算法的一部分， Strategy 使用委托来改变整个算法。
Factory Method（3.3）常被模板方法调用。&lt;/p></description></item><item><title>5.11-Visitor-访问者</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.11-Visitor-%E8%AE%BF%E9%97%AE%E8%80%85/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.11-Visitor-%E8%AE%BF%E9%97%AE%E8%80%85/</guid><description>&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h3 id="目的">目的
&lt;a class="header-anchor" href="#%e7%9b%ae%e7%9a%84">&lt;/a>
&lt;/h3>&lt;p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。&lt;/p>
&lt;h3 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h3>&lt;p>考虑一个编译器，它将源程序表示为一个抽象语法树，对于语法树结点需要进行不同的处理：类型检查，代码优化等
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.11-Visitor-%E8%AE%BF%E9%97%AE%E8%80%85/image-2023-10-19_18-21-15-257.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>将操作和结点类耦合带来的问题：将所有这些操作分散到各种结点类中会导致整个系统难以理解、难以维护和修改；此外，增加新的操作通常需要重新编译所有这些类&lt;/li>
&lt;li>解决方法：将每一个类中相关的操作包装在一个独立的对象（称为一个 Visitor）中，并在遍历抽象语法树时将此对象传递给当前访问的元素
&lt;ul>
&lt;li>所有抽象语法树的访问者有一个抽象的父类 NodeVisitor。NodeVisitor 必须为每一个结点类定义一个操作
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.11-Visitor-%E8%AE%BF%E9%97%AE%E8%80%85/image-2023-10-19_18-39-03-846.png" alt="" />
使用 Visitor 模式，必须定义两个类层次：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>一个对应于接受操作的元素（Node 层次）&lt;/li>
&lt;li>另一个对应于定义对元素的操作的访问者（NodeVisitor 层次）。给访问者类层次增加一个新的子类即可创建一个新的操作。&lt;/li>
&lt;/ul>
&lt;h3 id="适用性">适用性
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。&lt;/li>
&lt;li>需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。&lt;/li>
&lt;li>定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。&lt;/li>
&lt;/ul>
&lt;h3 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.11-Visitor-%E8%AE%BF%E9%97%AE%E8%80%85/image-2023-10-19_18-40-40-846.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Visitor：接口。为该对象结构中 ConcreteElement 的每一个类声明一个 Visit 操作，该操作的名字和特征标识了发送 Visit 请求给该访问者的类。&lt;/p>
&lt;ul>
&lt;li>访问者就可以通过该元素的特定接口直接访问它。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ConcreteVisitor：实现每个由 Visitor 声明的操作。每种具体的 Visitor 实现一种特定操作&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Element，ConcreteElement：定义一个 Accept 操作，它以一个访问者为参数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ObjectStructure（例如 List，Map）：能枚举它的元素，可以提供一个高层的接口以允许该 Visitor 访问它的元素&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个使用 Visitor 模式的客户必须创建一个 ConcreteVisitor 对象，然后遍历该对象结构，并用该访问者访问每一个元素。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当一个元素被访问时，它调用对应于它的类的 Visitor 操作。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="效果">效果
&lt;a class="header-anchor" href="#%e6%95%88%e6%9e%9c">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>访问者模式使得易于增加新的操作：仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。相反，如果每个功能都分散在多个类之上的话，定义新的操作时必须修改每一个类。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>访问者集中相关的操作而分离无关的操作：相关的行为不是分布在定义该对象结构的各个类上，而是集中在一个访问者中；无关行为却被分别放在各自的访问者子类中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>增加新的 ConcreteElement 类很困难：每添加一个新的 ConcreteElement 都要在 Vistor 中添加一个新的抽象操作，并在每一个 ConcretVisitor 类中实现相应的操作。&lt;/p></description></item><item><title>5.4-Iterator「cursor」-迭代器-行为型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.4-Iteratorcursor-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.4-Iteratorcursor-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h3 id="目的">目的
&lt;a class="header-anchor" href="#%e7%9b%ae%e7%9a%84">&lt;/a>
&lt;/h3>&lt;p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示&lt;/p>
&lt;h3 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h3>&lt;p>一个聚合对象，如列表（list），需要：&lt;/p>
&lt;ul>
&lt;li>提供一种方法来让别人可以访问它的元素，而又不需要暴露它的内部结构&lt;/li>
&lt;li>可能要以不同的方式遍历&lt;/li>
&lt;li>不希望列表的接口中充斥着各种不同遍历的操作&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>KEY&lt;/strong>：将对列表的访问和遍历从列表对象中分离出来并放入一个迭代器（iterator）对象中，由迭代器对象跟踪当前元素，维护遍历序列&lt;/p>
&lt;ul>
&lt;li>将遍历机制与列表对象分离使我们可以对同一个容器定义不同的迭代器来实现不同的遍历策略。例如先序迭代和后序迭代&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>多态迭代&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>为何需要多态：上述方法中，迭代器和列表是耦合在一起的，而且客户对象必须知道遍历的是一个列表而不是其他聚合结构&lt;/li>
&lt;li>方法：使用继承和多态机制，并由容器提供 CreateIterator 的接口，创建自己兼容的某种迭代器
&lt;ul>
&lt;li>这是 Factory Method，产生两个类层次，一个是列表的，一个是迭代器的。 CreateIterator“联系”这两个类层次
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.4-Iterator%E3%80%8Ccursor%E3%80%8D-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-10_09-23-04-798.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="适用性">适用性
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>访问一个聚合对象的内容而无须暴露它的内部表示。&lt;/li>
&lt;li>支持对聚合对象的多种遍历。&lt;/li>
&lt;li>为遍历不同的聚合结构提供一个统一的接口（即支持多态迭代）。&lt;/li>
&lt;/ul>
&lt;h3 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.4-Iterator%E3%80%8Ccursor%E3%80%8D-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-10_09-27-45-319.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>Iterator：定义访问和遍历元素的接口&lt;/li>
&lt;li>ConcreteIterator：
&lt;ul>
&lt;li>实现迭代器接口&lt;/li>
&lt;li>对该聚合遍历时&lt;em>跟踪当前位置，并能够计算出待遍历的后继对象&lt;/em>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Aggregate（聚合）：定义创建相应迭代器对象的接口。&lt;/li>
&lt;li>ConcreteAggregate：实现创建相应迭代器的接口，该操作返回 ConcreteIterator 的一个适当的实例&lt;/li>
&lt;/ul>
&lt;h3 id="优缺点">优缺点
&lt;a class="header-anchor" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">&lt;/a>
&lt;/h3>&lt;p>迭代器模式有三个重要的作用：&lt;/p>
&lt;ul>
&lt;li>支持以不同的方式遍历一个聚合&lt;/li>
&lt;li>简化了聚合的接口：有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了&lt;/li>
&lt;li>在同一个聚合上可以同时有多个遍历：每个迭代器保持它自己的遍历状态，因此你可以同时进行多个遍历&lt;/li>
&lt;/ul>
&lt;h3 id="实现">实现
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0">&lt;/a>
&lt;/h3>&lt;h4 id="谁控制迭代">谁控制迭代
&lt;a class="header-anchor" href="#%e8%b0%81%e6%8e%a7%e5%88%b6%e8%bf%ad%e4%bb%a3">&lt;/a>
&lt;/h4>&lt;p>控制迭代即控制迭代的推进过程，根据迭代过程是迭代器还是使用该迭代器的客户控制，迭代器可分为内部/外部迭代器 2 类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>外部迭代器&lt;/strong>：客户必须主动推进遍历的步伐，显式地向迭代器请求下一个元素&lt;/li>
&lt;li>&lt;strong>内部迭代器&lt;/strong>：由迭代器控制迭代的推进，客户只需向其提交一个待执行的操作，而迭代器将对聚合中的每一个元素实施该操作。&lt;/li>
&lt;/ul>
&lt;h4 id="谁定义遍历算法">谁定义遍历算法
&lt;a class="header-anchor" href="#%e8%b0%81%e5%ae%9a%e4%b9%89%e9%81%8d%e5%8e%86%e7%ae%97%e6%b3%95">&lt;/a>
&lt;/h4>&lt;p>迭代器和聚合均可定义遍历算法&lt;/p>
&lt;p>&lt;strong>聚合定义遍历算法&lt;/strong>：&lt;em>聚合定义遍历算法，迭代器只存储当前迭代的上下文&lt;/em>&lt;/p>
&lt;ul>
&lt;li>在遍历过程中用迭代器来存储当前迭代的状态。我们称这种迭代器为&lt;strong>游标（cursor）&lt;/strong>，因为它仅用来指示当前位置。&lt;/li>
&lt;li>客户会以这个游标为参数调用该聚合的 Next 操作，而 Next 操作将改变这个指示器的状态&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>迭代器定义遍历算法&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>优点：
&lt;ul>
&lt;li>易于在相同的聚合上使用不同的迭代算法&lt;/li>
&lt;li>易于在不同的聚合上复用相同的算法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点：遍历算法可能需要访问聚合的私有变量。如果这样，将遍历算法放入迭代器中会破坏聚合的封装性&lt;/li>
&lt;/ul>
&lt;h4 id="遍历时修改">遍历时修改
&lt;a class="header-anchor" href="#%e9%81%8d%e5%8e%86%e6%97%b6%e4%bf%ae%e6%94%b9">&lt;/a>
&lt;/h4>&lt;p>在遍历一个聚合的同时更改这个聚合可能是危险的。如果在遍历聚合的时候增加或删除聚合元素，可能会导致两次访问同一个元素或者遗漏掉某个元素。&lt;/p>
&lt;p>一个&lt;strong>健壮的迭代器 robust iterator&lt;/strong> 保证==插入和删除操作不会干扰遍历，且不需要拷贝该聚合==&lt;/p>
&lt;ul>
&lt;li>这大多数需要向聚合注册迭代器。当插入或删除元素时，该聚合需要：
&lt;ul>
&lt;li>调整迭代器的内部状态&lt;/li>
&lt;li>或在内部维护额外的信息以保证正确的遍历。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="可选接口">可选接口
&lt;a class="header-anchor" href="#%e5%8f%af%e9%80%89%e6%8e%a5%e5%8f%a3">&lt;/a>
&lt;/h4>&lt;p>迭代器的最小接口由 First、Next、IsDone 和 CurrentItem 操作组成&lt;/p></description></item><item><title>5.5-Mediator-中介者-行为型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.5-Mediator-%E4%B8%AD%E4%BB%8B%E8%80%85-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.5-Mediator-%E4%B8%AD%E4%BB%8B%E8%80%85-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h3 id="目的">目的
&lt;a class="header-anchor" href="#%e7%9b%ae%e7%9a%84">&lt;/a>
&lt;/h3>&lt;p>用一个中介对象封装对象交互，使各对象不需要显式地相互引用&lt;/p>
&lt;ul>
&lt;li>从而可以解耦合&lt;/li>
&lt;li>可以对立改变之间的交互&lt;/li>
&lt;/ul>
&lt;h3 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h3>&lt;p>面向对象中，对象的行为分布到各个对象中。这种分布可能会导致对象间有许多连接。在最坏的情况下，每一个对象都知道其他所有对象。&lt;/p>
&lt;p>考虑 GUI 中各个窗口组件的依赖关系：例如当一个特定的输入域为空时，某个按钮不能使用；ListBox 选择一项可能会改变一个输入域的内容&lt;/p>
&lt;ul>
&lt;li>这导致每个组件必须单独定制以反应组件间的依赖关系&lt;/li>
&lt;li>解决方法：可以通过将集体行为封装在一个单独的中介者（mediator）对象中，如下图所设&lt;/li>
&lt;/ul>
&lt;p>类层次结构：&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.5-Mediator-%E4%B8%AD%E4%BB%8B%E8%80%85-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-12_15-58-26-968.png" alt="" />
对象交互：&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.5-Mediator-%E4%B8%AD%E4%BB%8B%E8%80%85-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-12_15-52-46-168.png" alt="" />
例如选择 ListBox 改变 EntryField 的内容
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.5-Mediator-%E4%B8%AD%E4%BB%8B%E8%80%85-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-12_15-53-31-871.png" alt="" />&lt;/p>
&lt;h3 id="适用性">适用性
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>一组对象以定义良好但复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。&lt;/li>
&lt;li>一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。&lt;/li>
&lt;li>想定制一个分布在多个类中的行为，而又不想生成太多的子类。&lt;/li>
&lt;/ul>
&lt;h3 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.5-Mediator-%E4%B8%AD%E4%BB%8B%E8%80%85-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-12_16-00-15-284.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>Mediator 中介者：定义和同事 Colleague 通信的接口&lt;/li>
&lt;li>ConcreteMediator：了解并维护它的各个同事，处理它们之间的交互&lt;/li>
&lt;li>Colleagueclass：
&lt;ul>
&lt;li>每个同事均了解其中介对象（例如持有一份 Mediator 实例的引用）&lt;/li>
&lt;li>每个同事通过中介的接口与其他同事通信&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>同事向一个中介者对象发送和接收请求。中介者在各同事间适当地转发请求以实现协作行为&lt;/p>
&lt;h3 id="优缺点">优缺点
&lt;a class="header-anchor" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>将各 Colleague 解耦&lt;/li>
&lt;li>简化了对象协议：用 Mediator 和各 Colleague 间的一对多交互来代替多对多交互，更易于理解、维护和扩展。&lt;/li>
&lt;li>对对象如何协作进行了抽象：将中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象各自本身的行为转移到它们之间的交互上来。&lt;/li>
&lt;li>使控制集中化：中介者模式将交互的复杂性变为中介者的复杂性，这可能导致中介者本身复杂而难以维护&lt;/li>
&lt;/ul>
&lt;h3 id="实现">实现
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>简单情形下无需定义抽象中介类：当各 Colleague 仅与一个 Mediator 一起工作时，没有必要定义一个抽象的 Mediator 类&lt;/li>
&lt;li>Colleague-Mediator 通信：当一个感兴趣的事件发生时， Colleague 必须与其 Mediator 通信，这有两种实现方法：
&lt;ul>
&lt;li>使用 Observer（5.7） 模式，将 Mediator 实现为一个 Observer，各 Colleague 作为 Subject
&lt;ul>
&lt;li>一旦 Subject 状态改变就发送通知给 Mediator&lt;/li>
&lt;li>Mediator 将该事件向所有其他 Colleague 转发&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在 Mediator 中定义一个特殊的通知接口，各 Colleague 在通信时直接调用该接口&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="相关模式">相关模式
&lt;a class="header-anchor" href="#%e7%9b%b8%e5%85%b3%e6%a8%a1%e5%bc%8f">&lt;/a>
&lt;/h3>&lt;p>Facade（4.5）与中介者的不同之处在于：&lt;/p></description></item><item><title>5.6-Memento「Token」-备忘录-行为型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.6-MementoToken-%E5%A4%87%E5%BF%98%E5%BD%95-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.6-MementoToken-%E5%A4%87%E5%BF%98%E5%BD%95-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h4 id="目的">目的
&lt;a class="header-anchor" href="#%e7%9b%ae%e7%9a%84">&lt;/a>
&lt;/h4>&lt;p>在不破坏封装性的前提下捕获对象内部状态，在对象外保存该状态以备恢复&lt;/p>
&lt;h3 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h3>&lt;p>一个图形编辑器，它支持图形对象间的连线。用户可用一条直线连接两个矩形，而当用户移动任意一个矩形时，这两个矩形仍能保持连接
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.6-Memento%E3%80%8CToken%E3%80%8D-%E5%A4%87%E5%BF%98%E5%BD%95-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-13_17-44-47-122.png" alt="" />
考虑需要撤销移动命令的情形：&lt;/p>
&lt;ul>
&lt;li>备忘录存储内部状态：某个对象（称为原发器 originator ）保存自身某个瞬间的内部状态为备忘录对象。&lt;/li>
&lt;li>对象可以导出内部状态为备忘录：当需要设置原发器的检查点时，取消操作机制会&lt;em>向原发器&lt;/em>请求一个备忘录。&lt;/li>
&lt;li>也可以依据备忘录恢复内部状态：需要恢复时，编辑器向原发器提供备忘录供其恢复内部状态&lt;/li>
&lt;/ul>
&lt;p>譬如计算图形对象连线的 ConstraintSolver 类，可以作为原发器：考虑取消移动的过程：&lt;/p>
&lt;ul>
&lt;li>作为移动操作的一个副作用，编辑器向 ConstraintSolver 请求一个备忘录；ConstraintSolver 创建并返回一个备忘录&lt;/li>
&lt;li>此后当用户取消移动操作时，编辑器将上次请求的备忘录送回给 ConstraintSolver&lt;/li>
&lt;li>ConstraintSolver 改变它的内部结构以精确地将它的等式和变量返回到它们各自先前的状态&lt;/li>
&lt;/ul>
&lt;h3 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.6-Memento%E3%80%8CToken%E3%80%8D-%E5%A4%87%E5%BF%98%E5%BD%95-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-13_17-55-11-564.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>Memento 备忘录：备忘录存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态
&lt;ul>
&lt;li>防止原发器以外的其他对象访问备忘录。备忘录实际上有两个接口，
&lt;ul>
&lt;li>管理者（caretaker）只能看到备忘录的窄接口——它只能将备忘录传递给其他对象。&lt;/li>
&lt;li>原发器能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>理想的情况是只允许生成本备忘录的那个原发器访问本备忘录的内部状态。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Originator 原发器：原发器创建一个备忘录，用以记录当前时刻它的内部状态；并使用备忘录恢复内部状态&lt;/li>
&lt;li>Caretaker 管理者：负责保存好备忘录，但不能访问或修改备忘录的内容&lt;/li>
&lt;/ul>
&lt;p>管理者向原发器请求一个备忘录，保留一段时间后，在需要回退状态时将其送回给原发器&lt;/p>
&lt;h3 id="优缺点">优缺点
&lt;a class="header-anchor" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>保护封装性&lt;/li>
&lt;li>简化了原发器：Originator 无需考虑如何保存客户请求过的各个内部状态版本，版本管理由 caretaker 完成。&lt;/li>
&lt;li>复制状态的开销：若生成备忘录时必须拷贝并存储大量的信息，或者客户非常频繁地创建备忘录和恢复原发器状态，可能会导致非常大的开销
&lt;ul>
&lt;li>可能需要使用增量修改&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>维护状态的开销：管理者负责删除它所维护的备忘录。然而，管理者不知道备忘录中有多少个状态。因此当存储备忘录时，一个本来很小的管理者可能会产生大量的存储开销&lt;/li>
&lt;li>宽窄接口：在一些语言中可能难以保证只有原发器可访问备忘录的状态。&lt;/li>
&lt;/ul>
&lt;h3 id="实现">实现
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0">&lt;/a>
&lt;/h3>&lt;h4 id="宽窄接口">宽窄接口
&lt;a class="header-anchor" href="#%e5%ae%bd%e7%aa%84%e6%8e%a5%e5%8f%a3">&lt;/a>
&lt;/h4>&lt;p>备忘录有两个接口：一个为原发器所使用的宽接口，一个为其他对象所使用的窄接口。&lt;/p>
&lt;p>C++中，可将 Originator 作为 Memento 的一个友元，并使 Memento 宽接口为私有的，窄接口为公共的&lt;/p>
&lt;h4 id="增量改变">增量改变
&lt;a class="header-anchor" href="#%e5%a2%9e%e9%87%8f%e6%94%b9%e5%8f%98">&lt;/a>
&lt;/h4>&lt;p>如果备忘录的创建及其返回（给它们的原发器）的顺序是可预测的，备忘录可以仅存储原发器内部状态的增量改变。&lt;/p>
&lt;p>例如，一个包含可撤销的命令的历史列表可使用备忘录：&lt;/p>
&lt;ul>
&lt;li>存在一个历史列表，定义了一个特定的顺序，按照这个顺序命令可以被撤销和重做&lt;/li>
&lt;li>备忘录可以只存储一个命令所产生的增量改变而不是它所影响的每一个对象的完整状态&lt;/li>
&lt;/ul>
&lt;h3 id="相关模式">相关模式
&lt;a class="header-anchor" href="#%e7%9b%b8%e5%85%b3%e6%a8%a1%e5%bc%8f">&lt;/a>
&lt;/h3>&lt;p>Command（5.2）：命令可使用备忘录来为可撤销的操作维护状态。
Iterator（5.4）：如前所述，备忘录可用于迭代。&lt;/p></description></item><item><title>5.8-State「Object for state」-状态-状态对象-行为型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.8-StateObject-for-state-%E7%8A%B6%E6%80%81-%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.8-StateObject-for-state-%E7%8A%B6%E6%80%81-%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h3 id="目的">目的
&lt;a class="header-anchor" href="#%e7%9b%ae%e7%9a%84">&lt;/a>
&lt;/h3>&lt;p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类&lt;/p>
&lt;h3 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h3>&lt;p>考虑一个表示网络连接的类 TCPConnection。
一个 TCPConnection 对象的状态处于若干不同状态之一：连接已建立（Established）、正在监听（Listening）、连接已关闭（Closed）。
当一个 TCPConnection 对象收到其他对象的请求时，它根据自身的当前状态做出不同的反应。
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.8-State%E3%80%8CObject%20for%20state%E3%80%8D-%E7%8A%B6%E6%80%81-%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-18_17-19-21-774.png" alt="" />&lt;/p>
&lt;p>State 模式：&lt;/p>
&lt;ul>
&lt;li>Key：引入了一个称为 TCPState 的抽象类来表示网络的连接状态：
&lt;ul>
&lt;li>TCPState 类为各表示不同的操作状态的子类声明了一个公共接口。&lt;/li>
&lt;li>TCPState 的子类实现与特定状态相关的行为&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>TCPConnection 类维护一个表示 TCP 连接当前状态的状态对象（TCPState 子类的实例）
&lt;ul>
&lt;li>将所有与状态相关的请求委托给该对象&lt;/li>
&lt;li>一旦连接状态改变，TCPConnection 对象就会改变它所使用的状态对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="适用性">适用性
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。&lt;/li>
&lt;li>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。
&lt;ul>
&lt;li>State 模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.8-State%E3%80%8CObject%20for%20state%E3%80%8D-%E7%8A%B6%E6%80%81-%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-18_17-25-04-181.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>Context：定义面向客户的接口
&lt;ul>
&lt;li>维护 ConcreteState 实例，表征当前状态&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>State：定义接口，封装与 Context 的特定状态相关的行为&lt;/li>
&lt;li>ConcreteStateX：每一子类实现一个与 Context 的一个状态相关的行为&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>关联&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Context 将与状态相关的请求委托给当前的 ConcreteState 对象处理。
&lt;ul>
&lt;li>Context 可将自身作为一个参数传递给处理该请求的状态对象。这使得状态对象在必要时可访问 Context。&lt;/li>
&lt;li>Context 是客户使用的主要接口。客户可用状态对象来配置一个 Context，一旦一个 Context 配置完毕，它的客户不再需要直接与状态对象打交道。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Context 或 ConcreteState 子类都可决定哪个状态是另外一个的后继者，以及是在何种条件下进行状态转换。&lt;/li>
&lt;/ul>
&lt;h3 id="效果">效果
&lt;a class="header-anchor" href="#%e6%95%88%e6%9e%9c">&lt;/a>
&lt;/h3>&lt;p>&lt;strong>将不同状态的行为分割开来&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>不用 State 模式：使用数据值定义内部状态并且让 Context 操作来显式地检查这些数据。但这样将会使整个 Context 的实现中遍布看起来很相似的条件语句或 case 语句&lt;/li>
&lt;li>使用 State 模式：
&lt;ul>
&lt;li>避免了庞大的条件语句&lt;/li>
&lt;li>每一个状态转换和动作封装到一个类中，就把着眼点从执行状态提高到整个对象的状态。这将使代码结构化并使其意图更加清晰。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>确保内部状态变量的一致性&lt;/strong>：从 Context 的角度看，状态转换是原子的——只需重新绑定一个 ConcreteState 实例，而无需为一组变量分别赋值。（仅以内部数据值来定义当前状态时，其状态仅表现为对一些变量的赋值）&lt;/p></description></item><item><title>5.9-Strategy「Policy」-策略模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.9-StrategyPolicy-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:58 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.9-StrategyPolicy-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h3 id="目的">目的
&lt;a class="header-anchor" href="#%e7%9b%ae%e7%9a%84">&lt;/a>
&lt;/h3>&lt;p>封装算法，使之可以独立于客户变化&lt;/p>
&lt;h3 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h3>&lt;p>文本分行有多种算法&lt;/p>
&lt;ul>
&lt;li>若将程序类包含多种算法的代码，则使程序庞杂难维护&lt;/li>
&lt;li>并非任何时候都需要所有的算法&lt;/li>
&lt;li>若将算法嵌入客户程序内部，则变更算法将十分困难&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.9-Strategy%E3%80%8CPolicy%E3%80%8D-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/image-2023-10-18_20-27-56-390.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>Composition 维护对 Compositor 对象的一个引用。一旦 Composition 重新格式化它的文本，它就将这个职责转发给它的 Compositor 对象&lt;/li>
&lt;li>Compositor 的子类实现具体的分行算法&lt;/li>
&lt;/ul>
&lt;h3 id="适用性">适用性
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。&lt;/li>
&lt;li>需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。&lt;/li>
&lt;li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。&lt;/li>
&lt;li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的 Strategy 类中以代替这些条件语句。&lt;/li>
&lt;/ul>
&lt;h3 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.9-Strategy%E3%80%8CPolicy%E3%80%8D-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/image-2023-10-19_16-10-40-788.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>Strategy：算法的公共接口，Context 调用该接口&lt;/li>
&lt;li>ConcreteStrategy：实现具体的策略&lt;/li>
&lt;li>Context：用一个 ConcreteStrategy 对象来配置，维护一个 Strategy 实例，提供接口让 Strategy 访问其数据&lt;/li>
&lt;/ul>
&lt;p>Strategy 和 Context 相互作用以实现选定的算法。&lt;/p>
&lt;ul>
&lt;li>客户仅与 Context 交互，通常创建并传递一个 Concrete-Strategy 对象给该 Context&lt;/li>
&lt;li>Context 将客户的请求转发给它的 Strategy。&lt;/li>
&lt;li>当算法被调用时， Context 可以将该算法所需要的所有数据都传递给该 Strategy。
&lt;ul>
&lt;li>或者 Context 可以将自身作为一个参数传递给 Strategy 操作，以便 Strategy 在适当时候回调。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="效果">效果
&lt;a class="header-anchor" href="#%e6%95%88%e6%9e%9c">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>降低 Context 的复杂度：将算法和 Context 解耦合，易于切换算法&lt;/li>
&lt;li>有利于复用算法&lt;/li>
&lt;li>允许客户根据具体的时间/空间需要选择具体算法，但相应地，这意味着需要客户了解不同的 Strategy 之间的差异&lt;/li>
&lt;li>消除了大量的条件判断：Context 内嵌多种算法/行为时，通常需要大量条件语句来选择合适的行为
缺陷&lt;/li>
&lt;li>冗余参数：不同的 ConcreteStrategy 需要不同的参数集，因此抽象父类定义的接口必须提供这些参数集的并集。
&lt;ul>
&lt;li>这就意味着有时 Context 会创建和初始化一些永远不会用到的参数&lt;/li>
&lt;li>如果存在这样的问题，那么将需要在 Strategy 和 Context 之间进行更紧密的耦合。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对象的数目：Strategy 增加了一个应用中的对象的数目。有时你可以将 Strategy 实现为可供各 Context 共享的无状态的对象来减少这一开销&lt;/li>
&lt;/ul>
&lt;h3 id="实现">实现
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0">&lt;/a>
&lt;/h3>&lt;h4 id="关于-strategy-和-context-的接口">关于 Strategy 和 Context 的接口
&lt;a class="header-anchor" href="#%e5%85%b3%e4%ba%8e-strategy-%e5%92%8c-context-%e7%9a%84%e6%8e%a5%e5%8f%a3">&lt;/a>
&lt;/h4>&lt;p>这些接口必须让 ConcreteStrategy 能够有效地访问它所需要的 Context 中的任何数据，实现上有两种方法：&lt;/p></description></item><item><title>5.2-Command「Action,Transaction」-命令模式-动作模式-事务模式-行为型模式</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.2-CommandActionTransaction-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E4%BD%9C%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Mar 2024 15:49:57 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.2-CommandActionTransaction-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E4%BD%9C%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h3 id="目的">目的
&lt;a class="header-anchor" href="#%e7%9b%ae%e7%9a%84">&lt;/a>
&lt;/h3>&lt;p>将请求封装为对象，从而可用不同的请求：&lt;/p>
&lt;ul>
&lt;li>对客户行为参数化&lt;/li>
&lt;li>对请求排队或记录日志&lt;/li>
&lt;li>支持可撤销的操作&lt;/li>
&lt;/ul>
&lt;h3 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h3>&lt;p>有时必须向某对象提交请求，但并不知道关于被请求的操作或请求的接收者的任何信息。&lt;/p>

 &lt;blockquote>
 &lt;p>例如，用户界面工具箱包括按钮和菜单这样的对象，它们执行请求响应用户输入。但工具箱不能显式地在按钮或菜单中实现该请求，因为只有使用工具箱的应用知道该由哪个对象做哪个操作。&lt;/p>
 &lt;/blockquote>
&lt;p>&lt;strong>命令模式&lt;/strong>通过将请求本身变成一个&lt;em>可存储对象&lt;/em>来使工具箱对象可向未指定的应用对象提出请求。&lt;/p>
&lt;ul>
&lt;li>关键是一个抽象的 Command 类，它定义了一个执行操作的接口。&lt;/li>
&lt;li>Command 子类将接收者作为它的一个实例变量，并实现 Execute 操作
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.2-Command%E3%80%8CAction,Transaction%E3%80%8D-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E4%BD%9C%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-34-53-110.png" alt="" />&lt;/li>
&lt;/ul>

 &lt;blockquote>
 &lt;p>例如，PasteCommand 支持从剪贴板向一个文档（document）粘贴正文。
PasteCommand 的接收者是一个文档对象，该对象是实例化时提供的。Execute 操作将调用该 Document 的 Paste 操作。
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.2-Command%E3%80%8CAction,Transaction%E3%80%8D-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E4%BD%9C%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-44-14-818.png" alt="" />&lt;/p>
 &lt;/blockquote>
&lt;p>&lt;strong>MacroCommand&lt;/strong>：有时一个操作需要多个子操作完成，因此可定义 MacroCommand 执行一个命令序列&lt;/p>
&lt;ul>
&lt;li>MacroCommand 没有明确的接收者，而序列中的命令各自定义其接收者。
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.2-Command%E3%80%8CAction,Transaction%E3%80%8D-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E4%BD%9C%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-47-37-766.png" alt="" />&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>优势：灵活&lt;/strong>。因为&lt;em>提交一个请求的对象仅需要知道如何提交它，而不需要知道该请求将会被如何执行&lt;/em>。&lt;/p>
&lt;ul>
&lt;li>一个应用如果想让一个菜单与一个按钮代表同一项功能，只需让它们共享相应具体 Command 子类的同一个实例即可&lt;/li>
&lt;li>可以动态地替换 Command 对象，这可用于实现上下文有关的菜单&lt;/li>
&lt;li>可通过将几个命令组成更大的命令的形式来支持命令脚本&lt;/li>
&lt;/ul>
&lt;h3 id="适用性">适用性
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>抽象出待执行的动作以参数化某对象（Command 模式是回调机制的一个面向对象的替代品）&lt;/li>
&lt;li>在不同的时刻指定、排列和执行请求。一个 Command 对象可以有一个与初始请求无关的生存期。&lt;/li>
&lt;li>支持取消操作：Command 的 Excute 操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。&lt;/li>
&lt;li>支持修改日志：当系统崩溃后，可从磁盘中重新读入记录下来的命令并用 Execute 操作重新执行它们。（Command 接口中需添加装载操作和存储操作）&lt;/li>
&lt;li>用构建在原语操作上的高层操作构造一个系统：在支持事务（transaction）的信息系统中，一个事务封装了对数据的一组变动。
&lt;ul>
&lt;li>Command 模式提供了对事务进行建模的方法。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.2-Command%E3%80%8CAction,Transaction%E3%80%8D-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-%E5%8A%A8%E4%BD%9C%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-2023-10-08_10-57-10-433.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>Command：操作的接口&lt;/li>
&lt;li>ConcreteCommand：将一个接收者对象绑定于一个动作，调用接收者相应的操作，以实现 Execute&lt;/li>
&lt;li>Invoker（示例中的MenuItem）：要求该命令执行这个请求&lt;/li>
&lt;li>Receiver（示例中的 Document）：知道如何实施与执行一个请求相关的操作&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>工作流程&lt;/strong>：&lt;/p></description></item><item><title>5.7-Observer「publish-subscribe,dependent」-观察者-发布订阅-依赖</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.7-Observerpublish-subscribedependent-%E8%A7%82%E5%AF%9F%E8%80%85-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85-%E4%BE%9D%E8%B5%96/</link><pubDate>Thu, 28 Mar 2024 15:49:57 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.7-Observerpublish-subscribedependent-%E8%A7%82%E5%AF%9F%E8%80%85-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85-%E4%BE%9D%E8%B5%96/</guid><description>&lt;h3 id="用途">用途
&lt;a class="header-anchor" href="#%e7%94%a8%e9%80%94">&lt;/a>
&lt;/h3>&lt;p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新&lt;/p>
&lt;h3 id="示例">示例
&lt;a class="header-anchor" href="#%e7%a4%ba%e4%be%8b">&lt;/a>
&lt;/h3>&lt;p>将一个系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的一致性&lt;/p>

 &lt;blockquote>
 &lt;p>视图 View 依赖数据 Data
一个目标 Subject/publish 可以有任意数目的依赖它的观察者 Observer/subscribe。一旦目标的状态发生改变，所有的观察者都得到通知。
收到通知后，每个观察者都将查询目标以使其状态与目标的状态同步。&lt;/p>
 &lt;/blockquote>
&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.7-Observer%E3%80%8Cpublish-subscribe,dependent%E3%80%8D-%E8%A7%82%E5%AF%9F%E8%80%85-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85-%E4%BE%9D%E8%B5%96/image-2023-10-13_18-16-12-168.png" alt="" />&lt;/p>
&lt;h3 id="适用性">适用性
&lt;a class="header-anchor" href="#%e9%80%82%e7%94%a8%e6%80%a7">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中，以使它们可以各自独立地改变和复用。&lt;/li>
&lt;li>对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。&lt;/li>
&lt;li>一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，你不希望这些对象是紧密耦合的。&lt;/li>
&lt;/ul>
&lt;h3 id="结构">结构
&lt;a class="header-anchor" href="#%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.7-Observer%E3%80%8Cpublish-subscribe,dependent%E3%80%8D-%E8%A7%82%E5%AF%9F%E8%80%85-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85-%E4%BE%9D%E8%B5%96/image-2023-10-13_18-18-30-331.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>Subject（目标）
&lt;ul>
&lt;li>目标知道它的观察者。可以有任意多个观察者观察同一个目标。&lt;/li>
&lt;li>状态改变时，通知自身的观察者&lt;/li>
&lt;li>提供注册和删除观察者对象的接口。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ConcreteSubject（具体目标）：
&lt;ul>
&lt;li>为观察者提供获取/设置状态的接口&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Observer（观察者）：为那些在目标发生改变时需要获得通知的对象定义一个更新接口。&lt;/li>
&lt;li>ConcreteObserver：
&lt;ul>
&lt;li>维护一个指向 ConcreteSubject 对象的引用&lt;/li>
&lt;li>存储状态，这些状态与 ConcreteSubject 的状态保持一致&lt;/li>
&lt;li>实现 Observer 的更新接口，以使自身状态与目标的状态保持一致。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>交互时序&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>当 ConcreteSubject 发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者。&lt;/li>
&lt;li>在得到一个具体目标的改变通知后，ConcreteObserver 对象可向目标对象查询信息。ConcreteObserver 使用这些信息使它的状态与目标对象的状态一致。
&lt;img src="/imgs/img-lazy-loading.gif" data-src="./assets/5.7-Observer%E3%80%8Cpublish-subscribe,dependent%E3%80%8D-%E8%A7%82%E5%AF%9F%E8%80%85-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85-%E4%BE%9D%E8%B5%96/image-2023-10-13_18-26-01-479.png" alt="" />&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>注意&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>观察者 setState 后不会立即更新自身状态，而是等到被 notify 后再更新&lt;/li>
&lt;li>Notify 不总是由目标对象调用，它也可被一个观察者或其他对象调用。&lt;/li>
&lt;/ul>
&lt;h3 id="效果">效果
&lt;a class="header-anchor" href="#%e6%95%88%e6%9e%9c">&lt;/a>
&lt;/h3>&lt;p>Publisher 和 Subscriber 彼此独立，允许增加新的观察者而无需对现有的 Publisher/Subscriber 做任何修改&lt;/p>
&lt;ul>
&lt;li>低耦合：一个目标所知道的仅仅是它有一系列观察者，每个都符合抽象的 Observer 类的简单接口，而不知道其具体类型
&lt;ul>
&lt;li>一个处于较低层次的目标对象可与一个处于较高层次的观察者通信并通知它，反之则不行：
&lt;ul>
&lt;li>如果目标和观察者混在一块，那么得到的对象要么横贯两个层次（违反了层次性），要么必须放在这两层的某一层中（这可能会损害层次抽象）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>支持广播通信&lt;/li>
&lt;li>意外的更新：
&lt;ul>
&lt;li>在目标上一个看似无害的的操作可能会引起一系列对观察者以及依赖于这些观察者的对象的更新&lt;/li>
&lt;li>如果依赖准则的定义或维护不当，常常会引起错误的更新，这种错误通常很难捕捉。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="实现">实现
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0">&lt;/a>
&lt;/h3>&lt;p>&lt;strong>创建目标到其观察者之间的映射&lt;/strong>：&lt;/p></description></item><item><title>LeetCode刷题记录-动态规划</title><link>/post/Work/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E9%A2%98%E7%9B%AE/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link><pubDate>Sat, 17 Feb 2024 16:50:13 +0000</pubDate><guid>/post/Work/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E9%A2%98%E7%9B%AE/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid><description>&lt;h1 id="动态规划问题">动态规划问题
&lt;a class="header-anchor" href="#%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e9%97%ae%e9%a2%98">&lt;/a>
&lt;/h1>&lt;p>这类问题的求解思路是：&lt;/p>
&lt;ul>
&lt;li>先尝试有 Cache 的暴力搜索，列出递推式&lt;/li>
&lt;li>将上述搜索转化为使用 dp 数组的方法&lt;/li>
&lt;/ul>
&lt;h3 id="70-爬楼梯">
&lt;a href="https://leetcode.cn/problems/climbing-stairs/description/" title="70. 爬楼梯" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 70. 爬楼梯
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>
&lt;a class="header-anchor" href="#70-%e7%88%ac%e6%a5%bc%e6%a2%af">&lt;/a>
&lt;/h3>&lt;p>假设你正在爬楼梯。需要 &lt;code>n&lt;/code> 阶你才能到达楼顶。
每次你可以爬 &lt;code>1&lt;/code> 或 &lt;code>2&lt;/code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p>
&lt;div class="math display">
\begin{cases}
f(n)=f(n-2)+f(n-1)\\
f(&lt;=0)=0,f(1)=1,f(2)=2
\end{cases}
&lt;/div>
&lt;h3 id="746-使用最小花费爬楼梯">
&lt;a href="https://leetcode.cn/problems/min-cost-climbing-stairs/" title="746. 使用最小花费爬楼梯" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 746. 使用最小花费爬楼梯
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>
&lt;a class="header-anchor" href="#746-%e4%bd%bf%e7%94%a8%e6%9c%80%e5%b0%8f%e8%8a%b1%e8%b4%b9%e7%88%ac%e6%a5%bc%e6%a2%af">&lt;/a>
&lt;/h3>&lt;p>给你一个整数数组 &lt;code>cost&lt;/code> ，其中 &lt;code>cost[i]&lt;/code> 是从楼梯第 &lt;code>i&lt;/code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
你可以选择从下标为 &lt;code>0&lt;/code> 或下标为 &lt;code>1&lt;/code> 的台阶开始爬楼梯。
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。&lt;/p>
&lt;ul>
&lt;li>支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。&lt;/li>
&lt;/ul>
&lt;h3 id="62-不同路径">
&lt;a href="https://leetcode.cn/problems/unique-paths/" title="62. 不同路径" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 62. 不同路径
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>
&lt;a class="header-anchor" href="#62-%e4%b8%8d%e5%90%8c%e8%b7%af%e5%be%84">&lt;/a>
&lt;/h3>&lt;p>一个机器人位于一个 &lt;code>m x n&lt;/code> 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？&lt;/p></description></item></channel></rss>