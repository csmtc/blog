<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CSMTC Blog</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on CSMTC Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 11 Mar 2025 23:51:38 +0800</lastBuildDate><atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>My First Post</title>
      <link>http://localhost:1313/post/my-first-post/</link>
      <pubDate>Tue, 11 Mar 2025 23:51:38 +0800</pubDate>
      
      <guid>http://localhost:1313/post/my-first-post/</guid>
      <description>
        
          
            &lt;p&gt;尝试使用Hugo进行博客创作吧~&lt;/p&gt;
&lt;p&gt;$\alpha$&lt;/p&gt;
&lt;p&gt;$$
x = sin(y)
$$&lt;/p&gt;
          
          
        
      </description>
    </item>
    
    <item>
      <title>LeetCode刷题记录-动态规划</title>
      <link>http://localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E9%A2%98%E7%9B%AE/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Mon, 17 Feb 2025 16:50:13 +0000</pubDate>
      
      <guid>http://localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E9%A2%98%E7%9B%AE/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>
        
          
            &lt;h1 id=&#34;动态规划问题&#34;&gt;动态规划问题&lt;/h1&gt;
&lt;p&gt;这类问题的求解思路是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先尝试有 Cache 的暴力搜索，列出递推式&lt;/li&gt;
&lt;li&gt;将上述搜索转化为使用 dp 数组的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;70-爬楼梯&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/climbing-stairs/description/&#34;&gt;70. 爬楼梯&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;假设你正在爬楼梯。需要 &lt;code&gt;n&lt;/code&gt; 阶你才能到达楼顶。
每次你可以爬 &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;2&lt;/code&gt; 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;746-使用最小花费爬楼梯&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/min-cost-climbing-stairs/&#34;&gt;746. 使用最小花费爬楼梯&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;cost&lt;/code&gt; ，其中 &lt;code&gt;cost[i]&lt;/code&gt; 是从楼梯第 &lt;code&gt;i&lt;/code&gt; 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
你可以选择从下标为 &lt;code&gt;0&lt;/code&gt; 或下标为 &lt;code&gt;1&lt;/code&gt; 的台阶开始爬楼梯。
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;62-不同路径&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/unique-paths/&#34;&gt;62. 不同路径&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个机器人位于一个 &lt;code&gt;m x n&lt;/code&gt; 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？&lt;/p&gt;
&lt;p&gt;设 $dp[i][j]$ 表示由 (0,0) 走到(i,j)的路径数目
$$
\begin{cases}
dp[i][j]=0,i&amp;lt;=0||j&amp;lt;=0\
dp[i][j]=dp[i][j-1]+dp[i-1][j]
\end{cases}
$$&lt;/p&gt;
          
          
        
      </description>
    </item>
    
    <item>
      <title>LeetCode刷题记录-贪心</title>
      <link>http://localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E9%A2%98%E7%9B%AE/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E8%B4%AA%E5%BF%83/</link>
      <pubDate>Thu, 25 Jul 2024 17:13:03 +0000</pubDate>
      
      <guid>http://localhost:1313/post/work/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E9%A2%98%E7%9B%AE/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E8%B4%AA%E5%BF%83/</guid>
      <description>
        
          
            &lt;h3 id=&#34;55-跳跃游戏&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/jump-game/description/&#34;&gt;55. 跳跃游戏&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一个非负整数数组 &lt;code&gt;nums&lt;/code&gt; ，你最初位于数组的 &lt;strong&gt;第一个下标&lt;/strong&gt; 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标，如果可以，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;核心策略：看覆盖范围，覆盖范围内⼀定是可以跳过来的，不⽤管是怎么跳的。问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点。&lt;/p&gt;
&lt;h3 id=&#34;45-跳跃游戏-ii&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/jump-game-ii/description&#34;&gt;45. 跳跃游戏 II&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给定一个长度为 &lt;code&gt;n&lt;/code&gt; 的 &lt;strong&gt;0 索引&lt;/strong&gt;整数数组 &lt;code&gt;nums&lt;/code&gt;。初始位置为 &lt;code&gt;nums[0]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;每个元素 &lt;code&gt;nums[i]&lt;/code&gt; 表示从索引 &lt;code&gt;i&lt;/code&gt; 向前跳转的最大长度。换句话说，如果你在 &lt;code&gt;nums[i]&lt;/code&gt; 处，你可以跳转到任意 &lt;code&gt;nums[i + j]&lt;/code&gt; 处:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= j &amp;lt;= nums[i]&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;i + j &amp;lt; n&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回到达 &lt;code&gt;nums[n - 1]&lt;/code&gt; 的最小跳跃次数。生成的测试用例保证可以到达 &lt;code&gt;nums[n - 1]&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;核心策略：同样看覆盖范围，当前下标达到了上次跳跃的最大位置，且未达到终点，则需要跳跃一次。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (nums.size() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; max_pos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, last_max_pos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, cnt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, target &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums.size() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; target; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 跳跃的情况：当前下标达到了上次跳跃的最大位置，且未达到终点，则需要跳跃一次
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  max_pos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(max_pos, i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nums[i]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; last_max_pos) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;cnt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    last_max_pos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max_pos;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (last_max_pos &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; target)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;134-加油站&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/gas-station/&#34;&gt;134. 加油站&lt;/a&gt;&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;情况⼀：如果 gas 的总和⼩于 cost 总和，那么⽆论从哪⾥出发，⼀定是跑不了⼀圈的
情况⼆：rest[i] = gas[i]-cost[i]为⼀天剩下的油，i 从 0 开始计算累加到最后⼀站，如果累加没有出现负数，说明从 0 出发，油就没有断过，那么 0 就是起点。
情况三：如果累加的最⼩值是负数，汽⻋就要从⾮0 节点出发，从后向前，看哪个节点能把这个负数填平，能把这个负数填平的节点就是出发节点。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;376-摆动序列&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/wiggle-subsequence/&#34;&gt;376. 摆动序列&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。&lt;/p&gt;
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
